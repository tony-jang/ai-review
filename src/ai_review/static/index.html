<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Review</title>
<link rel="stylesheet" href="/vendor/starry-night-dark.css">
<style>
:root {
  --bg: #0D1117;
  --card: #161B22;
  --border: #30363D;
  --text: #E6EDF3;
  --text-muted: #8B949E;
  --severity-critical: #EF4444;
  --severity-high: #F97316;
  --severity-medium: #EAB308;
  --severity-low: #6B7280;
  --severity-dismissed: #22C55E;
  --model-opus: #8B5CF6;
  --model-gpt: #22C55E;
  --model-gemini: #3B82F6;
  --model-deepseek: #F97316;
  --accent: #58A6FF;
  --diff-add-bg: rgba(63,185,80,0.15);
  --diff-del-bg: rgba(248,81,73,0.15);
  --diff-add-text: #3fb950;
  --diff-del-text: #f85149;
  --diff-hunk-bg: rgba(56,139,253,0.15);
  --diff-hunk-text: #58a6ff;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; flex-direction: column; }

.header { display: flex; align-items: center; gap: 16px; padding: 12px 20px; border-bottom: 1px solid var(--border); background: var(--card); }
.header h1 { font-size: 16px; font-weight: 600; }
.header .branch { color: var(--accent); font-size: 13px; }
.header .stats { margin-left: auto; font-size: 13px; color: var(--text-muted); display: flex; gap: 16px; align-items: center; }

.step-indicator { display: flex; align-items: center; padding: 6px 20px; border-bottom: 1px solid var(--border); background: var(--card); }
.step-item { display: flex; flex-direction: column; align-items: center; position: relative; }
.step-dot { width: 20px; height: 20px; border-radius: 50%; border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; font-size: 10px; color: transparent; transition: all 0.3s ease; flex-shrink: 0; }
.step-dot.active { border-color: var(--accent); background: var(--accent); color: #fff; animation: step-pulse 1.5s ease-in-out infinite; }
.step-dot.done { border-color: var(--accent); background: var(--accent); color: #fff; }
.step-connector { flex: 1; height: 2px; background: var(--border); margin: 0 4px; transition: background 0.3s ease; align-self: center; min-width: 16px; }
.step-connector.done { background: var(--accent); }
.step-label { font-size: 11px; color: var(--text-muted); margin-top: 2px; white-space: nowrap; }
.step-label.active { color: var(--accent); font-weight: 600; }
.step-label.done { color: var(--accent); }
.step-detail { font-size: 10px; color: var(--accent); margin-top: 1px; white-space: nowrap; }
@keyframes step-pulse { 0%,100% { box-shadow: 0 0 0 0 rgba(88,166,255,0.4); } 50% { box-shadow: 0 0 0 6px rgba(88,166,255,0); } }

.main { display: flex; flex: 1; min-height: 0; overflow: hidden; }

/* Issue list */
.issue-list { overflow-y: auto; overflow-x: hidden; flex: 1; min-height: 0; }
.issue-item { padding: 10px 14px; border-bottom: 1px solid var(--border); cursor: pointer; display: flex; align-items: flex-start; gap: 8px; transition: background 0.15s; }
.issue-item:hover { background: rgba(88,166,255,0.06); }
.issue-item.active { background: rgba(88,166,255,0.1); border-left: 3px solid var(--accent); }
.issue-item.issue-item-flash { animation: issue-item-flash 1s ease; }
@keyframes issue-item-flash {
  0% { box-shadow: inset 0 0 0 0 rgba(88,166,255,0.7); background: rgba(88,166,255,0.22); }
  60% { box-shadow: inset 0 0 0 2px rgba(88,166,255,0.55); background: rgba(88,166,255,0.18); }
  100% { box-shadow: inset 0 0 0 0 rgba(88,166,255,0); background: inherit; }
}
.opinion-flash { animation: opinion-flash-anim 1.2s ease; }
@keyframes opinion-flash-anim {
  0% { box-shadow: inset 0 0 0 2px rgba(88,166,255,0.8); background: rgba(88,166,255,0.15); }
  100% { box-shadow: inset 0 0 0 0 rgba(88,166,255,0); background: inherit; }
}
.issue-icon { font-size: 12px; margin-top: 3px; }
.issue-info { flex: 1; min-width: 0; }
.issue-title { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.issue-meta { font-size: 11px; color: var(--text-muted); margin-top: 2px; display: flex; gap: 6px; align-items: center; }
.severity-badge { font-size: 10px; padding: 1px 5px; border-radius: 8px; font-weight: 600; text-transform: uppercase; }

/* Detail panel */
.right-panel { flex: 1; min-width: 0; min-height: 0; overflow: hidden; display: flex; flex-direction: column; }
.detail-view-bar { display: flex; gap: 8px; padding: 8px 12px; border-bottom: 1px solid var(--border); background: var(--card); align-items: center; }
.detail-view-group { display: inline-flex; gap: 8px; align-items: center; min-width: 0; }
.detail-view-btn { padding: 6px 10px; border: 1px solid var(--border); border-radius: 7px; background: var(--bg); color: var(--text-muted); font-size: 12px; font-weight: 600; cursor: pointer; flex: 0 0 auto; }
.detail-view-btn:hover { border-color: var(--accent); color: var(--accent); }
.detail-view-btn.active { border-color: var(--accent); background: rgba(88,166,255,0.16); color: var(--accent); }
.right-main-layout { flex: 1; min-height: 0; min-width: 0; overflow: hidden; display: flex; }
.right-content { flex: 1 1 auto; min-width: 0; min-height: 0; display: flex; flex-direction: column; overflow: hidden; }
.issue-detail { flex: 1; overflow-y: auto; overflow-x: hidden; }
.right-side-splitter { width: 4px; cursor: col-resize; background: var(--border); transition: background 0.15s; flex-shrink: 0; }
.right-side-splitter:hover, .right-side-splitter.active { background: var(--accent); }
.reviewers-sidebar { width: 420px; min-width: 320px; max-width: 900px; min-height: 0; overflow: hidden; border-left: 1px solid var(--border); background: var(--card); display: flex; flex-direction: column; flex-shrink: 0; }
.reviewers-header { padding: 10px 12px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; }
.reviewers-title-wrap { min-width: 0; display: flex; align-items: baseline; gap: 6px; }
.reviewers-title { font-size: 12px; font-weight: 700; color: var(--text); letter-spacing: 0.2px; }
.reviewers-count { font-size: 11px; color: var(--text-muted); }
.reviewers-list { flex: 1 1 auto; min-height: 0; overflow-y: auto; overflow-x: hidden; overscroll-behavior: contain; scrollbar-gutter: stable; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
.reviewers-empty { border: 1px dashed var(--border); border-radius: 8px; padding: 14px 10px; text-align: center; font-size: 12px; color: var(--text-muted); line-height: 1.5; }
.reviewers-list > * { flex-shrink: 0; }
.reviewer-card { width: 100%; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); color: var(--text); overflow: hidden; transition: border-color 0.15s, background 0.15s; }
.reviewer-card:hover { border-color: var(--accent); }
.reviewer-card.expanded { border-color: rgba(88,166,255,0.5); }
.reviewer-toggle { width: 100%; border: none; background: transparent; color: inherit; text-align: left; cursor: pointer; padding: 9px 10px; }
.reviewer-toggle:hover { background: rgba(88,166,255,0.08); }
.reviewer-card.expanded .reviewer-toggle { border-bottom: 1px solid var(--border); }
.reviewer-top { display: flex; align-items: center; gap: 6px; }
.reviewer-name { font-size: 12px; font-weight: 700; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.reviewer-role { font-size: 10px; color: var(--text-muted); max-width: 40%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.reviewer-status { margin-left: auto; font-size: 10px; border: 1px solid var(--border); border-radius: 999px; padding: 1px 6px; color: var(--text-muted); flex-shrink: 0; }
.reviewer-more { border: 1px solid var(--border); background: var(--bg); color: var(--text-muted); border-radius: 6px; font-size: 11px; line-height: 1; padding: 2px 7px; cursor: pointer; flex-shrink: 0; }
.reviewer-more:hover { border-color: var(--accent); color: var(--accent); background: rgba(88,166,255,0.12); }
.reviewer-caret { margin-left: 6px; font-size: 11px; color: var(--text-muted); flex-shrink: 0; }
.reviewer-meta { margin-top: 7px; display: flex; align-items: center; flex-wrap: wrap; gap: 5px; }
.reviewer-time { margin-left: auto; font-size: 10px; color: var(--text-muted); font-family: 'SF Mono', Monaco, monospace; }
.reviewer-issues { padding: 8px 9px 9px; background: rgba(255,255,255,0.015); display: grid; gap: 6px; }
.reviewer-issues-empty { border: 1px dashed var(--border); border-radius: 6px; padding: 10px 8px; text-align: center; font-size: 11px; color: var(--text-muted); }
.reviewer-issue-item { width: 100%; border: 1px solid var(--border); border-radius: 6px; background: var(--card); padding: 7px 8px; cursor: pointer; transition: border-color 0.15s, background 0.15s; }
.reviewer-issue-item:hover { border-color: var(--accent); background: rgba(88,166,255,0.07); }
.reviewer-issue-main { min-width: 0; width: 100%; display: grid; grid-template-columns: minmax(0, 1fr) auto; align-items: center; gap: 8px; overflow: hidden; }
.reviewer-issue-title { display: block; font-size: 12px; color: var(--text); min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.reviewer-opinion-badge { border: 1px solid var(--border); border-radius: 4px; padding: 1px 6px; font-size: 10px; font-weight: 700; white-space: nowrap; justify-self: end; flex-shrink: 0; }
.reviewer-opinion-raise { border-color: rgba(88,166,255,0.45); color: var(--accent); background: rgba(88,166,255,0.1); }
.reviewer-opinion-fix-required { border-color: rgba(34,197,94,0.45); color: #22C55E; background: rgba(34,197,94,0.1); }
.reviewer-opinion-no-fix { border-color: rgba(239,68,68,0.45); color: #EF4444; background: rgba(239,68,68,0.1); }
.reviewer-opinion-comment { border-color: rgba(234,179,8,0.45); color: #EAB308; background: rgba(234,179,8,0.1); }
.reviewer-status-reviewing { border-color: rgba(88,166,255,0.5); }
.reviewer-status-reviewing .model-dot { animation: agent-pulse 1.4s infinite; }
.reviewer-status-submitted { border-color: rgba(34,197,94,0.45); }
.reviewer-status-submitted .model-dot { background: #22C55E !important; }
.reviewer-status-failed { border-color: rgba(239,68,68,0.45); }
.reviewer-status-failed .model-dot { background: #EF4444 !important; }
.reviewer-activity {
  font-size: 11px;
  color: var(--text-muted, #888);
  padding: 2px 8px 4px 24px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  opacity: 0.8;
  transition: opacity 0.3s;
}
.reviewer-timeline { padding: 4px 8px 6px 24px; border-top: 1px solid var(--border); max-height: 120px; overflow-y: auto; }
.timeline-entry { font-size: 11px; color: var(--text-muted); padding: 2px 0; display: flex; gap: 6px; align-items: baseline; }
.timeline-entry .timeline-time { flex-shrink: 0; font-size: 10px; font-family: 'SF Mono', Monaco, monospace; opacity: 0.7; min-width: 40px; }
.timeline-entry .timeline-action { font-weight: 500; color: var(--text); }
.timeline-entry .timeline-target { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; }
.file-agent-dots { display: inline-flex; gap: 2px; margin-left: 4px; vertical-align: middle; }
.file-agent-dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; }
.activity-stats { font-size: 11px; color: var(--text-muted); padding: 0 4px; }
@media (max-width: 1200px) {
  .right-main-layout { flex-direction: column; }
  .right-side-splitter { display: none; }
  .reviewers-sidebar { width: auto; max-width: none; border-left: none; border-top: 1px solid var(--border); height: 38vh; min-height: 220px; max-height: 420px; }
}
.agent-session-board { padding: 14px 16px; display: grid; gap: 10px; }
.agent-session-card { border: 1px solid var(--border); border-radius: 10px; background: var(--card); padding: 10px 12px; }
.agent-session-head { display: flex; align-items: center; gap: 7px; flex-wrap: wrap; }
.agent-session-name { font-size: 13px; font-weight: 700; }
.agent-session-role { font-size: 11px; color: var(--text-muted); }
.agent-session-status { font-size: 10px; border-radius: 999px; padding: 2px 7px; border: 1px solid var(--border); color: var(--text-muted); }
.agent-session-summary { margin-top: 8px; font-size: 13px; color: var(--text); line-height: 1.5; }
.agent-session-summary > p:first-child { margin-top: 0; }
.agent-session-summary > p:last-child { margin-bottom: 0; }
.agent-session-empty { margin-top: 8px; font-size: 12px; color: var(--text-muted); }

.detail-header-bar { padding: 16px 20px; border-bottom: 1px solid var(--border); background: var(--card); }
.detail-header-bar.detail-flash { animation: detail-header-flash 1s ease; }
@keyframes detail-header-flash {
  0% { background: rgba(88,166,255,0.25); }
  100% { background: var(--card); }
}
.detail-title { font-size: 16px; font-weight: 600; margin-bottom: 6px; }
.detail-file { font-size: 13px; color: var(--accent); font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; }
.detail-badges { margin-top: 8px; display: flex; gap: 8px; align-items: center; }

/* Diff view */
.diff-container { border-bottom: 1px solid var(--border); overflow-x: auto; overflow-y: hidden; }
.diff-file-header { padding: 8px 16px; background: var(--card); border-bottom: 1px solid var(--border); font-size: 12px; font-family: 'SF Mono', Monaco, monospace; color: var(--text-muted); display: flex; align-items: center; gap: 8px; }
.diff-file-header .filename { color: var(--text); font-weight: 500; }
.diff-table { width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 12px; line-height: 20px; min-width: 100%; }
.diff-table td { padding: 0 12px; vertical-align: top; }
.diff-line-num { width: 50px; min-width: 50px; text-align: right; color: var(--text-muted); user-select: none; opacity: 0.5; white-space: nowrap; }
.diff-line-content { width: 100%; white-space: pre-wrap; }
.diff-file-meta { margin-left: auto; display: inline-flex; align-items: center; gap: 6px; font-size: 12px; }
.diff-file-meta .add { color: var(--diff-add-text); }
.diff-file-meta .del { color: var(--diff-del-text); }
.diff-file-meta .chg { color: var(--accent); }
.diff-add { background: var(--diff-add-bg); }
.diff-add .diff-line-content { color: var(--text); }
.diff-del { background: var(--diff-del-bg); }
.diff-del .diff-line-content { color: var(--text); }
.diff-line-content .diff-prefix { opacity: 0.85; margin-right: 4px; }
.diff-line-content .diff-prefix { user-select: none; -webkit-user-select: none; pointer-events: none; }
.diff-add .diff-prefix { color: var(--diff-add-text); font-weight: 600; }
.diff-del .diff-prefix { color: var(--diff-del-text); font-weight: 600; }
.diff-line-content .diff-code .hljs-comment,
.diff-line-content .diff-code .hljs-quote { color: #8b949e; font-style: italic; }
.diff-line-content .diff-code .hljs-keyword,
.diff-line-content .diff-code .hljs-selector-tag,
.diff-line-content .diff-code .hljs-literal,
.diff-line-content .diff-code .hljs-meta .hljs-keyword { color: #ff7b72; }
.diff-line-content .diff-code .hljs-string,
.diff-line-content .diff-code .hljs-doctag,
.diff-line-content .diff-code .hljs-regexp { color: #a5d6ff; }
.diff-line-content .diff-code .hljs-title,
.diff-line-content .diff-code .hljs-section,
.diff-line-content .diff-code .hljs-name,
.diff-line-content .diff-code .hljs-selector-id,
.diff-line-content .diff-code .hljs-selector-class { color: #d2a8ff; }
.diff-line-content .diff-code .hljs-attr,
.diff-line-content .diff-code .hljs-attribute,
.diff-line-content .diff-code .hljs-variable,
.diff-line-content .diff-code .hljs-template-variable,
.diff-line-content .diff-code .hljs-type,
.diff-line-content .diff-code .hljs-built_in { color: #79c0ff; }
.diff-line-content .diff-code .hljs-number,
.diff-line-content .diff-code .hljs-symbol,
.diff-line-content .diff-code .hljs-bullet { color: #79c0ff; }
.diff-line-content .diff-code .hljs-addition { color: #3fb950; }
.diff-line-content .diff-code .hljs-deletion { color: #f85149; }
.diff-line-content .diff-code .diff-tok-comment { color: #8b949e; font-style: italic; }
.diff-line-content .diff-code .diff-tok-keyword { color: #ff7b72; }
.diff-line-content .diff-code .diff-tok-string { color: #a5d6ff; }
.diff-line-content .diff-code .diff-tok-number { color: #79c0ff; }
.diff-hunk { background: var(--diff-hunk-bg); }
.diff-hunk td { color: var(--diff-hunk-text); font-style: italic; padding: 4px 12px; }
.diff-context td { color: var(--text-muted); }
.diff-split-table { table-layout: fixed; }
.diff-split-table td { padding: 0 10px; }
.diff-split-old-num,
.diff-split-new-num { width: 46px; min-width: 46px; }
.diff-split-old-content,
.diff-split-new-content { width: calc(50% - 46px); overflow: visible; }
.diff-split-old-content { padding-right: 14px; }
.diff-split-new-content { padding-left: 14px; }
.diff-split-old-content .diff-code,
.diff-split-new-content .diff-code {
  display: inline;
  overflow: visible;
  vertical-align: top;
}
.diff-split-new-num,
.diff-split-new-content { border-left: 1px solid var(--border); }
.diff-split-table td.diff-add { background: var(--diff-add-bg); }
.diff-split-table td.diff-del { background: var(--diff-del-bg); }
.diff-split-table td.diff-context { background: transparent; color: var(--text-muted); }
.diff-split-table td.diff-empty { background: rgba(255,255,255,0.02); color: var(--text-muted); }
.diff-split-row-stack td { border-top: 1px dashed rgba(255,255,255,0.06); }
/* Issue marker on diff line — GitHub-style yellow highlight */
tr.diff-issue-marker > td { background: rgba(187, 128, 9, 0.15) !important; }
tr.diff-issue-marker > td.diff-line-num { color: var(--text); opacity: 0.7; }
td.diff-issue-marker { background: rgba(187, 128, 9, 0.15) !important; }
td.diff-issue-marker.diff-line-num { color: var(--text); opacity: 0.7; }
.diff-loading { padding: 24px; text-align: center; color: var(--text-muted); font-size: 13px; }

/* Thread panel */
.thread-panel { padding: 16px 20px; }
.thread-title { font-size: 13px; font-weight: 600; color: var(--text-muted); margin-bottom: 12px; letter-spacing: 0.5px; }
.issue-origin-panel { padding: 14px 20px; border-bottom: 1px solid var(--border); background: linear-gradient(180deg, rgba(88,166,255,0.08), rgba(88,166,255,0.02)); }
.issue-origin-head { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 12px; }
.issue-origin-title { font-size: 12px; font-weight: 700; color: var(--accent); letter-spacing: 0.2px; }
.issue-origin-meta { margin-left: auto; font-size: 11px; color: var(--text-muted); font-family: 'SF Mono', Monaco, monospace; }
.issue-origin-body { border: 1px solid rgba(88,166,255,0.35); border-radius: 8px; background: rgba(13,17,23,0.6); padding: 12px; }
.issue-origin-suggestion { margin-top: 10px; }
.opinion { padding: 12px 14px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; }
.opinion-header { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; font-size: 12px; }
.opinion-time { margin-left: auto; color: var(--text-muted); font-size: 11px; font-family: 'SF Mono', Monaco, monospace; }
.model-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
.model-name { font-weight: 600; }
.action-badge { font-size: 10px; padding: 2px 6px; border-radius: 8px; font-weight: 600; text-transform: uppercase; }
.action-raise { background: rgba(239,68,68,0.15); color: var(--severity-critical); }
.action-fix_required { background: rgba(34,197,94,0.15); color: var(--severity-dismissed); }
.action-no_fix { background: rgba(239,68,68,0.15); color: var(--severity-critical); }
.action-false_positive { background: rgba(168,85,247,0.15); color: #A855F7; }
.action-withdraw { background: rgba(107,114,128,0.15); color: #6B7280; }
.action-comment { background: rgba(234,179,8,0.15); color: var(--severity-medium); }
/* backward compat */
.action-agree { background: rgba(34,197,94,0.15); color: var(--severity-dismissed); }
.action-disagree { background: rgba(239,68,68,0.15); color: var(--severity-critical); }
.action-clarify { background: rgba(234,179,8,0.15); color: var(--severity-medium); }
.opinion-text { font-size: 13px; line-height: 1.55; color: var(--text); white-space: pre-wrap; word-break: break-word; }
.opinion-text strong { font-weight: 700; }
.opinion-text em { font-style: italic; }
.opinion-text del { text-decoration: line-through; opacity: 0.9; }
.opinion-text code { background: rgba(110,118,129,0.2); border: 1px solid var(--border); border-radius: 4px; padding: 1px 5px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }
.opinion-text pre { background: #0b0f14; border: 1px solid var(--border); border-radius: 6px; padding: 8px 10px; margin: 6px 0; overflow-x: auto; white-space: pre; }
.opinion-text pre code { background: none; border: none; padding: 0; font-size: 12px; }
.mention-link { display: inline-flex; align-items: center; gap: 5px; border-radius: 999px; padding: 1px 8px; font-size: 11px; cursor: pointer; font-family: inherit; line-height: 1.3; max-width: min(100%, 420px); vertical-align: baseline; }
.mention-link .mention-main { font-weight: 600; white-space: nowrap; }
.mention-link .mention-meta { opacity: 0.92; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; }
.mention-link.mention-issue { border: 1px solid rgba(88,166,255,0.45); background: rgba(88,166,255,0.14); color: var(--accent); }
.mention-link.mention-issue:hover { background: rgba(88,166,255,0.23); }
.mention-link.mention-agent { border: 1px solid rgba(34,197,94,0.45); background: rgba(34,197,94,0.14); color: var(--severity-dismissed); }
.mention-link.mention-agent:hover { background: rgba(34,197,94,0.24); }
.opinion-more { margin-top: 6px; background: none; border: none; color: var(--accent); font-size: 11px; cursor: pointer; padding: 0; }
.opinion-suggestion { font-size: 12px; margin-top: 6px; padding: 8px 10px; background: rgba(34,197,94,0.08); border-left: 3px solid var(--severity-dismissed); border-radius: 0 4px 4px 0; color: var(--diff-add-text); }

.consensus-box { margin: 12px 0; padding: 10px 14px; border-radius: 8px; border: 1px solid var(--border); display: flex; align-items: center; gap: 8px; font-size: 13px; font-weight: 600; }
.consensus-reached { background: rgba(34,197,94,0.1); border-color: var(--severity-dismissed); color: var(--severity-dismissed); }
.consensus-pending { background: rgba(234,179,8,0.1); border-color: var(--severity-medium); color: var(--severity-medium); }

/* Comment form */
.comment-form { padding: 16px 20px; border-top: 1px solid var(--border); }
.comment-form textarea { width: 100%; min-height: 80px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 10px 12px; font-size: 13px; font-family: inherit; resize: vertical; }
.comment-form textarea:focus { outline: none; border-color: var(--accent); }
.comment-actions { display: flex; gap: 8px; margin-top: 10px; align-items: center; }
.comment-actions .spacer { flex: 1; }
.btn { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--border); background: var(--card); color: var(--text); font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.15s; }
.btn:hover { background: var(--border); }
.btn:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-agree { border-color: #22C55E40; color: var(--severity-dismissed); }
.btn-agree:hover { background: rgba(34,197,94,0.15); }
.btn-disagree { border-color: #EF444440; color: var(--severity-critical); }
.btn-disagree:hover { background: rgba(239,68,68,0.15); }
.btn-comment { border-color: #EAB30840; color: var(--severity-medium); }
.btn-comment:hover { background: rgba(234,179,8,0.15); }
.btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); }
.btn-primary:hover { background: #4C9AFF; }
.btn-finish { background: #22C55E; color: #fff; border-color: #22C55E; }
.btn-finish:hover { background: #16A34A; }

/* Branch picker */
.branch-picker-trigger { display:flex; align-items:center; justify-content:space-between; background:var(--bg); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:8px 12px; font-size:13px; font-family:inherit; width:100%; cursor:pointer; text-align:left; }
.branch-picker-trigger:hover { border-color:var(--accent); }
.branch-picker-trigger .bp-arrow { color:var(--text-muted); font-size:10px; margin-left:8px; }
.branch-picker-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:1100; display:flex; align-items:center; justify-content:center; }
.branch-picker-card { background:var(--card); border:1px solid var(--border); border-radius:10px; width:340px; max-height:420px; display:flex; flex-direction:column; box-shadow:0 8px 32px rgba(0,0,0,0.4); }
.branch-picker-card .bp-search { background:var(--bg); color:var(--text); border:none; border-bottom:1px solid var(--border); padding:10px 14px; font-size:13px; font-family:inherit; width:100%; outline:none; border-radius:10px 10px 0 0; }
.branch-picker-card .bp-list { overflow-y:auto; flex:1; max-height:340px; }
.branch-picker-card .bp-group-label { padding:6px 14px; font-size:11px; color:var(--text-muted); font-weight:600; text-transform:uppercase; letter-spacing:0.5px; position:sticky; top:0; background:var(--card); }
.branch-picker-card .bp-item { padding:7px 14px; font-size:13px; cursor:pointer; display:flex; align-items:center; gap:8px; }
.branch-picker-card .bp-item:hover { background:rgba(88,166,255,0.08); }
.branch-picker-card .bp-item.selected { background:rgba(88,166,255,0.12); color:var(--accent); }
.branch-picker-card .bp-item .bp-check { width:14px; color:var(--accent); font-size:12px; }
.branch-picker-card .bp-empty { padding:20px 14px; text-align:center; color:var(--text-muted); font-size:13px; }

/* Assist chat */
.assist-section { border-top: 2px solid var(--accent); }
.assist-toggle { padding: 12px 20px; display: flex; align-items: center; gap: 8px; cursor: pointer; background: rgba(88,166,255,0.06); transition: background 0.15s; }
.assist-toggle:hover { background: rgba(88,166,255,0.1); }
.assist-toggle .label { font-size: 13px; font-weight: 600; color: var(--accent); }
.assist-toggle .hint { font-size: 11px; color: var(--text-muted); margin-left: auto; }
.assist-chat { display: none; }
.assist-chat.open { display: block; }
.assist-messages { padding: 16px 20px; max-height: 400px; overflow-y: auto; }
.assist-msg { margin-bottom: 12px; }
.assist-msg-user { display: flex; justify-content: flex-end; }
.assist-msg-user .bubble { background: var(--accent); color: #fff; border-radius: 12px 12px 2px 12px; padding: 8px 14px; max-width: 80%; font-size: 13px; line-height: 1.5; }
.assist-msg-ai { display: flex; justify-content: flex-start; }
.assist-msg-ai .bubble { background: var(--card); border: 1px solid var(--border); border-radius: 12px 12px 12px 2px; padding: 10px 14px; max-width: 90%; font-size: 13px; line-height: 1.6; white-space: pre-wrap; }
.assist-msg-ai .bubble code { background: rgba(110,118,129,0.2); padding: 1px 5px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }
.assist-msg-ai .bubble pre { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 10px 12px; margin: 8px 0; overflow-x: auto; }
.assist-msg-ai .bubble pre code { background: none; padding: 0; font-size: 12px; }
.assist-input-bar { padding: 12px 20px; border-top: 1px solid var(--border); display: flex; gap: 8px; align-items: flex-end; }
.assist-input { flex: 1; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; font-size: 13px; font-family: inherit; resize: none; min-height: 38px; max-height: 120px; }
.assist-input:focus { outline: none; border-color: var(--accent); }
.btn-assist-send { background: var(--accent); color: #fff; border: none; border-radius: 8px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; white-space: nowrap; }
.btn-assist-send:hover { background: #4C9AFF; }
.btn-assist-send:disabled { opacity: 0.4; cursor: not-allowed; }
.assist-thinking { padding: 8px 14px; color: var(--text-muted); font-size: 13px; display: flex; align-items: center; gap: 8px; }
.assist-thinking .dots { display: inline-flex; gap: 3px; }
.assist-thinking .dots span { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); animation: dot-pulse 1.4s infinite; }
.assist-thinking .dots span:nth-child(2) { animation-delay: 0.2s; }
.assist-thinking .dots span:nth-child(3) { animation-delay: 0.4s; }
@keyframes dot-pulse { 0%,80%,100%{opacity:0.3} 40%{opacity:1} }
.assist-cli { padding: 8px 20px 16px; }
.assist-cli-box { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 8px 12px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 8px; cursor: pointer; transition: border-color 0.15s; }
.assist-cli-box:hover { border-color: var(--accent); }
.assist-cli-box .cmd { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.assist-cli-box .copy-hint { color: var(--accent); font-size: 11px; white-space: nowrap; }

/* Report overlay */
.report-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 100; }
.report-card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto; }
.report-header { padding: 20px 24px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
.report-header h2 { font-size: 18px; }
.report-close { background: none; border: none; color: var(--text-muted); font-size: 20px; cursor: pointer; padding: 4px 8px; }
.report-close:hover { color: var(--text); }
.report-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; padding: 20px 24px; border-bottom: 1px solid var(--border); }
.report-stat { text-align: center; }
.report-stat .value { font-size: 28px; font-weight: 700; color: var(--accent); }
.report-stat .label { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
.report-issues { padding: 16px 24px; }
.report-issue { display: flex; align-items: center; gap: 10px; padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
.report-issue:last-child { border-bottom: none; }

.empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); gap: 8px; }
.empty-state .icon { font-size: 40px; opacity: 0.3; }
.empty-state .message { font-size: 14px; }
.empty-state .hint { font-size: 12px; }

.summary-bar { padding: 8px 20px; border-top: 1px solid var(--border); background: var(--card); font-size: 12px; color: var(--text-muted); }

/* File panel */
.file-panel { border-bottom: 1px solid var(--border); background: var(--card); display: flex; flex-direction: column; min-height: 0; flex-shrink: 0; }
.file-panel.collapsed { height: auto !important; }
.file-panel-header { padding: 8px 14px; font-size: 12px; font-weight: 600; color: var(--text-muted); display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; }
.file-panel-header:hover { color: var(--text); }
.file-panel-header .toggle { transition: transform 0.2s; }
.file-panel-header .toggle.collapsed { transform: rotate(-90deg); }
.file-panel-tools { display: flex; gap: 8px; align-items: center; padding: 6px 10px 8px; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); background: rgba(255,255,255,0.02); }
.file-panel-tools.collapsed { display: none; }
.file-filter-input-wrap { flex: 1; min-width: 0; position: relative; }
.file-filter-input-wrap .search-icon { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: var(--text-muted); font-size: 11px; pointer-events: none; }
.file-filter-input {
  width: 100%;
  height: 30px;
  border: 1px solid var(--border);
  border-radius: 8px;
  background: #0b121a;
  color: var(--text);
  font-size: 12px;
  padding: 0 10px 0 28px;
  font-family: inherit;
}
.file-filter-input:focus { outline: none; border-color: var(--accent); }
.file-filter-btn {
  height: 30px;
  min-width: 36px;
  border: 1px solid var(--border);
  border-radius: 8px;
  background: #0b121a;
  color: var(--text-muted);
  font-size: 12px;
  padding: 0 10px;
  cursor: pointer;
  position: relative;
}
.file-filter-btn:hover { border-color: var(--accent); color: var(--accent); }
.file-filter-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(88,166,255,0.1); }
.file-filter-btn .dot {
  position: absolute;
  right: 6px;
  top: 6px;
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: var(--accent);
}
.file-panel-list { flex: 1; min-height: 0; overflow-y: auto; overflow-x: hidden; padding: 6px 0; contain: layout paint; }
.file-panel-list.collapsed { display: none; }
.left-v-splitter {
  height: 8px;
  flex-shrink: 0;
  cursor: row-resize;
  background: transparent;
  position: relative;
}
.left-v-splitter::before {
  content: '';
  position: absolute;
  left: 8px;
  right: 8px;
  top: 3px;
  height: 2px;
  border-radius: 999px;
  background: rgba(255,255,255,0.12);
}
.left-v-splitter:hover::before,
.left-v-splitter.dragging::before { background: rgba(88,166,255,0.7); }
.left-issue-pane { flex: 1; min-height: 0; display: flex; flex-direction: column; overflow: hidden; }
.file-filter-popover {
  position: fixed;
  z-index: 2250;
  width: 260px;
  max-height: min(70vh, 460px);
  overflow: auto;
  border: 1px solid var(--border);
  border-radius: 10px;
  background: #0b121a;
  box-shadow: 0 14px 30px rgba(0,0,0,0.45);
  display: none;
  padding: 6px 0;
}
.file-filter-popover.show { display: block; }
.file-filter-section-title {
  font-size: 11px;
  color: var(--text-muted);
  padding: 6px 12px 4px;
  font-weight: 600;
}
.file-filter-popover .sep {
  height: 1px;
  background: rgba(255,255,255,0.08);
  margin: 6px 8px;
}
.file-filter-item {
  width: calc(100% - 12px);
  margin: 1px 6px;
  border: none;
  border-radius: 8px;
  background: transparent;
  color: var(--text);
  font-size: 12px;
  padding: 6px 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}
.file-filter-item:hover { background: rgba(88,166,255,0.12); }
.file-filter-item .check {
  width: 14px;
  text-align: center;
  color: var(--accent);
  flex-shrink: 0;
}
.file-filter-item .label {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.file-filter-item .count {
  color: var(--text-muted);
  background: rgba(255,255,255,0.08);
  border-radius: 999px;
  min-width: 20px;
  text-align: center;
  padding: 1px 6px;
  font-size: 11px;
}
.file-tree-canvas { width: 100%; }
.file-tree-row {
  padding: 2px 8px;
  min-height: 22px;
  width: calc(100% - 8px);
  min-width: 0;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  user-select: none;
  border-radius: 6px;
  margin: 1px 6px;
  transition: background 0.15s ease;
  overflow: hidden;
}
.file-tree-row:hover { background: rgba(88,166,255,0.08); }
.file-tree-row.active { background: rgba(88,166,255,0.18); box-shadow: inset 0 0 0 1px rgba(88,166,255,0.28); }
.file-tree-twist { width: 10px; text-align: center; color: var(--text-muted); flex-shrink: 0; font-size: 10px; }
.file-tree-icon { width: 13px; text-align: center; flex-shrink: 0; font-size: 12px; }
.file-tree-icon.folder { color: #5AA8FF; }
.file-tree-status {
  width: 16px;
  height: 16px;
  border-radius: 999px;
  font-size: 10px;
  font-weight: 700;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  border: 1px solid transparent;
}
.file-tree-status.added { color: #3FB950; background: rgba(63,185,80,0.14); border-color: rgba(63,185,80,0.4); }
.file-tree-status.modified { color: #58A6FF; background: rgba(88,166,255,0.14); border-color: rgba(88,166,255,0.4); }
.file-tree-status.deleted { color: #F85149; background: rgba(248,81,73,0.14); border-color: rgba(248,81,73,0.4); }
.file-tree-status.renamed { color: #D2A8FF; background: rgba(210,168,255,0.14); border-color: rgba(210,168,255,0.4); }
.file-tree-label {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-size: 12px;
  color: var(--text);
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
}
.file-tree-children { display: block; margin-left: 14px; border-left: 1px solid rgba(255,255,255,0.08); padding-left: 6px; }
.file-tree-children > .file-tree-row { position: relative; }
.file-tree-children > .file-tree-row::before {
  content: '';
  position: absolute;
  left: -6px;
  top: 50%;
  width: 6px;
  border-top: 1px solid rgba(255,255,255,0.08);
}
.file-tree-empty { padding: 12px 14px; color: var(--text-muted); font-size: 12px; }
.file-context-menu {
  position: fixed;
  z-index: 2200;
  min-width: 160px;
  background: #0E141C;
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4);
  padding: 4px;
  display: none;
}
.file-context-menu.show { display: block; }
.file-context-item {
  width: 100%;
  text-align: left;
  border: none;
  background: transparent;
  color: var(--text);
  font-size: 12px;
  border-radius: 6px;
  padding: 7px 10px;
  cursor: pointer;
}
.file-context-item:hover { background: rgba(88,166,255,0.15); }
.file-context-item.active { color: var(--accent); font-weight: 600; }
.file-context-sep { height: 1px; margin: 4px 2px; background: rgba(255,255,255,0.08); }
.file-context-title { font-size: 10px; color: var(--text-muted); padding: 2px 8px 4px; letter-spacing: .2px; }
.file-hover-tooltip {
  position: fixed;
  z-index: 2300;
  max-width: min(70vw, 720px);
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.12);
  background: #0b121a;
  color: var(--text);
  font-size: 11px;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  line-height: 1.35;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  pointer-events: none;
  box-shadow: 0 8px 24px rgba(0,0,0,0.35);
  display: none;
}
.file-hover-tooltip.show { display: block; }

/* Agent panel */
.agent-panel { padding: 8px 20px; border-bottom: 1px solid var(--border); background: var(--card); }
.agent-panel-title { font-size: 12px; font-weight: 600; color: var(--text-muted); margin-bottom: 8px; display:flex; align-items:center; gap:8px; }
.agent-list { display: flex; gap: 8px; flex-wrap: wrap; }
.agent-card { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; font-size: 12px; cursor:pointer; }
.agent-card .model-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.agent-card .agent-name { font-weight: 600; }
.agent-card .agent-role { color: var(--text-muted); font-size: 11px; }
.agent-card .agent-time { color: var(--text-muted); font-size: 11px; font-family: 'SF Mono', Monaco, monospace; }
.agent-status-reviewing { border-color: var(--accent); }
.agent-status-reviewing .model-dot { animation: agent-pulse 1.5s infinite; }
@keyframes agent-pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
.agent-status-submitted { border-color: #22C55E40; }
.agent-status-submitted .model-dot { background: #22C55E !important; }
.agent-status-failed { border-color: #EF444440; }
.agent-status-failed .model-dot { background: #EF4444 !important; }
.agent-task-badge { font-size: 10px; padding: 1px 5px; border-radius: 8px; font-weight: 600; }
.task-review { background: rgba(88,166,255,0.15); color: var(--accent); }
.task-deliberation { background: rgba(139,92,246,0.15); color: var(--model-opus); }
.agent-actions { margin-left:auto; display:flex; gap:6px; }
.btn-agent-add { font-size:11px; padding:3px 8px; }
.btn-agent-remove { font-size:10px; padding:2px 6px; color:var(--severity-critical); border-color:#EF444440; }
.btn-agent-remove:hover { background: rgba(239,68,68,0.15); }
.agent-empty-guide { display: flex; align-items: center; justify-content: center; gap: 12px; padding: 14px; border: 1px dashed var(--border); border-radius: 8px; color: var(--text-muted); font-size: 13px; }
.agent-empty-guide .btn { flex-shrink: 0; }

.mention-row { margin-top: 8px; display:flex; flex-wrap:wrap; gap:6px; }
.mention-chip { border:1px solid var(--border); background:var(--bg); color:var(--text-muted); border-radius:999px; padding:2px 8px; font-size:11px; cursor:pointer; }
.mention-chip:hover { border-color:var(--accent); color:var(--accent); }
.section-card { border-bottom: 1px solid var(--border); }
.section-header { padding: 10px 20px; display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; color: var(--text-muted); font-size: 12px; font-weight: 600; }
.section-header:hover { color: var(--text); background: rgba(255,255,255,0.02); }
.section-toggle { transition: transform 0.2s; }
.section-toggle.collapsed { transform: rotate(-90deg); }
.section-body.collapsed { display: none; }
.diff-focus-note { padding: 8px 12px; margin: 8px 12px; border: 1px dashed var(--border); border-radius: 6px; font-size: 11px; color: var(--text-muted); }
.issue-filters { padding: 8px 10px; border-bottom: 1px solid var(--border); background: var(--card); display:flex; flex-wrap:wrap; gap:6px; }
.issue-filters select, .issue-filters input { background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 4px 6px; font-size: 11px; }
.issue-group-header { padding: 8px 12px; font-size: 11px; color: var(--text-muted); border-bottom: 1px solid var(--border); display:flex; align-items:center; gap:6px; cursor:pointer; background: rgba(255,255,255,0.02); min-width: 0; }
.issue-group-header:hover { color: var(--text); }
.issue-group-toggle { transition: transform .2s; flex-shrink: 0; }
.issue-group-toggle.collapsed { transform: rotate(-90deg); }
.issue-group-label { min-width: 0; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.timeline-item { padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--card); margin-bottom: 8px; }
.timeline-item.comment-flash,
.opinion.comment-flash { animation: comment-flash 1.2s ease; }
@keyframes comment-flash {
  0% { border-color: rgba(88,166,255,0.95); box-shadow: 0 0 0 2px rgba(88,166,255,0.45) inset; background: rgba(88,166,255,0.14); }
  100% { border-color: var(--border); box-shadow: none; background: var(--card); }
}
.timeline-head { display:flex; gap:8px; align-items:center; font-size:12px; margin-bottom:6px; }
.timeline-time { margin-left:auto; color: var(--text-muted); font-size:11px; font-family: 'SF Mono', Monaco, monospace; }
.agent-runtime-card { margin: 0 20px 12px; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); }
.agent-runtime-grid { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px 12px; font-size: 12px; color: var(--text-muted); margin-bottom: 10px; }
.agent-runtime-grid .k { color: var(--text-muted); }
.agent-runtime-grid .v { color: var(--text); }
.agent-runtime-log-title { font-size: 11px; color: var(--text-muted); margin: 8px 0 4px; }
.agent-runtime-log { max-height: 140px; overflow: auto; border: 1px solid var(--border); border-radius: 6px; background: #0b0f14; padding: 8px 10px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: #d1d7de; white-space: pre-wrap; word-break: break-word; }

/* Resize handle */
.resize-handle { width: 4px; cursor: col-resize; background: var(--border); transition: background 0.15s; flex-shrink: 0; }
.resize-handle:hover, .resize-handle.active { background: var(--accent); }

/* Session tabs */
.session-tabs { display: flex; align-items: center; border-bottom: 1px solid var(--border); background: var(--card); padding: 0 12px; gap: 0; }
.session-tab-list { display: flex; overflow-x: auto; gap: 0; flex: 1; scrollbar-width: none; -ms-overflow-style: none; }
.session-tab-list::-webkit-scrollbar { display: none; }
.session-tab { display: flex; align-items: center; gap: 6px; padding: 6px 12px; font-size: 12px; color: var(--text-muted); cursor: pointer; border-bottom: 2px solid transparent; white-space: nowrap; transition: all 0.15s; position: relative; flex-shrink: 0; }
.session-tab:hover { color: var(--text); background: rgba(88,166,255,0.04); }
.session-tab.active { color: var(--text); border-bottom-color: var(--accent); }
.session-tab .tab-id { font-family: 'SF Mono', Monaco, monospace; font-weight: 600; }
.session-tab .tab-base { color: var(--accent); font-size: 11px; }
.session-tab .tab-status { font-size: 10px; padding: 1px 5px; border-radius: 8px; font-weight: 600; }
.session-tab .tab-close { opacity: 0; margin-left: 2px; background: none; border: none; color: var(--text-muted); font-size: 11px; cursor: pointer; padding: 0 3px; border-radius: 3px; transition: all 0.15s; line-height: 1; }
.session-tab:hover .tab-close { opacity: 0.6; }
.session-tab .tab-close:hover { opacity: 1; color: var(--severity-critical); background: rgba(239,68,68,0.1); }
.session-tab-add { background: none; border: 1px solid var(--border); color: var(--text-muted); font-size: 14px; width: 26px; height: 26px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; flex-shrink: 0; margin-left: 6px; }
.session-tab-add:hover { color: var(--accent); border-color: var(--accent); background: rgba(88,166,255,0.06); }
.session-tabs-empty { padding: 6px 12px; font-size: 12px; color: var(--text-muted); }

::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

.preset-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
.preset-card { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: 16px 12px; border: 1px solid var(--border); border-radius: 8px; cursor: pointer; background: var(--bg); transition: border-color 0.15s, background 0.15s; }
.preset-card:hover { border-color: var(--accent); background: rgba(88,166,255,0.06); }
.preset-card .preset-icon { font-size: 24px; line-height: 1; }
.preset-card .preset-label { font-size: 13px; font-weight: 600; color: var(--text); }
.preset-card-custom { border-style: dashed; }
.preset-card-custom:hover { border-color: var(--text-muted); background: rgba(255,255,255,0.03); }
.provider-row { transition: all 0.15s; }
.help-dot { width: 15px; height: 15px; border-radius: 999px; border: 1px solid var(--border); color: var(--text-muted); display: inline-flex; align-items: center; justify-content: center; font-size: 10px; line-height: 1; cursor: help; user-select: none; }
.field-hint { font-size: 11px; color: var(--text-muted); margin-top: 4px; line-height: 1.4; }
.conn-test-result { font-size: 11px; margin-top: 6px; min-height: 18px; color: var(--text-muted); }
.conn-test-result.ok { color: var(--severity-dismissed); }
.conn-test-result.fail { color: var(--severity-critical); }
.conn-test-detail { margin-top: 6px; }
.conn-test-detail summary { cursor: pointer; color: var(--text-muted); }
.conn-test-json { margin-top: 6px; background: #0b0f14; border: 1px solid var(--border); border-radius: 6px; padding: 8px 10px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: #d1d7de; white-space: pre-wrap; word-break: break-word; max-height: 200px; overflow: auto; }
.am-dirty-indicator { font-size: 11px; color: var(--severity-medium); background: rgba(234,179,8,0.15); border: 1px solid rgba(234,179,8,0.35); border-radius: 999px; padding: 2px 8px; }
.toast-stack {
  position: fixed;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  width: min(380px, calc(100vw - 20px));
  display: flex;
  flex-direction: column;
  gap: 6px;
  z-index: 2305;
  pointer-events: none;
}
.toast {
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.28);
  padding: 9px 12px;
  font-size: 13px;
  background: rgba(12,18,26,0.94);
  backdrop-filter: blur(6px);
  color: var(--text);
  box-shadow: 0 10px 24px rgba(0,0,0,0.35);
  opacity: 0;
  transform: translateY(-8px) scale(0.985);
  transition: opacity 0.18s ease, transform 0.18s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}
.toast.show { opacity: 1; transform: translateY(0) scale(1); }
.toast .toast-icon { font-size: 13px; line-height: 1; width: 14px; text-align: center; flex-shrink: 0; }
.toast .toast-msg { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 600; letter-spacing: 0.1px; }
.toast.success { border-color: rgba(34,197,94,0.42); }
.toast.success .toast-icon,
.toast.success .toast-msg { color: #22c55e; }
.toast.error { border-color: rgba(239,68,68,0.45); }
.toast.error .toast-icon,
.toast.error .toast-msg { color: #f87171; }
.am-action-footer {
  position: sticky;
  bottom: 0;
  z-index: 4;
  display: flex;
  justify-content: flex-end;
  margin-top: 8px;
  padding-top: 10px;
  background: var(--card);
  border-top: 1px solid var(--border);
  box-shadow: 0 -10px 18px rgba(13,17,23,0.65);
}
</style>
</head>
<body>

<div class="header">
  <h1>AI Review</h1>
  <span class="branch" id="branch-info">--</span>
  <div class="stats">
    <span id="stat-files">파일 0개</span>
    <span id="stat-reviews">리뷰 0개</span>
    <span id="stat-issues">이슈 0개</span>
    <button class="btn btn-primary" id="btn-process" style="display:none" onclick="processReviews()">리뷰 처리</button>
    <button class="btn btn-finish" id="btn-finish" style="display:none" onclick="finishReview()">리뷰 완료</button>
  </div>
</div>

<div class="session-tabs" id="session-tabs">
  <div class="session-tab-list" id="session-tab-list"></div>
  <button class="session-tab-add" onclick="openNewSessionModal()" title="새 세션">+</button>
</div>

<div class="step-indicator" id="step-indicator"></div>

<div class="main">
  <div id="left-panel" style="width:380px;min-width:240px;max-width:760px;border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden">
    <div class="file-panel" id="file-panel" style="display:none">
      <div class="file-panel-header" onclick="toggleFilePanel()">
        <span class="toggle" id="file-toggle">▾</span>
        <span>변경 파일</span>
        <span id="file-count" style="margin-left:auto;color:var(--accent)"></span>
      </div>
      <div class="file-panel-tools" id="file-tools">
        <div class="file-filter-input-wrap">
          <span class="search-icon">⌕</span>
          <input id="file-filter-input" class="file-filter-input" type="text" placeholder="Filter files..." oninput="onFileFilterQueryInput(this.value)">
        </div>
        <button type="button" id="file-filter-mode-btn" class="file-filter-btn" onclick="toggleFileFilterPopover(event)" title="파일 필터">☰</button>
      </div>
      <div class="file-filter-popover" id="file-filter-popover"></div>
      <div class="file-panel-list" id="file-list"></div>
    </div>
    <div class="left-v-splitter" id="left-v-splitter" onmousedown="startLeftPaneSplitDrag(event)" style="display:none"></div>
    <div class="left-issue-pane" id="left-issue-pane">
      <div class="issue-filters" id="issue-filters">
        <select id="filter-severity" onchange="renderIssueList()">
          <option value="">전체 심각도</option>
          <option value="critical">심각</option>
          <option value="high">높음</option>
          <option value="medium">보통</option>
          <option value="low">낮음</option>
          <option value="dismissed">기각</option>
        </select>
        <select id="filter-agent" onchange="renderIssueList()">
          <option value="">전체 에이전트</option>
        </select>
        <select id="filter-consensus" onchange="renderIssueList()">
          <option value="">합의 전체</option>
          <option value="yes">합의됨</option>
          <option value="no">합의대기</option>
        </select>
        <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--text-muted)">
          <input type="checkbox" id="filter-mine" onchange="renderIssueList()">
          내가 코멘트한 이슈만
        </label>
        <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--text-muted)">
          <input type="checkbox" id="filter-core-only" onchange="renderIssueList()" checked>
          핵심 이슈만
        </label>
      </div>
      <div class="issue-list" id="issue-list">
        <div class="empty-state"><div class="icon">&#128269;</div><div class="message">이슈가 없습니다</div><div class="hint">리뷰 세션을 시작하세요</div></div>
      </div>
    </div>
  </div>
  <div class="resize-handle" id="resize-handle"></div>
  <div class="right-panel" id="right-panel">
    <div class="detail-view-bar">
      <div class="detail-view-group">
        <button type="button" id="detail-view-issue" class="detail-view-btn active" onclick="setDetailViewMode('issue')">이슈 상세</button>
      </div>
    </div>
    <div class="right-main-layout">
      <div class="right-content">
        <div class="issue-detail" id="issue-detail">
          <div class="empty-state"><div class="icon">&#128221;</div><div class="message">이슈를 선택하세요</div><div class="hint">이슈를 클릭하면 코드와 토론을 볼 수 있습니다</div></div>
        </div>
      </div>
      <div class="right-side-splitter" id="right-side-splitter"></div>
      <aside class="reviewers-sidebar" id="reviewers-sidebar">
        <div class="reviewers-header">
          <div class="reviewers-title-wrap">
            <span class="reviewers-title">Reviewers</span>
            <span class="reviewers-count" id="reviewers-count">0명</span>
          </div>
          <div class="agent-actions" style="margin-left:auto">
            <button class="btn btn-agent-add" onclick="openAddAgentModal()">프리셋 관리</button>
          </div>
        </div>
        <div class="reviewers-list" id="reviewers-list">
          <div class="reviewers-empty">리뷰어가 없습니다.<br>프리셋을 추가해 시작하세요.</div>
        </div>
      </aside>
    </div>
  </div>
</div>

<div class="summary-bar" id="summary-bar">준비 완료</div>

<script>
const MODEL_COLORS = { opus:'#8B5CF6', gpt:'#22C55E', gemini:'#3B82F6', deepseek:'#F97316', human:'#58A6FF', 'human-assist':'#14B8A6' };
const SEVERITY_COLORS = { critical:'#EF4444', high:'#F97316', medium:'#EAB308', low:'#6B7280', dismissed:'#22C55E' };
const SEVERITY_ICONS = { critical:'\uD83D\uDD34', high:'\uD83D\uDFE0', medium:'\uD83D\uDFE1', low:'\u26AA', dismissed:'\u2705' };
const SEVERITY_LABELS = { critical:'심각', high:'높음', medium:'보통', low:'낮음', dismissed:'기각' };
const ACTION_LABELS = { raise:'제기', fix_required:'수정 필요', no_fix:'수정 불필요', false_positive:'오탐', withdraw:'철회', comment:'의견', agree:'수정 필요', disagree:'수정 불필요', clarify:'의견' };
const STEPS = [
  { key:'collecting', label:'수집' },
  { key:'agents', label:'에이전트' },
  { key:'reviewing', label:'리뷰' },
  { key:'dedup', label:'중복제거' },
  { key:'deliberating', label:'토론' },
  { key:'complete', label:'완료' },
];
const STATUS_TAB_STYLES = { idle:{bg:'#6B728020',color:'#8B949E'}, collecting:{bg:'rgba(88,166,255,0.15)',color:'var(--accent)'}, reviewing:{bg:'rgba(88,166,255,0.15)',color:'var(--accent)'}, dedup:{bg:'rgba(139,92,246,0.15)',color:'var(--model-opus)'}, deliberating:{bg:'rgba(234,179,8,0.15)',color:'var(--severity-medium)'}, complete:{bg:'rgba(34,197,94,0.15)',color:'var(--severity-dismissed)'} };
const STATUS_TAB_LABELS = { idle:'대기', collecting:'수집', reviewing:'리뷰', dedup:'중복제거', deliberating:'토론', complete:'완료' };
const AGENT_PRESETS = [
  { id:'claude-code', label:'Claude Code', client_type:'claude-code', color:'#8B5CF6', icon:'🟣' },
  { id:'codex', label:'Codex', client_type:'codex', color:'#22C55E', icon:'🟢' },
  { id:'gemini', label:'Gemini', client_type:'gemini', color:'#3B82F6', icon:'🔵' },
  { id:'opencode', label:'OpenCode', client_type:'opencode', color:'#F97316', icon:'🟠', needsProvider:true },
];

let state = {
  sessionId:null,
  sessions:[],
  status:'idle',
  currentTurn:0,
  detailViewMode:'issue',
  issues:[],
  humanAssistAccessKey:null,
  issueNumberById:{},
  nextIssueNumber:1,
  selectedIssue:null,
  selectedAgent:null,
  selectedFileDiff:null,
  diffCache:{},
  files:[],
  fileFilterQuery:'',
  fileFilterTypes:{},
  fileFilterStatus:{ added:true, modified:true, deleted:true, renamed:true },
  filePanelHeight:0,
  fileOpenerId:'auto',
  fileTreeExpanded:{},
  agents:[],
  expandedDiffByIssue:{},
  collapsedIssueGroups:{},
  issueDetailModeByIssue:{},
  expandedReasoning:{},
  reviewerExpanded:{},
};
const UI_STATE_STORAGE_KEY = 'ai-review-ui-state-v1';
let _uiHydrating = false;
let _uiSelectedIssueBySession = {};
let _uiSavedFilters = null;
let _highlighterLoadPromise = null;
let _highlighterUnavailable = false;
let _starryNightRuntime = null;
let _starryScopeSet = null;
let _fileOpeners = [{ id:'default', label:'기본 앱', available:true }];
let _fileHoverTimer = null;
let _fileHoverPayload = null;
let _fileFilterPopoverBound = false;
let _fileTreeAutoExpandedPath = '';
let _humanAssistKeyBySession = {};
let _pendingOpinionJump = null;

// --- URL Router ---
const router = {
  _ID_RE: /^[0-9a-f]{12}$/,
  parse(url) {
    const path = (url ? new URL(url, location.origin).pathname : location.pathname).replace(/\/+$/, '') || '/';
    const hash = url ? new URL(url, location.origin).hash : location.hash;
    const parts = path.split('/').filter(Boolean);
    const result = { sessionId: null, issueId: null, viewMode: 'issue', opinionId: null };
    if (parts.length >= 1 && this._ID_RE.test(parts[0])) {
      result.sessionId = parts[0];
      if (parts.length >= 3 && parts[1] === 'issues' && this._ID_RE.test(parts[2])) {
        result.issueId = parts[2];
      }
    }
    if (hash && hash.startsWith('#op-')) {
      result.opinionId = hash.slice(4);
    }
    return result;
  },
  buildUrl(opts) {
    const sid = opts.sessionId || state.sessionId;
    if (!sid) return '/';
    let path = `/${sid}`;
    if (opts.issueId) {
      path += `/issues/${opts.issueId}`;
    }
    if (opts.opinionId) path += `#op-${opts.opinionId}`;
    return path;
  },
  push(opts) {
    const url = this.buildUrl(opts);
    if (url !== location.pathname + location.hash) {
      history.pushState(null, '', url);
    }
  },
  replace(opts) {
    const url = this.buildUrl(opts);
    if (url !== location.pathname + location.hash) {
      history.replaceState(null, '', url);
    }
  },
  sync() {
    const opts = { sessionId: state.sessionId, viewMode: state.detailViewMode };
    if (state.detailViewMode === 'issue' && state.selectedIssue) {
      opts.issueId = state.selectedIssue;
    }
    this.replace(opts);
  }
};

function _scrollToOpinion(opinionId) {
  const el = document.getElementById('op-' + opinionId);
  if (!el) return;
  el.scrollIntoView({ behavior: 'smooth', block: 'center' });
  el.classList.add('opinion-flash');
  setTimeout(() => el.classList.remove('opinion-flash'), 1200);
}

window.addEventListener('popstate', async () => {
  const parsed = router.parse();
  if (!parsed.sessionId) {
    // URL이 / 이면 현재 세션 유지
    return;
  }
  const sessionExists = state.sessions.some(s => s.session_id === parsed.sessionId);
  if (!sessionExists) {
    router.replace({ sessionId: state.sessionId, viewMode: state.detailViewMode, issueId: state.selectedIssue });
    return;
  }
  if (parsed.sessionId !== state.sessionId) {
    await switchSession(parsed.sessionId);
  }
  if (parsed.issueId) {
    const issueExists = state.issues.some(i => i.id === parsed.issueId);
    if (issueExists) {
      selectIssue(parsed.issueId);
    }
  } else {
    setDetailViewMode('issue');
  }
  if (parsed.opinionId) {
    setTimeout(() => _scrollToOpinion(parsed.opinionId), 100);
  }
});

function _uiReadFiltersFromDom() {
  return {
    severity: document.getElementById('filter-severity')?.value || '',
    agent: document.getElementById('filter-agent')?.value || '',
    consensus: document.getElementById('filter-consensus')?.value || '',
    mine_only: !!document.getElementById('filter-mine')?.checked,
    core_only: !!document.getElementById('filter-core-only')?.checked,
  };
}

function _uiApplyFiltersToDom(filters) {
  const f = filters || {};
  const sevEl = document.getElementById('filter-severity');
  const agEl = document.getElementById('filter-agent');
  const conEl = document.getElementById('filter-consensus');
  const mineEl = document.getElementById('filter-mine');
  const coreEl = document.getElementById('filter-core-only');
  if (sevEl) sevEl.value = f.severity || '';
  if (agEl) agEl.value = f.agent || '';
  if (conEl) conEl.value = f.consensus || '';
  if (mineEl) mineEl.checked = !!f.mine_only;
  if (coreEl) coreEl.checked = f.core_only === false ? false : true;
}

function _uiLoadStateFromStorage() {
  try {
    const raw = localStorage.getItem(UI_STATE_STORAGE_KEY);
    if (!raw) return {};
    const data = JSON.parse(raw);
    return (data && typeof data === 'object') ? data : {};
  } catch (e) {
    return {};
  }
}

function _uiSaveStateToStorage() {
  if (_uiHydrating) return;
  if (state.sessionId) {
    if (state.selectedIssue) _uiSelectedIssueBySession[state.sessionId] = state.selectedIssue;
    else delete _uiSelectedIssueBySession[state.sessionId];
  }

  const payload = {
    session_id: state.sessionId || '',
    selected_issue_by_session: _uiSelectedIssueBySession,
    filters: _uiReadFiltersFromDom(),
    issue_detail_mode_by_issue: state.issueDetailModeByIssue || {},
    file_panel_height: Number(state.filePanelHeight) || 0,
  };
  _uiSavedFilters = payload.filters;
  try {
    localStorage.setItem(UI_STATE_STORAGE_KEY, JSON.stringify(payload));
  } catch (e) {}
}

function _uiRestoreStateFromStorage() {
  _uiHydrating = true;
  const saved = _uiLoadStateFromStorage();
  _uiSelectedIssueBySession = saved.selected_issue_by_session || {};
  state.issueDetailModeByIssue = saved.issue_detail_mode_by_issue || {};
  {
    const h = Number(saved.file_panel_height || 0);
    state.filePanelHeight = Number.isFinite(h) && h > 0 ? h : 0;
  }
  _uiSavedFilters = saved.filters || null;
  _uiApplyFiltersToDom(_uiSavedFilters || {});
  _uiHydrating = false;
  return saved;
}

let agentTimerInterval = null;
let agentChatRuntimeInterval = null;
let agentChatLastMessageCount = 0;
let statusPollInterval = null;
let sseSource = null;
let pollInFlight = false;
let pollScheduled = false;
let _issueRenderPaused = false;
let _issueRenderPending = false;
let _pollDeferredWhileSelecting = false;
let _issueDetailRenderSeq = 0;

function getModelColor(id) {
  // Check agent config color first
  const agent = state.agents.find(a => a.model_id === id);
  if (agent?.color) return agent.color;
  const k = Object.keys(MODEL_COLORS).find(k => id.toLowerCase().includes(k));
  return k ? MODEL_COLORS[k] : '#8B949E';
}
function esc(s) { if(!s) return ''; const d=document.createElement('div'); d.textContent=s; return d.innerHTML; }
function _escapeAttr(s) {
  return String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}
function _hastToHtml(node) {
  if (!node) return '';
  if (node.type === 'text') return esc(node.value || '');
  const children = Array.isArray(node.children) ? node.children.map(_hastToHtml).join('') : '';
  if (node.type === 'root') return children;
  if (node.type !== 'element') return children;
  const tagName = String(node.tagName || 'span').toLowerCase();
  // Starry Night returns spans for token wrappers; keep only safe inline tags here.
  if (tagName !== 'span') return children;
  const props = node.properties || {};
  let className = '';
  if (Array.isArray(props.className)) className = props.className.filter(Boolean).join(' ');
  else if (typeof props.className === 'string') className = props.className;
  const classAttr = className ? ` class="${_escapeAttr(className)}"` : '';
  return `<span${classAttr}>${children}</span>`;
}
function _starryLanguageCandidates(language) {
  const lang = (language || '').toLowerCase();
  const map = {
    javascript: ['source.js', 'javascript', 'js'],
    typescript: ['source.ts', 'typescript', 'ts'],
    python: ['source.python', 'python', 'py'],
    go: ['source.go', 'go'],
    java: ['source.java', 'java'],
    kotlin: ['source.kotlin', 'kotlin', 'kt', 'kts'],
    csharp: ['source.cs', 'csharp', 'cs'],
    c: ['source.c', 'c'],
    cpp: ['source.cpp', 'cpp', 'c++'],
    rust: ['source.rust', 'rust', 'rs'],
    ruby: ['source.ruby', 'ruby', 'rb'],
    php: ['source.php', 'php'],
    swift: ['source.swift', 'swift'],
    scala: ['source.scala', 'scala'],
    sql: ['source.sql', 'sql'],
    bash: ['source.shell', 'shell', 'bash', 'sh'],
    yaml: ['source.yaml', 'yaml', 'yml'],
    json: ['source.json', 'json'],
    ini: ['source.ini', 'ini', 'toml'],
    xml: ['text.xml', 'xml', 'html'],
    css: ['source.css', 'css'],
    scss: ['source.scss', 'scss', 'sass'],
    markdown: ['text.md', 'markdown', 'md'],
    dockerfile: ['source.dockerfile', 'dockerfile'],
    makefile: ['source.makefile', 'makefile'],
  };
  return map[lang] || [lang];
}
function _starryScopeForLanguage(language) {
  if (!_starryNightRuntime || !language) return '';
  const candidates = _starryLanguageCandidates(language);
  for (const c of candidates) {
    if (!c) continue;
    if (_starryScopeSet && _starryScopeSet.has(c)) return c;
    if (_starryNightRuntime.flagToScope) {
      const scope = _starryNightRuntime.flagToScope(c);
      if (scope) return scope;
    }
  }
  return '';
}
function _ensureDiffHighlighter() {
  if (_starryNightRuntime) return Promise.resolve(true);
  if (_highlighterUnavailable) return Promise.resolve(false);
  if (_highlighterLoadPromise) return _highlighterLoadPromise;
  _highlighterLoadPromise = (async () => {
    try {
      const mod = await import('/vendor/starry-night.bundle.mjs');
      const createStarryNight = mod?.createStarryNight;
      const grammars = mod?.all || mod?.common;
      if (typeof createStarryNight !== 'function' || !Array.isArray(grammars)) {
        throw new Error('starry-night module is invalid');
      }
      _starryNightRuntime = await createStarryNight(grammars, {
        getOnigurumaUrlFetch() {
          return new URL('/vendor/onig.wasm', window.location.origin);
        },
      });
      _starryScopeSet = new Set(_starryNightRuntime.scopes ? _starryNightRuntime.scopes() : []);
      return true;
    } catch (e) {
      _highlighterUnavailable = true;
      console.warn('[diff-highlight] starry-night init failed:', e);
      return false;
    } finally {
      _highlighterLoadPromise = null;
    }
  })();
  return _highlighterLoadPromise;
}
function _requestDiffHighlighterRefresh() {
  if (_starryNightRuntime || _highlighterUnavailable) return;
  _ensureDiffHighlighter().then((ok) => {
    if (!ok) return;
    if (state.selectedIssue) {
      renderIssueDetail();
      return;
    }
    if (state.selectedFileDiff) {
      renderFileDiff(state.selectedFileDiff);
    }
  });
}
function _guessDiffLanguage(filePath) {
  const path = (filePath || '').toLowerCase();
  const name = path.split('/').pop() || '';
  if (name === 'dockerfile') return 'dockerfile';
  if (name === 'makefile' || name.startsWith('makefile.')) return 'makefile';
  const ext = name.includes('.') ? name.split('.').pop() : '';
  const byExt = {
    js: 'javascript',
    mjs: 'javascript',
    cjs: 'javascript',
    jsx: 'javascript',
    ts: 'typescript',
    tsx: 'typescript',
    py: 'python',
    go: 'go',
    java: 'java',
    kt: 'kotlin',
    kts: 'kotlin',
    cs: 'csharp',
    c: 'c',
    h: 'cpp',
    hh: 'cpp',
    hpp: 'cpp',
    hxx: 'cpp',
    cc: 'cpp',
    cpp: 'cpp',
    cxx: 'cpp',
    rs: 'rust',
    rb: 'ruby',
    php: 'php',
    swift: 'swift',
    scala: 'scala',
    sql: 'sql',
    sh: 'bash',
    bash: 'bash',
    zsh: 'bash',
    yml: 'yaml',
    yaml: 'yaml',
    json: 'json',
    toml: 'ini',
    ini: 'ini',
    xml: 'xml',
    html: 'xml',
    htm: 'xml',
    css: 'css',
    scss: 'scss',
    sass: 'scss',
    md: 'markdown',
  };
  return byExt[ext] || '';
}
function _escapeRegex(s) { return String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
function _basicKeywordsForLanguage(language) {
  const lang = (language || '').toLowerCase();
  if (lang === 'python') return ['def','class','import','from','as','if','elif','else','for','while','try','except','finally','with','return','yield','lambda','pass','break','continue','and','or','not','in','is','None','True','False','async','await','raise'];
  if (lang === 'go') return ['package','import','func','type','struct','interface','map','chan','select','go','defer','return','if','else','switch','case','default','for','range','break','continue','fallthrough','const','var','nil'];
  if (lang === 'java') return ['package','import','class','interface','enum','extends','implements','public','private','protected','static','final','void','new','return','if','else','switch','case','default','for','while','do','try','catch','finally','throw','throws','this','super','null','true','false'];
  if (lang === 'kotlin') return ['package','import','class','interface','object','fun','val','var','typealias','public','private','protected','internal','open','final','override','abstract','sealed','data','companion','operator','infix','inline','suspend','tailrec','const','lateinit','init','by','where','when','if','else','for','while','do','try','catch','finally','return','break','continue','this','super','is','in','as','null','true','false'];
  if (lang === 'csharp') return ['namespace','using','class','struct','interface','enum','public','private','protected','internal','static','readonly','const','void','new','return','if','else','switch','case','default','for','foreach','while','do','try','catch','finally','throw','this','base','null','true','false','async','await','var'];
  if (lang === 'rust') return ['fn','let','mut','struct','enum','impl','trait','pub','use','mod','crate','self','super','match','if','else','loop','while','for','in','return','break','continue','async','await','move','ref','const','static','true','false','None','Some'];
  if (lang === 'bash' || lang === 'shell') return ['if','then','else','elif','fi','for','while','do','done','case','esac','function','in','export','local','readonly','unset','return','break','continue'];
  if (lang === 'json' || lang === 'yaml' || lang === 'xml' || lang === 'ini') return ['true','false','null','yes','no','on','off'];
  // javascript/typescript/c-family fallback
  return ['function','class','interface','type','enum','import','export','from','as','const','let','var','new','return','if','else','switch','case','default','for','while','do','try','catch','finally','throw','extends','implements','public','private','protected','static','async','await','yield','break','continue','this','super','null','true','false','typeof','instanceof'];
}
function _basicHighlightDiffCode(text, language) {
  let src = text || '';
  const lang = (language || '').toLowerCase();
  const stash = [];
  const save = (cls, val) => {
    const token = `@@BT_${stash.length}@@`;
    stash.push(`<span class="${cls}">${esc(val)}</span>`);
    return token;
  };

  // Strings first to keep markers inside strings from being tokenized as comments/keywords.
  src = src.replace(/`[^`]*`/g, (m) => save('diff-tok-string', m));
  src = src.replace(/"(?:\\.|[^"\\])*"/g, (m) => save('diff-tok-string', m));
  src = src.replace(/'(?:\\.|[^'\\])*'/g, (m) => save('diff-tok-string', m));

  const hashCommentLang = new Set(['python', 'bash', 'shell', 'yaml', 'ini', 'toml']);
  if (hashCommentLang.has(lang)) {
    src = src.replace(/#.*$/g, (m) => save('diff-tok-comment', m));
  } else {
    src = src.replace(/\/\/.*$/g, (m) => save('diff-tok-comment', m));
  }

  src = src.replace(/\b\d+(?:\.\d+)?\b/g, (m) => save('diff-tok-number', m));

  const keywords = _basicKeywordsForLanguage(lang);
  if (keywords.length) {
    const kwRe = new RegExp(`\\b(${keywords.map(_escapeRegex).join('|')})\\b`, 'g');
    src = src.replace(kwRe, (m) => save('diff-tok-keyword', m));
  }

  src = esc(src);
  src = src.replace(/@@BT_(\d+)@@/g, (_m, idx) => stash[Number(idx)] || '');
  return src;
}
function _highlightDiffCode(text, language, enableHighlight = true) {
  const raw = text || '';
  if (!enableHighlight || !language) return esc(raw);
  if (!_starryNightRuntime) {
    _requestDiffHighlighterRefresh();
    return _basicHighlightDiffCode(raw, language);
  }
  try {
    const scope = _starryScopeForLanguage(language);
    if (!scope) return _basicHighlightDiffCode(raw, language);
    const tree = _starryNightRuntime.highlight(raw, scope);
    const html = _hastToHtml(tree);
    return html || _basicHighlightDiffCode(raw, language);
  } catch (e) {
    return _basicHighlightDiffCode(raw, language);
  }
}
function _renderDiffLineContent(prefix, text, language, enableHighlight = true) {
  const highlighted = _highlightDiffCode(text, language, enableHighlight);
  return `<span class="diff-prefix">${esc(prefix)}</span><span class="diff-code">${highlighted}</span>`;
}
function _issueLineRange(issue) {
  const line = Number.isInteger(issue?.line) ? issue.line : null;
  let start = Number.isInteger(issue?.line_start) ? issue.line_start : line;
  let end = Number.isInteger(issue?.line_end) ? issue.line_end : start;
  if (start === null && end !== null) start = end;
  if (start !== null && end !== null && end < start) {
    const tmp = start;
    start = end;
    end = tmp;
  }
  return { start, end };
}
function _issueRangeLabel(issue) {
  const r = _issueLineRange(issue);
  if (r.start === null) return '';
  if (r.end !== null && r.end !== r.start) return `${r.start}-${r.end}`;
  return String(r.start);
}
function _isIssueTargetLine(issue, lineNo) {
  if (!Number.isInteger(lineNo)) return false;
  const r = _issueLineRange(issue);
  if (r.start === null) return false;
  const end = r.end ?? r.start;
  return lineNo >= r.start && lineNo <= end;
}
function _hasActiveSelectionInIssueDetail() {
  const detail = document.getElementById('issue-detail');
  const sel = window.getSelection ? window.getSelection() : null;
  if (!detail || !sel || sel.rangeCount === 0 || sel.isCollapsed) return false;
  const anchor = sel.anchorNode;
  const focus = sel.focusNode;
  return !!((anchor && detail.contains(anchor)) || (focus && detail.contains(focus)));
}
function _shouldDeferIssueRender() {
  return _issueRenderPaused || _hasActiveSelectionInIssueDetail();
}
function _flushDeferredIssueRender() {
  if (_pollDeferredWhileSelecting) {
    _pollDeferredWhileSelecting = false;
    schedulePoll(0);
  }
  if (!_issueRenderPending) return;
  if (_shouldDeferIssueRender()) return;
  _issueRenderPending = false;
  renderIssueList();
  if (state.selectedIssue) renderIssueDetail();
}
function findIssueByRef(ref) {
  const key = (ref || '').trim();
  if (!key) return null;
  const exact = state.issues.find(i => i.id === key);
  if (exact) return exact;
  const matches = state.issues.filter(i => i.id.startsWith(key));
  if (matches.length === 1) return matches[0];
  return null;
}
function findAgentByRef(ref) {
  const key = (ref || '').trim().toLowerCase();
  if (!key) return null;
  const exact = state.agents.find(a => (a.model_id || '').toLowerCase() === key);
  if (exact) return exact;
  const matches = state.agents.filter(a => (a.model_id || '').toLowerCase().startsWith(key));
  if (matches.length === 1) return matches[0];
  return null;
}
function shortText(s, max = 32) {
  const text = (s || '').trim();
  if (!text) return '';
  return text.length > max ? `${text.slice(0, max - 1)}…` : text;
}
function _normalizeReviewerAction(action) {
  let key = String(action || '').trim().toLowerCase();
  if (!key) return 'comment';
  if (key.includes('.')) key = key.split('.').pop() || key; // e.g. OpinionAction.FIX_REQUIRED
  key = key.replace(/\s+/g, '_');
  key = key.replace(/-+/g, '_');
  if (key === 'fixrequired') key = 'fix_required';
  if (key === 'nofix') key = 'no_fix';

  if (key.startsWith('fix_required') || key.startsWith('agree')) return 'fix_required';
  if (key.startsWith('no_fix') || key.startsWith('disagree')) return 'no_fix';
  if (key.startsWith('comment') || key.startsWith('clarify')) return 'comment';
  if (key.startsWith('raise')) return 'raise';

  if (key.includes('수정') && key.includes('불필요')) return 'no_fix';
  if (key.includes('수정') && key.includes('필요')) return 'fix_required';
  if (key.includes('의견')) return 'comment';
  if (key.includes('제기')) return 'raise';

  return 'comment';
}
function _reviewerActionClass(action) {
  const key = _normalizeReviewerAction(action);
  if (key === 'raise') return 'reviewer-opinion-raise';
  if (key === 'fix_required') return 'reviewer-opinion-fix-required';
  if (key === 'no_fix') return 'reviewer-opinion-no-fix';
  if (key === 'comment') return 'reviewer-opinion-comment';
  return 'reviewer-opinion-comment';
}
function _reviewerActionLabel(action) {
  const key = _normalizeReviewerAction(action);
  return ACTION_LABELS[key] || ACTION_LABELS.raise;
}
function _isRaiseAction(action) {
  return _normalizeReviewerAction(action) === 'raise';
}
function _getInitialRaiseOpinion(issue) {
  const raisedBy = String(issue?.raised_by || '').trim();
  if (!raisedBy) return null;
  const thread = Array.isArray(issue?.thread) ? issue.thread : [];
  const candidates = thread.filter((op) => {
    if (!op) return false;
    if (String(op.model_id || '').trim() !== raisedBy) return false;
    if (!_isRaiseAction(op.action || '')) return false;
    return Number(op.turn || 0) === 0;
  });
  if (!candidates.length) return null;
  return candidates
    .slice()
    .sort((a, b) => new Date(a?.timestamp || 0).getTime() - new Date(b?.timestamp || 0).getTime())[0];
}
function _getDiscussionOpinions(issue) {
  const thread = Array.isArray(issue?.thread) ? issue.thread : [];
  return thread.filter((op) => !_isRaiseAction(op?.action || ''));
}
function _getLatestReviewerOpinion(issue, modelId) {
  const opinions = (issue?.thread || []).filter(op => op?.model_id === modelId);
  if (!opinions.length) return null;
  return opinions.slice().sort((a, b) => {
    const turnDiff = Number(b?.turn || 0) - Number(a?.turn || 0);
    if (turnDiff) return turnDiff;
    return new Date(b?.timestamp || 0).getTime() - new Date(a?.timestamp || 0).getTime();
  })[0];
}
function _getReviewerIssueEntries(modelId) {
  const key = String(modelId || '');
  const entries = [];
  for (const issue of state.issues || []) {
    const raisedByReviewer = issue?.raised_by === key;
    const latestOpinion = _getLatestReviewerOpinion(issue, key);
    if (latestOpinion) {
      const normalized = _normalizeReviewerAction(latestOpinion.action || 'comment');
      const resolved = (normalized === 'comment' && raisedByReviewer) ? 'raise' : normalized;
      entries.push({ issue, action: resolved, turn: Number(latestOpinion.turn || 0), ts: latestOpinion.timestamp || '' });
      continue;
    }
    if (raisedByReviewer) {
      entries.push({ issue, action: 'raise', turn: 0, ts: '' });
    }
  }
  return entries.sort((a, b) => {
    const aNo = Number(state.issueNumberById[a.issue.id] || 0);
    const bNo = Number(state.issueNumberById[b.issue.id] || 0);
    return aNo - bNo;
  });
}
function toggleReviewerIssues(modelId) {
  const key = String(modelId || '').trim();
  if (!key) return;
  state.reviewerExpanded[key] = !state.reviewerExpanded[key];
  renderAgentPanel();
}
function openReviewerChat(modelId, event) {
  if (event?.preventDefault) event.preventDefault();
  if (event?.stopPropagation) event.stopPropagation();
  const key = String(modelId || '').trim();
  if (!key) return;
  openAgentChat(key);
}
function _flashIssueJump(issueId) {
  const key = String(issueId || '').trim();
  if (!key) return;
  const row = document.querySelector(`.issue-item[data-issue-id="${key}"]`);
  if (row) {
    row.scrollIntoView({ block: 'center' });
    row.classList.remove('issue-item-flash');
    void row.offsetWidth;
    row.classList.add('issue-item-flash');
    setTimeout(() => row.classList.remove('issue-item-flash'), 1050);
  }
  const header = document.querySelector('#issue-detail .detail-header-bar');
  if (header) {
    header.classList.remove('detail-flash');
    void header.offsetWidth;
    header.classList.add('detail-flash');
    setTimeout(() => header.classList.remove('detail-flash'), 1000);
  }
}
function _expandIssueGroupForIssue(issueId) {
  const key = String(issueId || '').trim();
  if (!key) return;
  const issue = state.issues.find(i => i.id === key);
  if (!issue) return;
  state.collapsedIssueGroups[issueGroupKey(issue)] = false;
}
function _findOpinionNode(modelId, timestamp, action) {
  const modelKey = String(modelId || '').trim();
  if (!modelKey) return null;
  const timeKey = String(timestamp || '').trim();
  const actionKey = _normalizeReviewerAction(action);
  const nodes = Array.from(document.querySelectorAll('#issue-detail .timeline-item, #issue-detail .opinion'));
  if (!nodes.length) return null;
  const byModel = nodes.filter((node) => String(node.dataset.opModel || '').trim() === modelKey);
  if (timeKey) {
    const exact = byModel.find((node) => String(node.dataset.opTime || '').trim() === timeKey);
    if (exact) return exact;
  }
  const byAction = byModel.find((node) => _normalizeReviewerAction(node.dataset.opAction || '') === actionKey);
  if (byAction) return byAction;
  return byModel[0] || null;
}
function _flashOpinionNode(node) {
  if (!node) return;
  node.classList.remove('comment-flash');
  void node.offsetWidth;
  node.classList.add('comment-flash');
  setTimeout(() => node.classList.remove('comment-flash'), 1250);
}
function _applyPendingOpinionJump(issueId) {
  const pending = _pendingOpinionJump;
  if (!pending) return;
  if (String(pending.issueId || '') !== String(issueId || '')) return;
  _pendingOpinionJump = null;
  setTimeout(() => {
    const node = _findOpinionNode(pending.modelId, pending.timestamp, pending.action);
    if (!node) return;
    node.scrollIntoView({ block: 'center' });
    _flashOpinionNode(node);
  }, 0);
}
function jumpToIssueFromReviewer(issueId, modelId, timestamp = '', action = 'raise') {
  const key = String(issueId || '').trim();
  if (!key) return;
  if (!state.issues.some(i => i.id === key)) return;
  _expandIssueGroupForIssue(key);
  state.issueDetailModeByIssue[key] = 'timeline';
  _pendingOpinionJump = {
    issueId: key,
    modelId: String(modelId || '').trim(),
    timestamp: String(timestamp || '').trim(),
    action: String(action || 'raise').toLowerCase(),
  };
  selectIssue(key);
}
function jumpToIssueFromMention(ref) {
  const key = (ref || '').trim();
  if (!key) return;
  const exact = state.issues.find(i => i.id === key);
  if (exact) {
    _expandIssueGroupForIssue(exact.id);
    selectIssue(exact.id);
    setTimeout(() => _flashIssueJump(exact.id), 0);
    return;
  }
  const matches = state.issues.filter(i => i.id.startsWith(key));
  if (matches.length === 1) {
    _expandIssueGroupForIssue(matches[0].id);
    selectIssue(matches[0].id);
    setTimeout(() => _flashIssueJump(matches[0].id), 0);
    return;
  }
  if (matches.length > 1) {
    showToast(`@${key}가 여러 이슈와 매칭됩니다. 더 길게 입력해주세요.`, 'error');
    return;
  }
  showToast(`@${key}에 해당하는 이슈를 찾지 못했습니다.`, 'error');
}
function jumpToAgentFromMention(ref) {
  const key = (ref || '').trim();
  if (!key) return;
  const agent = findAgentByRef(key);
  if (!agent || !agent.model_id) {
    showToast(`@${key}에 해당하는 에이전트를 찾지 못했습니다.`, 'error');
    return;
  }
  openAgentChat(agent.model_id);
}
function renderMd(s) {
  let t = esc(s || '');
  const stash = [];
  const save = (html) => {
    const token = `@@MD_${stash.length}@@`;
    stash.push(html);
    return token;
  };

  t = t.replace(/```[A-Za-z0-9_-]*\n([\s\S]*?)```/g, (_m, code) => save(`<pre><code>${code}</code></pre>`));
  t = t.replace(/```([\s\S]*?)```/g, (_m, code) => save(`<pre><code>${code}</code></pre>`));
  t = t.replace(/`([^`\n]+)`/g, (_m, code) => save(`<code>${code}</code>`));

  t = t.replace(/^(#{1,4})\s+(.+)$/gm, (_m, h, text) => {
    const sz = {1:'20px',2:'18px',3:'16px',4:'14px'}[h.length] || '14px';
    return save(`<div style="font-size:${sz};font-weight:700;margin:12px 0 6px;color:var(--text)">${text}</div>`);
  });

  t = t.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  t = t.replace(/~~([^~]+)~~/g, '<del>$1</del>');
  t = t.replace(/(^|[\s(])\*([^*\n]+)\*(?=$|[\s),.!?:;])/g, '$1<em>$2</em>');
  t = t.replace(/^(\s*)[-*] (.+)$/gm, '$1<span style="display:list-item;margin-left:20px">$2</span>');
  t = t.replace(/(^|[\s(])@([A-Za-z0-9_-]{4,64})(?=$|[\s),.!?:;])/g, (m, prefix, ref) => {
    const issue = findIssueByRef(ref);
    if (issue) {
      const encodedRef = encodeURIComponent(ref);
      const issueTitle = shortText(issue.title || issue.id, 36);
      return `${prefix}<button type="button" class="mention-link mention-issue" onclick="jumpToIssueFromMention(decodeURIComponent('${encodedRef}'))" title="${esc(issue.title || issue.id)}로 이동"><span class="mention-main">@${ref}</span><span class="mention-meta">${esc(issueTitle)}</span></button>`;
    }
    const agent = findAgentByRef(ref);
    if (agent && agent.model_id) {
      const encodedAgent = encodeURIComponent(agent.model_id);
      const role = shortText(agent.role || '에이전트', 20);
      return `${prefix}<button type="button" class="mention-link mention-agent" onclick="jumpToAgentFromMention(decodeURIComponent('${encodedAgent}'))" title="@${esc(agent.model_id)} 창 열기"><span class="mention-main">@${esc(agent.model_id)}</span><span class="mention-meta">${esc(role)}</span></button>`;
    }
    return m;
  });

  t = t.replace(/\n/g, '<br>');
  t = t.replace(/@@MD_(\d+)@@/g, (_m, idx) => stash[Number(idx)] || '');
  return t;
}
function sevLabel(s) { return SEVERITY_LABELS[s]||s; }
function actLabel(a) { const key = (a||'').replace(/-/g,'_'); const label = ACTION_LABELS[key]; return label ? `${key} (${label})` : a; }
function formatTs(ts) {
  if (!ts) return '';
  const d = new Date(ts);
  if (Number.isNaN(d.getTime())) return '';
  return d.toLocaleString('ko-KR', { hour12: false });
}
function renderIssueDetailEmpty() {
  return '<div class="empty-state"><div class="icon">&#128221;</div><div class="message">이슈를 선택하세요</div><div class="hint">이슈를 클릭하면 코드와 토론을 볼 수 있습니다</div></div>';
}
function renderAgentSessionDetail() {
  if (!state.agents.length) {
    return '<div class="empty-state"><div class="icon">&#129302;</div><div class="message">에이전트가 없습니다</div><div class="hint">프리셋을 선택해 세션을 시작하세요</div></div>';
  }

  const statusLabel = (status) => {
    if (status === 'reviewing') return '진행중';
    if (status === 'submitted') return '완료';
    if (status === 'failed') return '실패';
    return '대기';
  };

  return `<div class="agent-session-board">${
    state.agents.map((agent) => {
      const modelColor = getModelColor(agent.model_id);
      return `<div class="agent-session-card">
        <div class="agent-session-head">
          <span class="model-dot" style="background:${modelColor}"></span>
          <span class="agent-session-name" style="color:${modelColor}">${esc(agent.model_id)}</span>
          ${agent.role ? `<span class="agent-session-role">${esc(agent.role)}</span>` : ''}
          <span class="agent-session-status">${esc(statusLabel(agent.status))}</span>
          <button class="btn" style="margin-left:auto;padding:4px 8px;font-size:11px" onclick="openAgentChat('${esc(agent.model_id)}')">대화</button>
        </div>
        <div class="agent-session-empty">에이전트 활동을 추적 중입니다.</div>
      </div>`;
    }).join('')
  }</div>`;
}
function renderDetailViewBar() {
  const issueBtn = document.getElementById('detail-view-issue');
  if (!issueBtn) return;
  issueBtn.classList.toggle('active', state.detailViewMode === 'issue');
}
function setDetailViewMode(mode) {
  const target = 'issue';
  if (state.detailViewMode === target) return;
  state.detailViewMode = target;
  router.push({ issueId: state.selectedIssue });
  renderDetailViewBar();
  renderIssueDetail();
}
function renderReasoning(text, key, maxChars=260) {
  const raw = text || '';
  const expanded = !!state.expandedReasoning[key];
  if (raw.length <= maxChars) return `<div class="opinion-text">${renderMd(raw)}</div>`;
  const shown = expanded ? raw : `${raw.slice(0, maxChars)}...`;
  return `<div class="opinion-text">${renderMd(shown)}</div>
    <button class="opinion-more" onclick="toggleReasoning('${esc(key)}')">${expanded ? '접기' : '더보기'}</button>`;
}
function toggleReasoning(key) {
  state.expandedReasoning[key] = !state.expandedReasoning[key];
  renderIssueDetail();
}
function toggleSection(id, btnId) {
  const body = document.getElementById(id);
  const btn = document.getElementById(btnId);
  if (!body || !btn) return;
  body.classList.toggle('collapsed');
  btn.classList.toggle('collapsed');
}
function toggleIssueDiff(issueId) {
  state.expandedDiffByIssue[issueId] = !state.expandedDiffByIssue[issueId];
  renderIssueDetail();
}
function setIssueDetailMode(issueId, mode) {
  state.issueDetailModeByIssue[issueId] = mode;
  _uiSaveStateToStorage();
  renderIssueDetail();
}
function toggleIssueGroup(groupKey) {
  state.collapsedIssueGroups[groupKey] = !state.collapsedIssueGroups[groupKey];
  renderIssueList();
}
function normalizeTitle(title) {
  return (title || '')
    .toLowerCase()
    .replace(/[^a-z0-9가-힣\s]/g, ' ')
    .split(/\s+/)
    .filter(w => w.length > 1)
    .sort()
    .slice(0, 4)
    .join(' ');
}
function issueGroupKey(issue) {
  return `${issue.file}::${normalizeTitle(issue.title) || 'misc'}`;
}
function getFilteredIssues() {
  const severity = document.getElementById('filter-severity')?.value || '';
  const agent = document.getElementById('filter-agent')?.value || '';
  const consensus = document.getElementById('filter-consensus')?.value || '';
  const mineOnly = !!document.getElementById('filter-mine')?.checked;
  const coreOnly = !!document.getElementById('filter-core-only')?.checked;

  return state.issues.filter((issue) => {
    const sev = issue.final_severity || issue.severity;
    if (severity && sev !== severity) return false;
    if (agent) {
      const raised = issue.raised_by === agent;
      const inThread = (issue.thread || []).some(op => op.model_id === agent);
      if (!raised && !inThread) return false;
    }
    if (consensus === 'yes' && issue.consensus !== true) return false;
    if (consensus === 'no' && issue.consensus === true) return false;
    if (mineOnly) {
      const mine = (issue.thread || []).some(op => op.model_id === 'human');
      if (!mine) return false;
    }
    if (coreOnly) {
      const severe = sev === 'critical' || sev === 'high';
      if (!severe && issue.consensus === true) return false;
    }
    return true;
  });
}

function ensureIssueDisplayNumbers() {
  for (const issue of state.issues) {
    if (!state.issueNumberById[issue.id]) {
      state.issueNumberById[issue.id] = state.nextIssueNumber++;
    }
  }
}

function _clampFilePanelHeight(height) {
  const left = document.getElementById('left-panel');
  const splitter = document.getElementById('left-v-splitter');
  if (!left) return Math.max(120, Math.round(Number(height) || 0));
  const minFile = 120;
  const minIssue = 180;
  const splitterH = splitter?.offsetHeight || 8;
  const maxFile = Math.max(minFile, left.clientHeight - minIssue - splitterH);
  return Math.max(minFile, Math.min(maxFile, Math.round(Number(height) || minFile)));
}

function _defaultFilePanelHeight() {
  const left = document.getElementById('left-panel');
  if (!left) return 260;
  const target = Math.round(left.clientHeight * 0.34);
  return _clampFilePanelHeight(target);
}

function _setFilePanelHeight(height, persist = false) {
  const panel = document.getElementById('file-panel');
  if (!panel) return;
  const clamped = _clampFilePanelHeight(height);
  panel.style.height = `${clamped}px`;
  state.filePanelHeight = clamped;
  if (persist) _uiSaveStateToStorage();
}

function _syncLeftPaneLayout() {
  const panel = document.getElementById('file-panel');
  const splitter = document.getElementById('left-v-splitter');
  if (!panel || !splitter) return;
  const visible = panel.style.display !== 'none';
  const collapsed = panel.classList.contains('collapsed');
  if (!visible || collapsed) {
    splitter.style.display = 'none';
    panel.style.height = '';
    return;
  }
  splitter.style.display = '';
  const preferred = Number(state.filePanelHeight) > 0 ? Number(state.filePanelHeight) : _defaultFilePanelHeight();
  _setFilePanelHeight(preferred, false);
}

function startLeftPaneSplitDrag(event) {
  const panel = document.getElementById('file-panel');
  const splitter = document.getElementById('left-v-splitter');
  if (!panel || !splitter) return;
  if (panel.style.display === 'none' || panel.classList.contains('collapsed')) return;
  event.preventDefault();
  const startY = event.clientY;
  const startH = panel.getBoundingClientRect().height;
  splitter.classList.add('dragging');
  const onMove = (e) => {
    _setFilePanelHeight(startH + (e.clientY - startY), false);
  };
  const onUp = () => {
    splitter.classList.remove('dragging');
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    _uiSaveStateToStorage();
  };
  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function toggleFilePanel() {
  const list = document.getElementById('file-list');
  const tools = document.getElementById('file-tools');
  const toggle = document.getElementById('file-toggle');
  const panel = document.getElementById('file-panel');
  _hideFileFilterPopover();
  const collapsed = list.classList.toggle('collapsed');
  if (tools) tools.classList.toggle('collapsed', collapsed);
  toggle.classList.toggle('collapsed', collapsed);
  if (panel) panel.classList.toggle('collapsed', collapsed);
  _syncLeftPaneLayout();
}

function onFileFilterQueryInput(value) {
  state.fileFilterQuery = String(value || '');
  renderFilePanel();
}

function _fileTypeKey(path) {
  const p = String(path || '');
  const name = p.split('/').pop() || '';
  if (!name) return '__no_ext__';
  if (name.startsWith('.') && !name.slice(1).includes('.')) return '__dotfile__';
  const dot = name.lastIndexOf('.');
  if (dot <= 0 || dot === name.length - 1) return '__no_ext__';
  return name.slice(dot).toLowerCase();
}

function _fileTypeLabel(typeKey) {
  if (typeKey === '__dotfile__') return 'dotfile';
  if (typeKey === '__no_ext__') return 'No extension';
  return typeKey;
}

function _collectFileFilterFacets(files) {
  const typeCounts = {};
  const statusCounts = { added: 0, modified: 0, deleted: 0, renamed: 0 };
  for (const f of files || []) {
    const t = _fileTypeKey(f.path || '');
    typeCounts[t] = (typeCounts[t] || 0) + 1;
    const st = _fileStatusMeta(f).key;
    if (statusCounts[st] == null) statusCounts[st] = 0;
    statusCounts[st] += 1;
  }
  const typeOptions = Object.entries(typeCounts)
    .map(([key, count]) => ({ key, label: _fileTypeLabel(key), count }))
    .sort((a, b) => {
      const aSpecial = a.key.startsWith('__') ? 1 : 0;
      const bSpecial = b.key.startsWith('__') ? 1 : 0;
      if (aSpecial !== bSpecial) return aSpecial - bSpecial;
      if (a.label === b.label) return b.count - a.count;
      return a.label.localeCompare(b.label);
    });
  return { typeOptions, statusCounts };
}

function _syncFileFilterState(files) {
  const facets = _collectFileFilterFacets(files);
  const active = {};
  for (const t of facets.typeOptions) active[t.key] = (state.fileFilterTypes[t.key] !== false);
  state.fileFilterTypes = active;
  for (const key of ['added', 'modified', 'deleted', 'renamed']) {
    if (state.fileFilterStatus[key] == null) state.fileFilterStatus[key] = true;
  }
  return facets;
}

function _isStructuredFileFilterActive(facets = null) {
  const f = facets || _collectFileFilterFacets(state.files);
  const typeTotal = f.typeOptions.length;
  const typeSelected = f.typeOptions.filter(t => state.fileFilterTypes[t.key] !== false).length;
  const statusKeys = ['added', 'modified', 'deleted', 'renamed'];
  const statusSelected = statusKeys.filter(k => state.fileFilterStatus[k] !== false).length;
  return (typeTotal > 0 && typeSelected < typeTotal) || statusSelected < statusKeys.length;
}

function _hideFileFilterPopover() {
  const pop = document.getElementById('file-filter-popover');
  if (!pop) return;
  pop.classList.remove('show');
  pop.style.left = '-9999px';
  pop.style.top = '-9999px';
}

function _positionFileFilterPopover() {
  const pop = document.getElementById('file-filter-popover');
  const btn = document.getElementById('file-filter-mode-btn');
  if (!pop || !btn) return;
  const b = btn.getBoundingClientRect();
  pop.classList.add('show');
  pop.style.left = '0px';
  pop.style.top = '0px';
  const rect = pop.getBoundingClientRect();
  const left = Math.max(8, Math.min(b.right - rect.width, window.innerWidth - rect.width - 8));
  const top = Math.max(8, Math.min(b.bottom + 6, window.innerHeight - rect.height - 8));
  pop.style.left = `${left}px`;
  pop.style.top = `${top}px`;
}

function _renderFileFilterPopover() {
  const pop = document.getElementById('file-filter-popover');
  if (!pop) return;
  const facets = _syncFileFilterState(state.files);
  const statusItems = [
    { key: 'added', label: 'Added' },
    { key: 'modified', label: 'Modified' },
    { key: 'deleted', label: 'Deleted' },
    { key: 'renamed', label: 'Renamed' },
  ];
  const statusKeys = statusItems.map(s => s.key);
  const allTypesChecked = facets.typeOptions.every(t => state.fileFilterTypes[t.key] !== false);
  const allStatusesChecked = statusKeys.every(k => state.fileFilterStatus[k] !== false);
  const statusTotalCount = statusKeys.reduce((sum, key) => sum + (facets.statusCounts[key] || 0), 0);
  const typeRows = facets.typeOptions.map((t) => {
    const checked = state.fileFilterTypes[t.key] !== false;
    return `<button type="button" class="file-filter-item" data-act="type" data-key="${_escapeAttr(t.key)}">
      <span class="check">${checked ? '✓' : ''}</span>
      <span class="label">${esc(t.label)}</span>
      <span class="count">${t.count}</span>
    </button>`;
  }).join('');
  const statusRows = statusItems.map((s) => {
    const checked = state.fileFilterStatus[s.key] !== false;
    const count = facets.statusCounts[s.key] || 0;
    return `<button type="button" class="file-filter-item" data-act="status" data-key="${_escapeAttr(s.key)}">
      <span class="check">${checked ? '✓' : ''}</span>
      <span class="label">${esc(s.label)}</span>
      <span class="count">${count}</span>
    </button>`;
  }).join('');
  pop.innerHTML = `
    <div class="file-filter-section-title">File extensions</div>
    <button type="button" class="file-filter-item" data-act="types-all">
      <span class="check">${allTypesChecked ? '✓' : ''}</span>
      <span class="label">All extensions</span>
      <span class="count">${facets.typeOptions.length}</span>
    </button>
    ${typeRows || '<div class="file-filter-section-title">확장자 없음</div>'}
    <div class="sep"></div>
    <div class="file-filter-section-title">File status</div>
    <button type="button" class="file-filter-item" data-act="statuses-all">
      <span class="check">${allStatusesChecked ? '✓' : ''}</span>
      <span class="label">All statuses</span>
      <span class="count">${statusTotalCount}</span>
    </button>
    ${statusRows}
  `;
}

function _toggleFileFilterType(typeKey) {
  const key = String(typeKey || '');
  if (!key) return;
  state.fileFilterTypes[key] = !(state.fileFilterTypes[key] !== false);
}

function _setAllFileFilterTypes(enabled) {
  const facets = _collectFileFilterFacets(state.files);
  for (const t of facets.typeOptions) state.fileFilterTypes[t.key] = !!enabled;
}

function _setAllFileFilterStatuses(enabled) {
  for (const key of ['added', 'modified', 'deleted', 'renamed']) state.fileFilterStatus[key] = !!enabled;
}

function _toggleFileFilterStatus(statusKey) {
  const key = String(statusKey || '');
  if (!key) return;
  state.fileFilterStatus[key] = !(state.fileFilterStatus[key] !== false);
}

function _ensureFileFilterPopoverEvents() {
  if (_fileFilterPopoverBound) return;
  const pop = document.getElementById('file-filter-popover');
  if (!pop) return;

  pop.addEventListener('click', (event) => {
    const item = event.target?.closest?.('.file-filter-item');
    if (!item) return;
    event.preventDefault();
    event.stopPropagation();
    const act = item.dataset?.act || '';
    if (act === 'type') {
      _toggleFileFilterType(item.dataset?.key || '');
    } else if (act === 'status') {
      _toggleFileFilterStatus(item.dataset?.key || '');
    } else if (act === 'types-all') {
      const facets = _collectFileFilterFacets(state.files);
      const allOn = facets.typeOptions.every(t => state.fileFilterTypes[t.key] !== false);
      _setAllFileFilterTypes(!allOn);
    } else if (act === 'statuses-all') {
      const allOn = ['added', 'modified', 'deleted', 'renamed'].every(k => state.fileFilterStatus[k] !== false);
      _setAllFileFilterStatuses(!allOn);
    } else {
      return;
    }
    renderFilePanel();
    _renderFileFilterPopover();
    _positionFileFilterPopover();
  });

  document.addEventListener('click', (event) => {
    const btn = document.getElementById('file-filter-mode-btn');
    if (pop.contains(event.target) || btn?.contains(event.target)) return;
    _hideFileFilterPopover();
  });
  document.addEventListener('scroll', () => _hideFileFilterPopover(), true);
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') _hideFileFilterPopover();
  });
  window.addEventListener('resize', () => {
    if (!pop.classList.contains('show')) return;
    _positionFileFilterPopover();
  });
  window.addEventListener('blur', () => _hideFileFilterPopover());
  _fileFilterPopoverBound = true;
}

function toggleFileFilterPopover(event) {
  event?.stopPropagation?.();
  _ensureFileFilterPopoverEvents();
  const pop = document.getElementById('file-filter-popover');
  if (!pop) return;
  if (pop.classList.contains('show')) {
    _hideFileFilterPopover();
    return;
  }
  _syncFileFilterState(state.files);
  _renderFileFilterPopover();
  _positionFileFilterPopover();
}

function _updateFileFilterUi(facets = null) {
  const input = document.getElementById('file-filter-input');
  const btn = document.getElementById('file-filter-mode-btn');
  if (input && input.value !== state.fileFilterQuery) input.value = state.fileFilterQuery;
  if (btn) {
    const currentFacets = facets || _collectFileFilterFacets(state.files);
    const active = _isStructuredFileFilterActive(currentFacets);
    btn.innerHTML = `☰${active ? '<span class="dot"></span>' : ''}`;
    btn.title = active ? '파일 필터 (적용 중)' : '파일 필터';
    btn.classList.toggle('active', active);
  }
}

function _passesFileFilter(file) {
  const query = (state.fileFilterQuery || '').trim().toLowerCase();
  const path = String(file?.path || '');
  if (query && !path.toLowerCase().includes(query)) return false;
  const st = _fileStatusMeta(file).key;
  if (state.fileFilterStatus[st] === false) return false;
  const typeKey = _fileTypeKey(path);
  if (state.fileFilterTypes[typeKey] === false) return false;
  return true;
}

function _selectedIssueFilePath() {
  if (!state.selectedIssue) return '';
  const issue = state.issues.find(i => i.id === state.selectedIssue);
  return issue?.file || '';
}

function _isSelectedFilePath(path) {
  const filePath = String(path || '');
  if (!filePath) return false;
  if (state.selectedFileDiff === filePath) return true;
  return _selectedIssueFilePath() === filePath;
}

function _expandFileTreeAncestors(path) {
  const parts = String(path || '').split('/').filter(Boolean);
  if (parts.length <= 1) return;
  let acc = '';
  for (let i = 0; i < parts.length - 1; i++) {
    acc = acc ? `${acc}/${parts[i]}` : parts[i];
    state.fileTreeExpanded[acc] = true;
  }
}

function _syncSelectedFileTreeExpansion() {
  const path = state.selectedFileDiff || _selectedIssueFilePath();
  if (!path) {
    _fileTreeAutoExpandedPath = '';
    return;
  }
  if (_fileTreeAutoExpandedPath === path) return;
  _expandFileTreeAncestors(path);
  _fileTreeAutoExpandedPath = path;
}

function _fileTreeDefaultExpanded(depth) {
  return true;
}

function _isFileTreeExpanded(key, depth) {
  if (state.fileTreeExpanded[key] === true) return true;
  if (state.fileTreeExpanded[key] === false) return false;
  return _fileTreeDefaultExpanded(depth);
}

function _sortedFileTreeChildren(node) {
  const children = Array.from(node.children?.values?.() || []);
  children.sort((a, b) => {
    if (a.kind !== b.kind) return a.kind === 'dir' ? -1 : 1;
    return a.name.localeCompare(b.name);
  });
  return children;
}

function _compressSingleChildDirChains(node, isRoot = false) {
  if (!node || node.kind !== 'dir') return node;

  for (const child of node.children.values()) {
    if (child.kind === 'dir') _compressSingleChildDirChains(child, false);
  }

  if (isRoot) return node;

  while (node.children.size === 1) {
    const onlyChild = Array.from(node.children.values())[0];
    if (!onlyChild || onlyChild.kind !== 'dir') break;
    node.name = node.name ? `${node.name}/${onlyChild.name}` : onlyChild.name;
    node.key = onlyChild.key;
    node.children = onlyChild.children;
    node.fileCount = onlyChild.fileCount;
  }
  return node;
}

function _buildFileTree(files) {
  const root = { kind: 'dir', key: '', name: '', children: new Map(), fileCount: 0 };
  for (const file of files || []) {
    const rawPath = String(file.path || '').trim();
    if (!rawPath) continue;
    const parts = rawPath.split('/').filter(Boolean);
    if (!parts.length) continue;
    let cursor = root;
    let key = '';
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      key = key ? `${key}/${part}` : part;
      const isFile = i === parts.length - 1;
      if (!cursor.children.has(part)) {
        if (isFile) cursor.children.set(part, { kind: 'file', key, name: part, file: { ...file, path: rawPath } });
        else cursor.children.set(part, { kind: 'dir', key, name: part, children: new Map(), fileCount: 0 });
      }
      const node = cursor.children.get(part);
      if (isFile) {
        node.file = { ...file, path: rawPath };
      } else {
        cursor = node;
      }
    }
  }

  const countFiles = (node) => {
    if (node.kind === 'file') return 1;
    let count = 0;
    for (const child of node.children.values()) count += countFiles(child);
    node.fileCount = count;
    return count;
  };
  countFiles(root);
  _compressSingleChildDirChains(root, true);
  return root;
}

function _fileStatusMeta(file) {
  const raw = String(file?.status || '').toLowerCase();
  if (raw === 'added' || raw === 'new') return { key: 'added', icon: 'A', label: '추가' };
  if (raw === 'deleted' || raw === 'removed') return { key: 'deleted', icon: 'D', label: '삭제' };
  if (raw === 'renamed') return { key: 'renamed', icon: 'R', label: '이동/이름변경' };
  if (raw === 'modified' || raw === 'changed') return { key: 'modified', icon: 'M', label: '수정' };
  const additions = Number(file?.additions || 0);
  const deletions = Number(file?.deletions || 0);
  if (additions > 0 && deletions === 0) return { key: 'added', icon: 'A', label: '추가' };
  if (deletions > 0 && additions === 0) return { key: 'deleted', icon: 'D', label: '삭제' };
  return { key: 'modified', icon: 'M', label: '수정' };
}

function _renderFileTreeNode(node, depth) {
  if (node.kind === 'file') {
    const file = node.file || {};
    const filePath = String(file.path || node.key || '');
    const statusMeta = _fileStatusMeta(file);
    const activeClass = _isSelectedFilePath(filePath) ? ' active' : '';
    return `<div class="file-tree-row file-tree-file${activeClass}" style="--depth:${depth}" data-path="${_escapeAttr(filePath)}" data-full-path="${_escapeAttr(filePath)}" data-kind="file" onclick="onFileTreeFileClick(this)" oncontextmenu="onFileTreeFileContextMenu(event, this)" onmouseenter="onFileTreeRowEnter(event,this)" onmousemove="onFileTreeRowMove(event)" onmouseleave="onFileTreeRowLeave()">
      <span class="file-tree-twist"></span>
      <span class="file-tree-status ${statusMeta.key}" title="${_escapeAttr(statusMeta.label)}">${statusMeta.icon}</span>
      <span class="file-tree-label">${esc(node.name)}</span>${_getFileAgentDots(filePath)}
    </div>`;
  }

  const expanded = _isFileTreeExpanded(node.key, depth);
  const twisty = expanded ? '\u25BE' : '\u25B8';
  const row = `<div class="file-tree-row file-tree-dir" style="--depth:${depth}" data-key="${_escapeAttr(node.key)}" data-full-path="${_escapeAttr(node.key)}" data-kind="dir" data-expanded="${expanded ? '1' : '0'}" onclick="onFileTreeDirClick(this)" oncontextmenu="onFileTreeDirContextMenu(event, this)" onmouseenter="onFileTreeRowEnter(event,this)" onmousemove="onFileTreeRowMove(event)" onmouseleave="onFileTreeRowLeave()">
    <span class="file-tree-twist">${twisty}</span>
    <span class="file-tree-icon folder">\uD83D\uDCC1</span>
    <span class="file-tree-label">${esc(node.name)}</span>
  </div>`;
  if (!expanded) return row;
  const childrenHtml = _sortedFileTreeChildren(node).map(child => _renderFileTreeNode(child, depth + 1)).join('');
  return `${row}<div class="file-tree-children">${childrenHtml}</div>`;
}

function _joinRepoPath(root, relPath) {
  const base = String(root || '').trim();
  const rel = String(relPath || '').trim();
  if (!base) return rel;
  if (!rel) return base;
  if (base.endsWith('/') || base.endsWith('\\')) return base + rel;
  const sep = base.includes('\\') && !base.includes('/') ? '\\' : '/';
  return `${base}${sep}${rel}`;
}

function _getCurrentSessionRepoPath() {
  const current = state.sessions.find(s => s.session_id === state.sessionId);
  return current?.repo_path || '';
}

function _resolveFilePathForCopy(path) {
  const repoRoot = _getCurrentSessionRepoPath();
  return repoRoot ? _joinRepoPath(repoRoot, path) : path;
}

let _fileContextMenuPath = '';
let _fileContextMenuKind = 'file';
let _fileContextMenuPos = { x: 0, y: 0 };

function _currentFileOpener() {
  const available = (_fileOpeners || []).filter(o => o && (o.available || o.id === 'default'));
  const found = available.find(o => o.id === state.fileOpenerId);
  if (found) return found;
  return available.find(o => o.id === 'default') || { id: 'default', label: '기본 앱', available: true };
}

function _setFileOpener(openerId) {
  const id = String(openerId || '').trim();
  const available = (_fileOpeners || []).filter(o => o && (o.available || o.id === 'default'));
  const picked = available.find(o => o.id === id);
  state.fileOpenerId = picked ? picked.id : 'default';
}

async function _loadFileOpeners() {
  try {
    const r = await fetch('/api/fs/openers');
    if (!r.ok) return;
    const data = await r.json();
    const list = Array.isArray(data?.openers) ? data.openers : [];
    const normalized = [];
    for (const item of list) {
      const id = String(item?.id || '').trim();
      const label = String(item?.label || '').trim();
      if (!id || !label) continue;
      normalized.push({ id, label, available: item?.available !== false });
    }
    if (!normalized.some(o => o.id === 'default')) normalized.unshift({ id: 'default', label: '기본 앱', available: true });
    _fileOpeners = normalized;
    _setFileOpener(state.fileOpenerId || 'default');
  } catch (e) {}
}

function _hideFileHoverTooltip() {
  if (_fileHoverTimer) {
    clearTimeout(_fileHoverTimer);
    _fileHoverTimer = null;
  }
  _fileHoverPayload = null;
  const tooltip = document.getElementById('file-hover-tooltip');
  if (!tooltip) return;
  tooltip.classList.remove('show');
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
}

function _ensureFileHoverTooltip() {
  let tooltip = document.getElementById('file-hover-tooltip');
  if (tooltip) return tooltip;
  tooltip = document.createElement('div');
  tooltip.id = 'file-hover-tooltip';
  tooltip.className = 'file-hover-tooltip';
  document.body.appendChild(tooltip);
  return tooltip;
}

function _positionFileHoverTooltip(tooltip, x, y) {
  const offset = 14;
  tooltip.style.left = '0px';
  tooltip.style.top = '0px';
  const rect = tooltip.getBoundingClientRect();
  const maxLeft = Math.max(8, window.innerWidth - rect.width - 8);
  const maxTop = Math.max(8, window.innerHeight - rect.height - 8);
  const left = Math.max(8, Math.min(x + offset, maxLeft));
  const top = Math.max(8, Math.min(y + offset, maxTop));
  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

function onFileTreeRowEnter(event, el) {
  _hideFileHoverTooltip();
  const fullPath = String(el?.dataset?.fullPath || el?.dataset?.path || el?.dataset?.key || '').trim();
  if (!fullPath) return;
  _fileHoverPayload = { text: fullPath, x: event?.clientX || 0, y: event?.clientY || 0 };
  _fileHoverTimer = setTimeout(() => {
    const payload = _fileHoverPayload;
    if (!payload) return;
    const tooltip = _ensureFileHoverTooltip();
    tooltip.textContent = payload.text;
    tooltip.classList.add('show');
    _positionFileHoverTooltip(tooltip, payload.x, payload.y);
  }, 200);
}

function onFileTreeRowMove(event) {
  if (_fileHoverPayload) {
    _fileHoverPayload.x = event?.clientX || _fileHoverPayload.x;
    _fileHoverPayload.y = event?.clientY || _fileHoverPayload.y;
  }
  const tooltip = document.getElementById('file-hover-tooltip');
  if (tooltip?.classList.contains('show')) {
    _positionFileHoverTooltip(tooltip, event?.clientX || 0, event?.clientY || 0);
  }
}

function onFileTreeRowLeave() {
  _hideFileHoverTooltip();
}

function _hideFileContextMenu() {
  const menu = document.getElementById('file-context-menu');
  if (!menu) return;
  menu.classList.remove('show');
  menu.style.left = '-9999px';
  menu.style.top = '-9999px';
}

function _contextOpenActionLabel() {
  const opener = _currentFileOpener();
  if (opener.id === 'auto') {
    return _fileContextMenuKind === 'dir' ? '자동 도구로 폴더 열기' : '자동 도구로 파일 열기';
  }
  if (_fileContextMenuKind === 'dir') {
    return opener.id === 'default' ? '폴더 열기' : `${opener.label}로 폴더 열기`;
  }
  return opener.id === 'default' ? '파일 열기' : `${opener.label}로 파일 열기`;
}

function _renderFileContextMenuContent(menu) {
  const availableOpeners = (_fileOpeners || []).filter(o => o && (o.available || o.id === 'default'));
  const current = _currentFileOpener();
  const openerItems = availableOpeners.map((opener) => {
    const active = opener.id === current.id ? ' active' : '';
    const check = opener.id === current.id ? '✓ ' : '';
    return `<button type="button" class="file-context-item${active}" data-action="set-opener" data-opener-id="${_escapeAttr(opener.id)}">${check}${esc(opener.label)}</button>`;
  }).join('');
  menu.innerHTML = `
    <button type="button" class="file-context-item" data-action="open">${esc(_contextOpenActionLabel())}</button>
    <button type="button" class="file-context-item" data-action="copy">경로 복사</button>
    <div class="file-context-sep"></div>
    <div class="file-context-title">열기 도구</div>
    ${openerItems}`;
}

function _ensureFileContextMenu() {
  let menu = document.getElementById('file-context-menu');
  if (menu) return menu;
  menu = document.createElement('div');
  menu.id = 'file-context-menu';
  menu.className = 'file-context-menu';
  menu.addEventListener('contextmenu', (e) => e.preventDefault());
  menu.addEventListener('click', async (e) => {
    const btn = e.target?.closest?.('.file-context-item');
    if (!btn) return;
    const action = btn.dataset?.action || '';
    if (action === 'open') {
      await onFileContextMenuOpen();
      return;
    }
    if (action === 'copy') {
      await onFileContextMenuCopyPath();
      return;
    }
    if (action === 'set-opener') {
      const openerId = btn.dataset?.openerId || 'default';
      _setFileOpener(openerId);
      _renderFileContextMenuContent(menu);
      showToast(`열기 도구: ${_currentFileOpener().label}`);
    }
  });
  document.body.appendChild(menu);

  document.addEventListener('click', (e) => {
    if (!menu.contains(e.target)) _hideFileContextMenu();
  });
  document.addEventListener('contextmenu', (e) => {
    if (!menu.contains(e.target)) _hideFileContextMenu();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') _hideFileContextMenu();
  });
  document.addEventListener('scroll', () => {
    _hideFileContextMenu();
    _hideFileHoverTooltip();
  }, true);
  window.addEventListener('resize', () => {
    _hideFileContextMenu();
    _hideFileHoverTooltip();
  });
  window.addEventListener('blur', () => {
    _hideFileContextMenu();
    _hideFileHoverTooltip();
  });
  return menu;
}

function _positionFileContextMenu(menu, x, y) {
  menu.style.left = '0px';
  menu.style.top = '0px';
  menu.classList.add('show');
  const rect = menu.getBoundingClientRect();
  const maxLeft = Math.max(8, window.innerWidth - rect.width - 8);
  const maxTop = Math.max(8, window.innerHeight - rect.height - 8);
  const left = Math.max(8, Math.min(x, maxLeft));
  const top = Math.max(8, Math.min(y, maxTop));
  menu.style.left = `${left}px`;
  menu.style.top = `${top}px`;
}

function _openFileTreeContextMenu(event, el, kind) {
  event.preventDefault();
  event.stopPropagation();
  _hideFileHoverTooltip();
  const path = el?.dataset?.path || el?.dataset?.key || '';
  if (!path) return;
  _fileContextMenuPath = path;
  _fileContextMenuKind = kind === 'dir' ? 'dir' : 'file';
  _fileContextMenuPos = { x: event.clientX, y: event.clientY };
  const menu = _ensureFileContextMenu();
  _renderFileContextMenuContent(menu);
  _positionFileContextMenu(menu, _fileContextMenuPos.x, _fileContextMenuPos.y);
  _loadFileOpeners().then(() => {
    if (!menu.classList.contains('show')) return;
    _renderFileContextMenuContent(menu);
    _positionFileContextMenu(menu, _fileContextMenuPos.x, _fileContextMenuPos.y);
  });
}

function onFileTreeFileContextMenu(event, el) {
  _openFileTreeContextMenu(event, el, 'file');
}

function onFileTreeDirContextMenu(event, el) {
  _openFileTreeContextMenu(event, el, 'dir');
}

async function _copyFileTreePath(path) {
  const filePath = String(path || '').trim();
  if (!filePath) return;
  const resolvedPath = _resolveFilePathForCopy(filePath);
  if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
    showToast('클립보드 복사를 지원하지 않습니다', 'error');
    return;
  }
  try {
    await navigator.clipboard.writeText(resolvedPath);
    showToast('파일 경로를 복사했습니다');
  } catch (e) {
    showToast('파일 경로 복사 실패', 'error');
  }
}

async function _openFileTreePath(path, kind = 'file') {
  const filePath = String(path || '').trim();
  if (!filePath) return;
  const opener = _currentFileOpener();
  try {
    const r = await fetch('/api/fs/open', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: filePath, session_id: state.sessionId, opener_id: opener.id }),
    });
    let data = {};
    try { data = await r.json(); } catch (e) {}
    if (!r.ok) {
      showToast(data.detail || '로컬 파일 열기 실패', 'error');
      return;
    }
    if (kind === 'dir') showToast('폴더를 열었습니다');
    else showToast('파일을 열었습니다');
  } catch (e) {
    showToast('로컬 파일 열기 실패', 'error');
  }
}

async function onFileContextMenuOpen() {
  const path = _fileContextMenuPath;
  const kind = _fileContextMenuKind;
  _hideFileContextMenu();
  await _openFileTreePath(path, kind);
}

async function onFileContextMenuCopyPath() {
  const path = _fileContextMenuPath;
  _hideFileContextMenu();
  await _copyFileTreePath(path);
}

function onFileTreeDirClick(el) {
  _hideFileHoverTooltip();
  _hideFileContextMenu();
  const key = el?.dataset?.key || '';
  if (!key) return;
  const current = el?.dataset?.expanded === '1';
  state.fileTreeExpanded[key] = !current;
  renderFilePanel();
}

async function onFileTreeFileClick(el) {
  _hideFileHoverTooltip();
  _hideFileContextMenu();
  const path = el?.dataset?.path || '';
  if (!path) return;
  await filterByFile(path);
}

function renderFilePanel() {
  _hideFileHoverTooltip();
  _hideFileContextMenu();
  const facets = _syncFileFilterState(state.files);
  _updateFileFilterUi(facets);
  const panel = document.getElementById('file-panel');
  if (!state.files.length) {
    const listEl = document.getElementById('file-list');
    const toolsEl = document.getElementById('file-tools');
    const toggleEl = document.getElementById('file-toggle');
    panel.style.display = 'none';
    panel.classList.remove('collapsed');
    listEl?.classList.remove('collapsed');
    toolsEl?.classList.remove('collapsed');
    toggleEl?.classList.remove('collapsed');
    _syncLeftPaneLayout();
    return;
  }
  panel.style.display='';
  _syncLeftPaneLayout();
  const filteredFiles = state.files.filter(_passesFileFilter);
  const countText = filteredFiles.length === state.files.length
    ? `${state.files.length}개`
    : `${filteredFiles.length}/${state.files.length}개`;
  document.getElementById('file-count').textContent = countText;
  const list = document.getElementById('file-list');
  _syncSelectedFileTreeExpansion();
  const tree = _buildFileTree(filteredFiles);
  const html = _sortedFileTreeChildren(tree).map(node => _renderFileTreeNode(node, 0)).join('');
  if (!html) {
    list.innerHTML = '<div class="file-tree-empty">필터 조건에 맞는 파일이 없습니다.</div>';
    return;
  }
  list.innerHTML = `<div class="file-tree-canvas">${html}</div>`;
}

async function filterByFile(path) {
  _fileTreeAutoExpandedPath = '';
  _expandFileTreeAncestors(path);
  const match = state.issues.find(i => i.file === path);
  if (match) { selectIssue(match.id); return; }
  // No matching issue — show standalone diff viewer
  state.selectedIssue = null;
  state.selectedFileDiff = path;
  renderFilePanel();
  renderIssueList();
  await renderFileDiff(path);
}

async function renderFileDiff(path) {
  const el = document.getElementById('issue-detail');
  const diffContent = await fetchDiff(path);
  const statsMeta = _renderDiffStatsMeta(path);
  el.innerHTML = `
    <div class="detail-header-bar">
      <div class="detail-title" style="font-family:'SF Mono',Monaco,monospace">${esc(path)}</div>
      <div class="detail-badges" style="margin-top:8px">
        <button class="btn" onclick="createIssueFromFile('${esc(path)}')">+ 이슈 등록</button>
      </div>
    </div>
    <div class="diff-container">
      <div class="diff-file-header"><span class="filename">${esc(path)}</span>${statsMeta}</div>
      ${diffContent ? renderDiff(diffContent, { file: path }) : '<div class="diff-loading">변경 내역 없음</div>'}
    </div>`;
}

function formatElapsed(sec) {
  if (sec == null) return '';
  if (sec < 60) return Math.floor(sec) + 's';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return m + 'm ' + s + 's';
}

// --- Agent Activity Tracking ---
const _agentActivities = {}; // modelId -> { latest: {action, target, ts}, history: [{action, target, ts}] }
const ACTIVITY_STALE_MS = 30000;
const MAX_ACTIVITY_HISTORY = 50;

const ACTIVITY_LABELS = {
  view_file: '파일 확인',
  search: '검색',
  view_tree: '구조 탐색',
  view_diff: 'diff 확인',
  view_context: '컨텍스트 확인',
  view_index: '인덱스 확인',
  Read: '파일 읽기',
  Grep: '패턴 검색',
  Glob: '파일 탐색',
  Bash: '명령 실행',
  arv_get_file: '파일 조회',
  arv_get_index: '인덱스 조회',
  arv_get_search: '코드 검색',
  arv_get_tree: '구조 조회',
  arv_get_context: '컨텍스트 조회',
  arv_get_thread: '스레드 조회',
  arv_get_delta: '델타 조회',
  arv_get_confirmed: '확정 이슈 조회',
  arv_report: '이슈 제출',
  arv_summary: '리뷰 완료',
  arv_opinion: '의견 제출',
  arv_respond: '응답 제출',
  arv_ping: '연결 테스트',
};

function _onAgentActivity(data) {
  const { model_id, action, target, timestamp } = data;
  if (!model_id) return;
  if (!_agentActivities[model_id]) {
    _agentActivities[model_id] = { latest: null, history: [] };
  }
  const entry = { action, target, ts: timestamp || new Date().toISOString() };
  _agentActivities[model_id].latest = entry;
  _agentActivities[model_id].history.unshift(entry);
  if (_agentActivities[model_id].history.length > MAX_ACTIVITY_HISTORY) {
    _agentActivities[model_id].history.pop();
  }
  _updateAgentActivityUI(model_id);
  updateSummary();
}

function _formatActivityTarget(action, target) {
  if (action === 'search' && target.startsWith('search:')) return target.slice(7);
  if (action === 'view_tree' && target.startsWith('tree:')) return target.slice(5);
  if (action === 'view_diff' && target.startsWith('diff:')) return target.slice(5);
  if (action === 'view_context' && target.startsWith('context:')) return target.slice(8);
  if (action === 'Grep' && target.startsWith('grep:')) return target.slice(5);
  if (action === 'Glob' && target.startsWith('glob:')) return target.slice(5);
  if (action === 'Bash' && target.startsWith('bash:')) return target.slice(5);
  return target;
}

function _updateAgentActivityUI(modelId) {
  const el = document.querySelector(`[data-activity-model="${CSS.escape(modelId)}"]`);
  if (!el) return;
  const info = _agentActivities[modelId];
  if (!info || !info.latest) { el.textContent = ''; return; }
  const label = ACTIVITY_LABELS[info.latest.action] || info.latest.action;
  const target = _formatActivityTarget(info.latest.action, info.latest.target);
  el.textContent = `${label}: ${target}`;
  el.title = `${label}: ${target}`;
  el.style.display = '';

  // Auto-hide after stale period
  clearTimeout(el._staleTimer);
  el._staleTimer = setTimeout(() => {
    el.textContent = '';
    el.style.display = 'none';
  }, ACTIVITY_STALE_MS);
}

function _renderActivityTimeline(modelId) {
  const info = _agentActivities[modelId];
  if (!info || !info.history.length) return '';
  const rows = info.history.slice(0, 15).map(e => {
    const label = ACTIVITY_LABELS[e.action] || e.action;
    const target = _formatActivityTarget(e.action, e.target);
    const d = new Date(e.ts);
    const time = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0');
    return `<div class="timeline-entry"><span class="timeline-time">${time}</span><span class="timeline-action">${esc(label)}</span><span class="timeline-target" title="${_escapeAttr(target)}">${esc(target)}</span></div>`;
  }).join('');
  return `<div class="reviewer-timeline">${rows}</div>`;
}

function _getFileAgentDots(filePath) {
  const dots = [];
  const seen = new Set();
  for (const [modelId, info] of Object.entries(_agentActivities)) {
    if (seen.has(modelId)) continue;
    const visited = info.history.some(e =>
      (e.action === 'view_file' || e.action === 'view_diff' || e.action === 'Read') && e.target.includes(filePath)
    );
    if (visited) {
      seen.add(modelId);
      dots.push(`<span class="file-agent-dot" style="background:${getModelColor(modelId)}" title="${_escapeAttr(modelId)}"></span>`);
    }
  }
  return dots.length ? `<span class="file-agent-dots">${dots.join('')}</span>` : '';
}

function _getActivityStats() {
  let totalCalls = 0, filesViewed = new Set(), searches = 0;
  for (const info of Object.values(_agentActivities)) {
    for (const e of info.history) {
      totalCalls++;
      if (e.action === 'view_file' || e.action === 'view_diff' || e.action === 'Read') filesViewed.add(e.target);
      if (e.action === 'search' || e.action === 'Grep') searches++;
    }
  }
  if (!totalCalls) return '';
  return `<span class="activity-stats">API ${totalCalls}회 · 파일 ${filesViewed.size}개 · 검색 ${searches}회</span>`;
}

function renderAgentPanel() {
  const list = document.getElementById('reviewers-list');
  const countEl = document.getElementById('reviewers-count');
  const prevScrollTop = list ? list.scrollTop : 0;
  const hadScrollable = !!list && list.scrollHeight > list.clientHeight;
  const hasReviewing = state.agents.some(a => a.status === 'reviewing');
  if (hasReviewing) startAgentTimer(); else stopAgentTimer();
  ensureIssueDisplayNumbers();
  if (countEl) countEl.textContent = `${state.agents.length}명`;
  if (!list) return;

  if (!state.agents.length) {
    list.innerHTML = '<div class="reviewers-empty">리뷰어가 없습니다.<br>프리셋을 추가해 시작하세요.</div>';
    return;
  }

  const statusLabel = (status) => {
    if (status === 'reviewing') return '진행중';
    if (status === 'submitted') return '완료';
    if (status === 'failed') return '실패';
    return '대기';
  };

  list.innerHTML = state.agents.map((agent) => {
    const modelId = String(agent.model_id || 'unknown');
    const modelIdEncoded = encodeURIComponent(modelId);
    const modelColor = getModelColor(modelId);
    const elapsed = formatElapsed(agent.elapsed_seconds);
    const status = String(agent.status || 'idle');
    const expanded = !!state.reviewerExpanded[modelId];
    const statusCls = status === 'reviewing'
      ? ' reviewer-status-reviewing'
      : (status === 'submitted' ? ' reviewer-status-submitted' : (status === 'failed' ? ' reviewer-status-failed' : ''));
    const issueEntries = _getReviewerIssueEntries(modelId);
    const issuesHtml = issueEntries.length
      ? issueEntries.map((entry) => {
          const issue = entry.issue || {};
          const issueId = String(issue.id || '');
          const issueIdEncoded = encodeURIComponent(issueId);
          const modelIdForIssueEncoded = encodeURIComponent(modelId);
          const tsEncoded = encodeURIComponent(String(entry.ts || ''));
          const issueNo = Number(state.issueNumberById[issueId] || 0);
          const actionKey = _normalizeReviewerAction(entry.action || 'raise');
          const actionEncoded = encodeURIComponent(actionKey);
          const actionLabel = _reviewerActionLabel(actionKey);
          const actionCls = _reviewerActionClass(actionKey);
          const rowTitle = `#${issueNo} ${String(issue.title || '').trim()}`;
          return `<div class="reviewer-issue-item" onclick="jumpToIssueFromReviewer(decodeURIComponent('${issueIdEncoded}'),decodeURIComponent('${modelIdForIssueEncoded}'),decodeURIComponent('${tsEncoded}'),decodeURIComponent('${actionEncoded}'))" title="${_escapeAttr(`${rowTitle} (${actionLabel})`)}">
            <div class="reviewer-issue-main">
              <span class="reviewer-issue-title">${esc(rowTitle)}</span>
              <span class="reviewer-opinion-badge ${actionCls}">${esc(actionLabel)}</span>
            </div>
          </div>`;
        }).join('')
      : '<div class="reviewer-issues-empty">아직 남긴 의견이 없습니다.</div>';

    return `<div class="reviewer-card${statusCls}${expanded ? ' expanded' : ''}">
      <div class="reviewer-toggle" role="button" tabindex="0" onclick="toggleReviewerIssues(decodeURIComponent('${modelIdEncoded}'))" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleReviewerIssues(decodeURIComponent('${modelIdEncoded}'));}" title="@${_escapeAttr(modelId)} 의견 보기">
        <div class="reviewer-top">
          <span class="model-dot" style="background:${modelColor}"></span>
          <span class="reviewer-name" style="color:${modelColor}">${esc(modelId)}</span>
          ${agent.role ? `<span class="reviewer-role">${esc(agent.role)}</span>` : ''}
          <span class="reviewer-status">${esc(statusLabel(status))}</span>
          <button type="button" class="reviewer-more" onclick="openReviewerChat(decodeURIComponent('${modelIdEncoded}'), event)" title="@${_escapeAttr(modelId)}에게 직접 말걸기">...</button>
          <span class="reviewer-caret">${expanded ? '▾' : '▸'}</span>
        </div>
        <div class="reviewer-meta">
          <span class="reviewer-time" data-reviewer-time-model="${_escapeAttr(modelId)}" ${elapsed ? '' : 'style="display:none"'}>${esc(elapsed || '')}</span>
        </div>
        <div class="reviewer-activity" data-activity-model="${_escapeAttr(modelId)}" style="display:none"></div>
      </div>
      ${expanded ? `<div class="reviewer-issues">${issuesHtml}</div>${_renderActivityTimeline(modelId)}` : ''}
    </div>`;
  }).join('');

  if (hadScrollable || prevScrollTop > 0) {
    const maxTop = Math.max(0, list.scrollHeight - list.clientHeight);
    list.scrollTop = Math.min(prevScrollTop, maxTop);
  }
}

function renderIssueFilterOptions() {
  const sel = document.getElementById('filter-agent');
  if (!sel) return;
  const prev = sel.value;
  const savedAgent = _uiSavedFilters?.agent || '';
  const ids = [...new Set(state.agents.map(a => a.model_id).filter(Boolean))].sort();
  sel.innerHTML = `<option value="">전체 에이전트</option>${ids.map(id => `<option value="${esc(id)}">${esc(id)}</option>`).join('')}`;
  if (ids.includes(prev)) {
    sel.value = prev;
  } else if (ids.includes(savedAgent)) {
    sel.value = savedAgent;
  } else {
    sel.value = '';
  }
}

function startAgentTimer() {
  if (agentTimerInterval) return;
  agentTimerInterval = setInterval(() => {
    state.agents.forEach(a => {
      if (a.status === 'reviewing' && a.elapsed_seconds != null) a.elapsed_seconds += 1;
    });
    if (_shouldDeferIssueRender()) return;
    refreshReviewerElapsedTimes();
  }, 1000);
}

function stopAgentTimer() {
  if (agentTimerInterval) { clearInterval(agentTimerInterval); agentTimerInterval = null; }
}

function refreshReviewerElapsedTimes() {
  const list = document.getElementById('reviewers-list');
  if (!list) return;
  const nodes = list.querySelectorAll('[data-reviewer-time-model]');
  if (!nodes.length) return;
  const byModel = new Map((state.agents || []).map((a) => [String(a.model_id || ''), a]));
  nodes.forEach((node) => {
    const modelId = String(node.dataset.reviewerTimeModel || '');
    const agent = byModel.get(modelId);
    const elapsed = agent ? formatElapsed(agent.elapsed_seconds) : '';
    if (elapsed) {
      node.textContent = elapsed;
      node.style.display = '';
    } else {
      node.textContent = '';
      node.style.display = 'none';
    }
  });
}

function renderIssueList() {
  const el = document.getElementById('issue-list');
  _hideFileHoverTooltip();
  ensureIssueDisplayNumbers();
  const filtered = getFilteredIssues();
  if (!filtered.length) {
    el.innerHTML = '<div class="empty-state"><div class="icon">&#128269;</div><div class="message">조건에 맞는 이슈가 없습니다</div><div class="hint">필터를 조정해보세요</div></div>';
    _uiSaveStateToStorage();
    return;
  }

  const grouped = {};
  for (const issue of filtered) {
    const key = issueGroupKey(issue);
    grouped[key] = grouped[key] || [];
    grouped[key].push(issue);
  }

  el.innerHTML = Object.keys(grouped).sort().map((gk) => {
    const items = grouped[gk];
    const collapsed = !!state.collapsedIssueGroups[gk];
    const toggleCls = collapsed ? 'issue-group-toggle collapsed' : 'issue-group-toggle';
    const title = `${items[0].file} · ${items.length}개`;
    const encodedKey = encodeURIComponent(gk);
    const groupHeader = `<div class="issue-group-header" data-full-path="${_escapeAttr(title)}" onclick="toggleIssueGroup(decodeURIComponent('${encodedKey}'))" onmouseenter="onFileTreeRowEnter(event,this)" onmousemove="onFileTreeRowMove(event)" onmouseleave="onFileTreeRowLeave()"><span class="${toggleCls}">▾</span><span class="issue-group-label">${esc(title)}</span></div>`;
    if (collapsed) return groupHeader;
    return groupHeader + items.map((issue) => {
    const displayNo = state.issueNumberById[issue.id] || 0;
    const sev = issue.final_severity || issue.severity;
    const icon = SEVERITY_ICONS[sev]||'\u26AA';
    const color = SEVERITY_COLORS[sev]||'#6B7280';
    const active = state.selectedIssue===issue.id?' active':'';
    const cLabel = issue.consensus===true?'\u2705':issue.consensus===false?'\u26A0':'\u23F3';
    const raisedBy = issue.raised_by||'';
    const rangeLabel = _issueRangeLabel(issue);
    const itemHover = `#${displayNo} ${issue.title || ''}`;
    return `<div class="issue-item${active}" data-issue-id="${_escapeAttr(issue.id)}" data-full-path="${_escapeAttr(itemHover)}" onclick="selectIssue('${issue.id}')" onmouseenter="onFileTreeRowEnter(event,this)" onmousemove="onFileTreeRowMove(event)" onmouseleave="onFileTreeRowLeave()">
      <span class="issue-icon">${icon}</span>
      <div class="issue-info">
        <div class="issue-title">#${displayNo} ${esc(issue.title)}</div>
        <div class="issue-meta">
          <span class="severity-badge" style="background:${color}20;color:${color}">${sevLabel(sev)}</span>
          <span>${cLabel}</span>
          ${rangeLabel
            ? `<span style="font-family:'SF Mono',Monaco,monospace;color:var(--text-muted)">L${esc(rangeLabel)}</span>`
            : `<span style="color:var(--severity-high);font-size:11px">라인 미지정</span>`}
          <span style="color:${getModelColor(raisedBy)}">${esc(raisedBy)}</span>
        </div>
      </div>
    </div>`;
    }).join('');
  }).join('');
  // Add manual issue creation button (only when not complete)
  if (state.status !== 'complete') {
    el.innerHTML += `<div style="padding:10px 14px;border-bottom:1px solid var(--border)">
      <button class="btn" style="width:100%;text-align:center" onclick="createIssueFromFile('')">+ 이슈 등록</button>
    </div>`;
  }
  _uiSaveStateToStorage();
}

function parseDiffLines(content) {
  if (!content) return [];
  const lines = content.split('\n');
  const result = [];
  let oldLine = 0, newLine = 0;
  for (const line of lines) {
    const trimmed = line.trimStart();
    if (trimmed.startsWith('@@')) {
      const m = line.match(/@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@(.*)/);
      if (m) { oldLine = parseInt(m[1]); newLine = parseInt(m[2]); }
      result.push({ type:'hunk', text:line });
    } else if (/^(diff --git|index |---\s|\+\+\+\s|new file mode|deleted file mode|similarity index|rename from |rename to |old mode |new mode )/.test(trimmed)) {
      // Skip patch metadata lines such as --- /dev/null, +++ b/path
      continue;
    } else if (line.startsWith('+')) {
      result.push({ type:'add', old:'', new:newLine, text:line.slice(1) });
      newLine++;
    } else if (line.startsWith('-')) {
      result.push({ type:'del', old:oldLine, new:'', text:line.slice(1) });
      oldLine++;
    } else {
      const text = line.startsWith(' ') ? line.slice(1) : line;
      result.push({ type:'ctx', old:oldLine, new:newLine, text });
      oldLine++; newLine++;
    }
  }
  return result;
}

function _findFileInfo(path) {
  const filePath = String(path || '');
  if (!filePath) return null;
  return state.files.find(f => f.path === filePath) || null;
}

function _isModifiedFileDiff(filePath, rows) {
  const info = _findFileInfo(filePath);
  if (info) {
    const adds = Number(info.additions || 0);
    const dels = Number(info.deletions || 0);
    return adds > 0 && dels > 0;
  }
  let hasAdd = false;
  let hasDel = false;
  for (const row of rows || []) {
    if (row.type === 'add') hasAdd = true;
    if (row.type === 'del') hasDel = true;
    if (hasAdd && hasDel) return true;
  }
  return false;
}

function _renderDiffStatsMeta(filePath) {
  const info = _findFileInfo(filePath);
  if (!info) return '';
  const adds = Number(info.additions || 0);
  const dels = Number(info.deletions || 0);
  return `<span class="diff-file-meta"><span class="add">+${adds}</span><span class="del">-${dels}</span></span>`;
}

function _renderUnifiedDiffTable(rows, issueRef, language, enableHighlight) {
  let html = '<table class="diff-table">';
  for (const l of rows) {
    if (l.type === 'hunk') {
      html += `<tr class="diff-hunk"><td colspan="3">${esc(l.text)}</td></tr>`;
      continue;
    }
    const cls = l.type === 'add' ? 'diff-add' : l.type === 'del' ? 'diff-del' : 'diff-context';
    const marker = _isIssueTargetLine(issueRef, l.new) ? ' diff-issue-marker' : '';
    const prefix = l.type === 'add' ? '+' : l.type === 'del' ? '-' : ' ';
    const content = _renderDiffLineContent(prefix, l.text, language, enableHighlight);
    html += `<tr class="${cls}${marker}"><td class="diff-line-num">${l.old}</td><td class="diff-line-num">${l.new}</td><td class="diff-line-content">${content}</td></tr>`;
  }
  html += '</table>';
  return html;
}

function _hasVeryLongToken(text, limit = 140) {
  const raw = String(text || '');
  if (!raw) return false;
  return raw.split(/\s+/).some(token => token.length >= limit);
}

function _shouldStackSplitPair(leftLine, rightLine) {
  if (!leftLine || !rightLine) return false;
  const leftText = String(leftLine.text || '');
  const rightText = String(rightLine.text || '');
  if ((leftText.length + rightText.length) >= 180) return true;
  if (Math.max(leftText.length, rightText.length) >= 220) return true;
  return _hasVeryLongToken(leftText) || _hasVeryLongToken(rightText);
}

function _renderSplitDiffTable(rows, issueRef, language, enableHighlight) {
  let html = '<table class="diff-table diff-split-table"><colgroup><col style="width:46px"><col><col style="width:46px"><col></colgroup>';
  let i = 0;

  const splitRow = (leftLine, rightLine, extraClass = '') => {
    const leftNum = leftLine ? leftLine.old : '';
    const rightNum = rightLine ? rightLine.new : '';
    const leftCls = leftLine ? (leftLine.type === 'del' ? 'diff-del' : 'diff-context') : 'diff-empty';
    const rightCls = rightLine ? (rightLine.type === 'add' ? 'diff-add' : 'diff-context') : 'diff-empty';
    const marker = _isIssueTargetLine(issueRef, rightLine?.new) ? ' diff-issue-marker' : '';
    const leftContent = leftLine
      ? _renderDiffLineContent(leftLine.type === 'del' ? '-' : ' ', leftLine.text, language, enableHighlight)
      : '';
    const rightContent = rightLine
      ? _renderDiffLineContent(rightLine.type === 'add' ? '+' : ' ', rightLine.text, language, enableHighlight)
      : '';
    return `<tr${extraClass ? ` class="${extraClass}"` : ''}>
      <td class="diff-line-num diff-split-old-num ${leftCls}">${leftNum}</td>
      <td class="diff-line-content diff-split-old-content ${leftCls}">${leftContent}</td>
      <td class="diff-line-num diff-split-new-num ${rightCls}${marker}">${rightNum}</td>
      <td class="diff-line-content diff-split-new-content ${rightCls}${marker}">${rightContent}</td>
    </tr>`;
  };

  const splitRowPair = (leftLine, rightLine) => {
    if (_shouldStackSplitPair(leftLine, rightLine)) {
      return (
        splitRow(leftLine, null, 'diff-split-row-stack') +
        splitRow(null, rightLine, 'diff-split-row-stack')
      );
    }
    return splitRow(leftLine, rightLine);
  };

  while (i < rows.length) {
    const line = rows[i];
    if (line.type === 'hunk') {
      html += `<tr class="diff-hunk"><td colspan="4">${esc(line.text)}</td></tr>`;
      i += 1;
      continue;
    }
    if (line.type === 'ctx') {
      html += splitRow(line, line);
      i += 1;
      continue;
    }

    const delRows = [];
    const addRows = [];
    while (i < rows.length && rows[i].type !== 'ctx' && rows[i].type !== 'hunk') {
      if (rows[i].type === 'del') delRows.push(rows[i]);
      else if (rows[i].type === 'add') addRows.push(rows[i]);
      i += 1;
    }
    const blockLen = Math.max(delRows.length, addRows.length);
    for (let j = 0; j < blockLen; j++) {
      html += splitRowPair(delRows[j] || null, addRows[j] || null);
    }
  }

  html += '</table>';
  return html;
}

function _renderDiffRows(rows, issueRef, language, enableHighlight, filePath) {
  if (!_starryNightRuntime) _requestDiffHighlighterRefresh();
  if (_isModifiedFileDiff(filePath, rows)) return _renderSplitDiffTable(rows, issueRef, language, enableHighlight);
  return _renderUnifiedDiffTable(rows, issueRef, language, enableHighlight);
}

function renderDiff(diffContent, issue) {
  if (!diffContent) return '<div class="diff-loading">변경 내역 없음</div>';
  const lines = parseDiffLines(diffContent);
  if (!lines.length) return '<div class="diff-loading">변경 없음</div>';
  const filePath = issue?.file || state.selectedFileDiff || '';
  const language = _guessDiffLanguage(filePath);
  const enableHighlight = !!(language && lines.length <= 1200);
  return _renderDiffRows(lines, issue, language, enableHighlight, filePath);
}

function renderDiffWithFocus(diffContent, issue, contextLines=20, full=false) {
  const target = _issueLineRange(issue);
  if (full || target.start === null) return renderDiff(diffContent, issue);
  const lines = parseDiffLines(diffContent);
  if (!lines.length) return '<div class="diff-loading">변경 없음</div>';
  const filePath = issue?.file || state.selectedFileDiff || '';
  const language = _guessDiffLanguage(filePath);
  const enableHighlight = !!(language && lines.length <= 1200);
  const end = target.end ?? target.start;
  const focusedIndex = new Set();

  for (let idx = 0; idx < lines.length; idx++) {
    const l = lines[idx];
    if (l.type === 'hunk') continue;
    const newLine = Number.isInteger(l.new) ? l.new : null;
    if (newLine !== null && newLine >= (target.start - contextLines) && newLine <= (end + contextLines)) {
      focusedIndex.add(idx);
    }
  }

  for (let idx = 0; idx < lines.length; idx++) {
    const l = lines[idx];
    if (l.type !== 'del') continue;
    if (focusedIndex.has(idx - 1) || focusedIndex.has(idx + 1)) focusedIndex.add(idx);
  }

  if (!focusedIndex.size) return renderDiff(diffContent, issue);
  const focused = lines.filter((_, idx) => focusedIndex.has(idx) && lines[idx].type !== 'hunk');
  if (!focused.length) return renderDiff(diffContent, issue);

  const tableHtml = _renderDiffRows(focused, issue, language, enableHighlight, filePath);

  const targetLabel = _issueRangeLabel(issue);
  return `<div class="diff-focus-note">이슈 라인(${esc(targetLabel)}) 주변 ±${contextLines}줄만 표시 중입니다.</div>${tableHtml}`;
}

async function renderIssueDetail() {
  const renderSeq = ++_issueDetailRenderSeq;
  const el = document.getElementById('issue-detail');
  renderDetailViewBar();
  if (!state.selectedIssue) { el.innerHTML = renderIssueDetailEmpty(); return; }
  const issue = state.issues.find(i=>i.id===state.selectedIssue);
  if (!issue) return;

  const sev = issue.final_severity||issue.severity;
  const sevColor = SEVERITY_COLORS[sev]||'#6B7280';
  const rangeLabel = _issueRangeLabel(issue);
  const fileLine = rangeLabel ? `${issue.file}:${rangeLabel}` : `${issue.file} (라인 미지정)`;

  // Header
  let html = `<div class="detail-header-bar">
    <div class="detail-title">${esc(issue.title)}</div>
    <div class="detail-file">${esc(fileLine)}</div>
    <div class="detail-badges">
      <span class="severity-badge" style="background:${sevColor}20;color:${sevColor}">${sevLabel(sev)}</span>
      <span style="font-size:12px;color:var(--text-muted)">제기: <span style="color:${getModelColor(issue.raised_by||'')}">${esc(issue.raised_by)}</span></span>
    </div>
  </div>`;

  // Initial raise (not a comment): always render as standalone issue block.
  const initialRaise = _getInitialRaiseOpinion(issue);
  const raisedAt = initialRaise?.timestamp ? formatTs(initialRaise.timestamp) : '';
  html += `<div class="issue-origin-panel">
    <div class="issue-origin-head">
      <span class="issue-origin-title">최초 이슈 제기</span>
      <span class="model-dot" style="background:${getModelColor(issue.raised_by || '')}"></span>
      <span class="model-name" style="color:${getModelColor(issue.raised_by || '')}">${esc(issue.raised_by || 'unknown')}</span>
      <span class="action-badge action-raise">raise (제기)</span>
      ${raisedAt ? `<span class="issue-origin-meta">${esc(raisedAt)}</span>` : ''}
    </div>
    <div class="issue-origin-body">
      <div class="opinion-text">${issue.description ? renderMd(issue.description) : '<span style="color:var(--text-muted)">설명이 없습니다.</span>'}</div>
      ${issue.suggestion ? `<div class="issue-origin-suggestion"><div class="opinion-suggestion">${renderMd(issue.suggestion)}</div></div>` : ''}
    </div>
  </div>`;

  // Diff
  const isFullDiff = !!state.expandedDiffByIssue[issue.id];
  const issueStatsMeta = _renderDiffStatsMeta(issue.file);
  html += '<div class="diff-container">';
  html += `<div class="diff-file-header"><span class="filename">${esc(issue.file)}</span>${issueStatsMeta}<button class="btn" onclick="toggleIssueDiff('${issue.id}')">${isFullDiff ? '축약 보기' : '전체 diff 보기'}</button></div>`;

  const diffContent = await fetchDiff(issue.file);
  if (renderSeq !== _issueDetailRenderSeq) return;
  html += renderDiffWithFocus(diffContent, issue, 20, isFullDiff);
  html += '</div>';

  // Discussion thread (exclude initial raise opinion)
  const discussionThread = _getDiscussionOpinions(issue);
  if (discussionThread.length) {
    const mode = state.issueDetailModeByIssue[issue.id] || 'timeline';
    const isTimeline = mode === 'timeline';
    const timeline = [...discussionThread].sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0));
    html += `<div style="padding:10px 20px;border-bottom:1px solid var(--border);display:flex;gap:8px">
      <button class="btn ${isTimeline ? 'btn-primary' : ''}" onclick="setIssueDetailMode('${issue.id}','timeline')">타임라인</button>
      <button class="btn ${!isTimeline ? 'btn-primary' : ''}" onclick="setIssueDetailMode('${issue.id}','thread')">스레드</button>
    </div>`;
    if (isTimeline) {
      html += `<div class="thread-panel"><div class="thread-title">타임라인 (${timeline.length})</div>`;
      timeline.forEach((op, idx) => {
        const mColor = getModelColor(op.model_id);
        const actionClass = 'action-'+op.action;
        const rk = `tl-${issue.id}-${idx}`;
        html += `<div class="timeline-item" data-op-model="${_escapeAttr(op.model_id || '')}" data-op-time="${_escapeAttr(op.timestamp || '')}" data-op-action="${_escapeAttr(op.action || '')}">
          <div class="timeline-head">
            <span class="model-dot" style="background:${mColor}"></span>
            <span class="model-name" style="color:${mColor}">${esc(op.model_id)}</span>
            <span class="action-badge ${actionClass}">${actLabel(op.action)}</span>
            ${op.turn != null ? `<span class="severity-badge" style="background:#6B728020;color:#8B949E">턴 ${op.turn}</span>` : ''}
            <span class="timeline-time">${op.timestamp ? esc(formatTs(op.timestamp)) : ''}</span>
          </div>
          ${renderReasoning(op.reasoning, rk)}
        </div>`;
      });
      html += `</div>`;
    } else {
    html += `<div class="section-card">
      <div class="section-header" onclick="toggleSection('issue-thread-${issue.id}', 'issue-thread-toggle-${issue.id}')">
        <span class="section-toggle collapsed" id="issue-thread-toggle-${issue.id}">▾</span>
        <span>토론 (${discussionThread.length})</span>
      </div>
      <div class="section-body collapsed" id="issue-thread-${issue.id}">
      <div class="thread-panel">`;
    discussionThread.forEach((op, idx) => {
      const mColor = getModelColor(op.model_id);
      const actionClass = 'action-'+op.action;
      const rk = `th-${issue.id}-${idx}`;
      html += `<div class="opinion" ${op.id ? `id="op-${_escapeAttr(op.id)}"` : ''} data-op-model="${_escapeAttr(op.model_id || '')}" data-op-time="${_escapeAttr(op.timestamp || '')}" data-op-action="${_escapeAttr(op.action || '')}">
        <div class="opinion-header">
          <span class="model-dot" style="background:${mColor}"></span>
          <span class="model-name" style="color:${mColor}">${esc(op.model_id)}</span>
          <span class="action-badge ${actionClass}">${actLabel(op.action)}</span>
          ${op.suggested_severity?`<span class="severity-badge" style="background:${SEVERITY_COLORS[op.suggested_severity]||'#6B7280'}20;color:${SEVERITY_COLORS[op.suggested_severity]||'#6B7280'}">${sevLabel(op.suggested_severity)}</span>`:''}
          ${op.timestamp ? `<span class="opinion-time">${esc(formatTs(op.timestamp))}</span>` : ''}
        </div>
        ${renderReasoning(op.reasoning, rk)}
      </div>`;
    });
    html += '</div></div></div>';
    }
  }

  // Consensus
  if (issue.consensus===true && issue.consensus_type==='closed') {
    html += `<div style="padding:0 20px 16px"><div class="consensus-box consensus-reached">\uD83D\uDEAB False Positive (종결)</div></div>`;
  } else if (issue.consensus===true) {
    html += `<div style="padding:0 20px 16px"><div class="consensus-box consensus-reached">\u2705 합의 완료 \u2192 ${sevLabel(sev)}</div></div>`;
  } else if (discussionThread.length > 0) {
    html += `<div style="padding:0 20px 16px"><div class="consensus-box consensus-pending">\u23F3 합의 대기 중</div></div>`;
  }

  // Comment form
  html += `<div class="comment-form">
      <textarea id="comment-text" placeholder="이 이슈에 대한 의견을 작성하세요..."></textarea>
      <div class="field-hint">Markdown 지원: **굵게**, *기울임*, ~~취소선~~, \`코드\`, @이슈ID(클릭 이동)</div>
      <div class="comment-actions">
        <button class="btn btn-agree" onclick="submitOpinion('${issue.id}','fix_required')">수정필요</button>
        <button class="btn btn-disagree" onclick="submitOpinion('${issue.id}','no_fix')">수정불필요</button>
        <button class="btn" style="border-color:#A855F7;color:#A855F7" onclick="submitOpinion('${issue.id}','false_positive')">오탐</button>
        <button class="btn btn-comment" onclick="submitOpinion('${issue.id}','comment')">의견</button>
        <div class="spacer"></div>
        <select id="comment-severity" style="background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:4px 8px;font-size:12px;">
          <option value="">-- 심각도 --</option>
          <option value="critical">심각</option>
          <option value="high">높음</option>
          <option value="medium">보통</option>
          <option value="low">낮음</option>
          <option value="dismissed">기각</option>
        </select>
      </div>
      <div class="mention-row">
        ${state.agents.map(a => `<button class="mention-chip" onclick="insertMention('@${esc(a.model_id)} ')">@${esc(a.model_id)}</button>`).join('')}
      </div>
    </div>`;

  // Assist (issue resolution helper)
  const hasHistory = issue.assist_messages && issue.assist_messages.length > 0;
  const openClass = hasHistory ? ' open' : '';
  html += `<div class="assist-section">
    <div class="assist-toggle" onclick="toggleAssist('${issue.id}')">
      <span style="font-size:16px">&#129302;</span>
      <span class="label">해결 도우미</span>
      <span class="hint">${hasHistory ? issue.assist_messages.length + '개 메시지' : 'AI에게 이슈 해결을 요청하세요'}</span>
    </div>
    <div class="assist-chat${openClass}" id="assist-chat-${issue.id}">
      <div class="assist-messages" id="assist-messages-${issue.id}">
        ${hasHistory ? renderAssistMessages(issue.assist_messages) : '<div style="padding:8px;color:var(--text-muted);font-size:13px;text-align:center">아래에서 질문하거나 "이 이슈를 설명해줘"를 눌러보세요</div>'}
      </div>
      <div class="assist-cli">
        <div class="assist-cli-box" onclick="copyCliCommand('${issue.id}')" title="클릭하면 복사됩니다">
          <span style="color:var(--accent)">$</span>
          <span class="cmd" id="assist-cli-${issue.id}">claude -p "${esc(issue.file)} 파일의 이슈를 해결해주세요: ${esc(issue.title)}"</span>
          <span class="copy-hint">복사</span>
        </div>
      </div>
      <div class="assist-input-bar">
        <button class="btn btn-primary" style="font-size:12px;padding:8px 12px" onclick="sendAssist('${issue.id}','이 이슈에 대해 설명해주고, 어떻게 해결하면 좋을지 제안해줘')">설명 요청</button>
        <button class="btn" style="font-size:12px;padding:8px 12px" onclick="issueHumanAssistKey()">도우미 키 발급</button>
        <button class="btn" style="font-size:12px;padding:8px 12px" onclick="submitAssistOpinion('${issue.id}')">AI 의견 제출</button>
        <textarea class="assist-input" id="assist-input-${issue.id}" placeholder="질문을 입력하세요..." rows="1" onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendAssistFromInput('${issue.id}')}"></textarea>
        <button class="btn-assist-send" id="assist-send-${issue.id}" onclick="sendAssistFromInput('${issue.id}')">전송</button>
      </div>
    </div>
  </div>`;

  if (renderSeq !== _issueDetailRenderSeq) return;
  if (_shouldDeferIssueRender()) {
    _issueRenderPending = true;
    return;
  }
  el.innerHTML = html;
  _applyPendingOpinionJump(issue.id);
}

async function fetchDiff(filePath) {
  if (state.diffCache[filePath]) return state.diffCache[filePath];
  if (!state.sessionId) return '';
  try {
    const r = await fetch(`/api/sessions/${state.sessionId}/diff/${filePath}`);
    if (!r.ok) return '';
    const d = await r.json();
    state.diffCache[filePath] = d.content;
    return d.content;
  } catch(e) { return ''; }
}

function updateStepIndicator() {
  const el = document.getElementById('step-indicator');
  const statusIdxMap = { collecting:0, reviewing:2, dedup:3, deliberating:4, complete:5 };
  let idx = statusIdxMap[state.status] ?? -1;
  if (state.status === 'reviewing' && !state.agents.length) idx = 1;
  let detail = '';
  if (state.status === 'reviewing' && !state.agents.length) {
    detail = '프리셋이 없는 세션';
  }
  if (state.status === 'reviewing' && state.agents.length) {
    const done = state.agents.filter(a => a.status === 'submitted').length;
    detail = `${done}/${state.agents.length} 에이전트 완료`;
  }
  el.innerHTML = STEPS.map((step, i) => {
    let cls, dotContent;
    if (idx < 0) { cls = 'pending'; dotContent = ''; }
    else if (i < idx) { cls = 'done'; dotContent = '✓'; }
    else if (i === idx) { cls = 'active'; dotContent = ''; }
    else { cls = 'pending'; dotContent = ''; }
    const dot = `<span class="step-dot ${cls}">${dotContent}</span>`;
    const label = `<span class="step-label ${cls}">${step.label}</span>`;
    const det = (cls === 'active' && detail) ? `<span class="step-detail">${detail}</span>` : '';
    const stepHtml = `<div class="step-item">${dot}${label}${det}</div>`;
    const conn = i < STEPS.length - 1 ? `<div class="step-connector ${i < idx ? 'done' : ''}"></div>` : '';
    return stepHtml + conn;
  }).join('');
}

function updateSummary() {
  const el = document.getElementById('summary-bar');
  const t = state.issues.length;
  const c = state.issues.filter(i=>i.consensus===true).length;
  const d = state.issues.filter(i=>(i.final_severity||i.severity)==='dismissed').length;
  const stats = _getActivityStats();
  if (!t && !stats) { el.textContent='준비 완료'; return; }
  const issuePart = t ? `이슈 ${t}개 \u00B7 합의 ${c}개 \u00B7 기각 ${d}개` : '준비 완료';
  el.innerHTML = stats ? `${esc(issuePart)} ${stats}` : esc(issuePart);
}

function selectIssue(id) {
  state.detailViewMode = 'issue';
  state.selectedIssue = id;
  state.selectedFileDiff = null;
  _fileTreeAutoExpandedPath = '';
  if (state.sessionId && id) _uiSelectedIssueBySession[state.sessionId] = id;
  _uiSaveStateToStorage();
  router.push({ viewMode: 'issue', issueId: id });
  renderFilePanel();
  renderIssueList();
  renderIssueDetail();
}

function insertMention(mention) {
  const el = document.getElementById('comment-text');
  if (!el) return;
  const start = el.selectionStart || el.value.length;
  const end = el.selectionEnd || el.value.length;
  const before = el.value.slice(0, start);
  const after = el.value.slice(end);
  el.value = before + mention + after;
  const pos = start + mention.length;
  el.focus();
  el.setSelectionRange(pos, pos);
}

function getUniqueAgentId(baseId) {
  const existing = _amPresetCache.map(a => a.id);
  if (!existing.includes(baseId)) return baseId;
  for (let i = 2; ; i++) {
    const candidate = `${baseId}-${i}`;
    if (!existing.includes(candidate)) return candidate;
  }
}

// --- Agent Manager: Constants ---
const ROLE_PRESETS = [
  { key:'engineering', label:'엔지니어링', icon:'🔧', role:'Engineering Reviewer',
    review_focus:['code quality','error handling','performance','maintainability'],
    system_prompt:'You are a senior software engineer focused on code quality, error handling, performance, and maintainability.' },
  { key:'security', label:'시큐리티', icon:'🛡️', role:'Security Reviewer',
    review_focus:['injection','authentication','authorization','data exposure','cryptography'],
    system_prompt:'You are a security specialist focused on OWASP Top 10, injection flaws, auth issues, and data exposure.' },
  { key:'architecture', label:'아키텍처', icon:'🏗️', role:'Architecture Reviewer',
    review_focus:['design patterns','coupling','cohesion','scalability','API design'],
    system_prompt:'You are a software architect focused on design patterns, coupling, cohesion, scalability, and API design.' },
  { key:'testing', label:'테스팅', icon:'🧪', role:'Test Quality Reviewer',
    review_focus:['test coverage','edge cases','test design','assertions','mocking'],
    system_prompt:'You are a test quality specialist focused on coverage, edge cases, test design, assertions, and mocking strategy.' },
];

const STRICTNESS_OPTIONS = [
  { value:'strict',   label:'엄격', desc:'사소한 것도 빠짐없이 지적' },
  { value:'balanced', label:'균형', desc:'실질적 영향 있는 이슈 위주' },
  { value:'lenient',  label:'관대', desc:'심각한 버그/보안만 지적' },
];

let _amAvailableModels = {};
let _amSelectedAgentId = null;
let _amMode = 'list'; // 'list' | 'edit' | 'add'
let _amOverlay = null;
let _amPresetCache = [];
let _amDirty = false;

const AGENT_FIELD_HELP = {
  role: '리뷰 시 에이전트가 맡는 역할 이름입니다.',
  description: '에이전트 카드에 표시되는 한 줄 설명입니다.',
  strictness: '엄격도는 지적 범위를 조절합니다. 엄격할수록 사소한 항목도 더 많이 검토합니다.',
  client_type: '실행할 에이전트 클라이언트 종류입니다.',
  model_id: '프리셋은 일부 예시입니다. 비우면 각 CLI/서버 기본 모델을 사용하며, 원하는 모델 ID를 직접 입력할 수 있습니다.',
  provider: 'OpenCode에서 사용할 모델 provider ID입니다.',
  system_prompt: '리뷰 스타일/제약을 강하게 주고 싶을 때 입력하세요.',
  temperature: '0에 가까울수록 일관적이고, 높을수록 다양하게 응답합니다. 비우면 클라이언트 기본값을 사용합니다.',
  review_focus: '쉼표로 나눠 핵심 점검 항목을 지정합니다.',
  test_endpoint: '테스트 시 콜백 URL/세션 ID를 자동 생성해 LLM에게 전달합니다.',
};

const MODEL_DEFAULT_HINTS = {
  'claude-code': '기본값(빈 값): Claude CLI 기본 모델 사용',
  'codex': '기본값(빈 값): Codex CLI 기본 모델 사용',
  'gemini': '기본값(빈 값): Gemini CLI 기본 모델 사용',
  'opencode': '기본값(빈 값): OpenCode 서버 기본 모델 사용',
};

function showToast(message, kind = 'success', durationMs = null) {
  if (!message) return;
  const resolvedDuration = Number.isFinite(durationMs) && durationMs > 0
    ? Number(durationMs)
    : (kind === 'error' ? 5200 : 3800);
  let stack = document.getElementById('toast-stack');
  if (!stack) {
    stack = document.createElement('div');
    stack.id = 'toast-stack';
    stack.className = 'toast-stack';
    document.body.appendChild(stack);
  }
  const toastKey = `${kind || 'success'}::${String(message).trim()}`;
  let toast = Array.from(stack.children).find((el) => el?.dataset?.toastKey === toastKey);
  if (!toast) {
    if (stack.children.length >= 3) stack.firstElementChild?.remove();
    toast = document.createElement('div');
    toast.className = `toast ${kind || 'success'}`;
    toast.dataset.toastKey = toastKey;
    toast.innerHTML = `<span class="toast-icon">${kind === 'error' ? '⚠' : '✓'}</span><span class="toast-msg"></span>`;
    stack.appendChild(toast);
  } else {
    toast.className = `toast ${kind || 'success'}`;
  }
  const msgEl = toast.querySelector('.toast-msg');
  if (msgEl) msgEl.textContent = String(message);
  if (toast._hideTimer) clearTimeout(toast._hideTimer);
  if (toast._removeTimer) clearTimeout(toast._removeTimer);
  requestAnimationFrame(() => toast.classList.add('show'));
  toast._hideTimer = setTimeout(() => {
    toast.classList.remove('show');
    toast._removeTimer = setTimeout(() => toast.remove(), 180);
  }, resolvedDuration);
}

function _amSetDirty(dirty) {
  _amDirty = !!dirty;
  const badge = document.getElementById('am-dirty-indicator');
  if (!badge) return;
  badge.style.display = _amDirty ? '' : 'none';
}

function _amBindDirtyTracking() {
  const right = _amOverlay?.querySelector('#am-right');
  if (!right) return;
  right.querySelectorAll('input, textarea, select').forEach((el) => {
    el.addEventListener('input', () => _amSetDirty(true));
    el.addEventListener('change', () => _amSetDirty(true));
  });
  _amSetDirty(false);
}

function _amConfirmDiscardChanges(actionText) {
  if (!_amDirty) return true;
  const action = actionText || '이동';
  return confirm(`저장되지 않은 변경 사항이 있습니다. 저장하지 않고 ${action}하시겠습니까?`);
}

function _amRequestClose() {
  if (!_amConfirmDiscardChanges('창을 닫기')) return;
  _amOverlay?.remove();
  _amOverlay = null;
  _amSelectedAgentId = null;
  _amMode = 'list';
  _amSetDirty(false);
}

function _amLabel(text, helpText) {
  const help = (helpText || '').trim();
  const titleAttr = help ? ` title="${esc(help)}"` : '';
  return `<label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:flex;align-items:center;gap:6px"${titleAttr}><span>${esc(text)}</span>${help ? `<span class="help-dot" title="${esc(help)}">?</span>` : ''}</label>`;
}

function _amModelHintByClientType(clientType) {
  return MODEL_DEFAULT_HINTS[clientType] || '기본값(빈 값): 클라이언트 기본 모델 사용';
}

function _amRefreshModelHint(mode) {
  const prefix = mode === 'new' ? 'am-new' : 'am';
  const ct = document.getElementById(`${prefix}-client-type`)?.value || 'claude-code';
  const hintEl = document.getElementById(`${prefix}-model-default-hint`);
  if (hintEl) hintEl.textContent = _amModelHintByClientType(ct);
}

async function _amFetchAvailableModels() {
  try {
    const r = await fetch('/api/available-models');
    if (r.ok) _amAvailableModels = await r.json();
  } catch (e) { console.warn('available-models fetch failed', e); }
}

function _amRefreshConnectionHint(mode) {
  const prefix = mode === 'new' ? 'am-new' : 'am';
  const targetEl = document.getElementById(`${prefix}-test-target`);
  if (!targetEl) return;
  targetEl.textContent = '실행 시 콜백 URL/세션 ID를 자동 생성해 에이전트에게 전달합니다.';
}

async function openAgentManager(editModelId) {
  await _amFetchAvailableModels();

  let presets = [];
  try {
    const r = await fetch('/api/agent-presets');
    if (r.ok) presets = await r.json();
  } catch (e) {}

  _amOverlay = document.createElement('div');
  _amOverlay.className = 'report-overlay';
  _amOverlay.innerHTML = `<div class="report-card" style="max-width:900px;height:80vh;display:flex;flex-direction:column;overflow:hidden">
    <div class="report-header"><h2>에이전트 프리셋 관리</h2><button class="report-close" onclick="_amRequestClose()">✕</button></div>
    <div style="display:flex;flex:1;overflow:hidden">
      <div id="am-left" style="width:240px;min-width:200px;border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden">
        <div id="am-agent-list" style="flex:1;overflow-y:auto;padding:8px 0"></div>
        <div style="padding:8px 12px;border-top:1px solid var(--border)">
          <button class="btn btn-primary" onclick="_amShowAddPanel()" style="width:100%;font-size:12px">+ 프리셋 추가</button>
        </div>
      </div>
      <div id="am-right" style="flex:1;overflow-y:auto;padding:20px">
        <div style="color:var(--text-muted);font-size:13px;text-align:center;margin-top:40px">좌측에서 프리셋을 선택하거나 추가하세요</div>
      </div>
    </div>
  </div>`;
  document.body.appendChild(_amOverlay);
  _amOverlay.addEventListener('click', (e) => { if (e.target === _amOverlay) _amRequestClose(); });
  _amSetDirty(false);

  _amRenderList(presets);

  if (editModelId) {
    _amSelectedAgentId = editModelId;
    _amMode = 'edit';
    _amRenderEditForm(presets.find(a => a.id === editModelId), presets);
  }
}

function _amRenderList(agents) {
  _amPresetCache = agents || [];
  const listEl = _amOverlay?.querySelector('#am-agent-list');
  if (!listEl) return;
  if (!agents.length) {
    listEl.innerHTML = '<div style="padding:20px;text-align:center;color:var(--text-muted);font-size:12px">프리셋이 없습니다</div>';
    return;
  }
  listEl.innerHTML = agents.map(a => {
    const color = a.color || '#8B949E';
    const sel = _amSelectedAgentId === a.id;
    return `<div onclick="_amSelectAgent('${esc(a.id)}')" style="padding:8px 12px;cursor:pointer;display:flex;align-items:center;gap:8px;font-size:12px;${sel ? 'background:rgba(88,166,255,0.1);border-left:3px solid var(--accent)' : 'border-left:3px solid transparent'};transition:background 0.15s" onmouseover="this.style.background='rgba(88,166,255,0.06)'" onmouseout="this.style.background='${sel ? 'rgba(88,166,255,0.1)' : 'transparent'}'">
      <span style="width:10px;height:10px;border-radius:50%;background:${color};flex-shrink:0;opacity:${a.enabled !== false ? '1' : '0.3'}"></span>
      <div style="flex:1;min-width:0">
        <div style="font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;${a.enabled === false ? 'opacity:0.4' : ''}">${esc(a.id)}</div>
        <div style="color:var(--text-muted);font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(a.role || a.client_type || '')}</div>
      </div>
      <button onclick="event.stopPropagation();_amDeleteAgent('${esc(a.id)}')" title="삭제" style="background:none;border:none;color:var(--severity-critical);cursor:pointer;font-size:14px;padding:2px 4px;opacity:0.5;flex-shrink:0" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.5'">✕</button>
    </div>`;
  }).join('');
}

async function _amSelectAgent(modelId) {
  if (_amSelectedAgentId !== modelId && !_amConfirmDiscardChanges('다른 프리셋으로 이동')) return;
  _amSelectedAgentId = modelId;
  _amMode = 'edit';
  let agents = [];
  try {
    const r = await fetch('/api/agent-presets');
    if (r.ok) agents = await r.json();
  } catch (e) {}
  _amRenderList(agents);
  const mc = agents.find(a => a.id === modelId);
  if (mc) _amRenderEditForm(mc, agents);
}

function _amRenderEditForm(mc, agents) {
  const right = _amOverlay?.querySelector('#am-right');
  if (!right || !mc) return;
  const inputStyle = 'background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;font-family:inherit;width:100%';
  const focus = (mc.review_focus || []).join(', ');
  const strictness = mc.strictness || 'balanced';
  const clientType = mc.client_type || 'claude-code';
  const models = _amAvailableModels[clientType] || [];

  right.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:14px">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
        <span style="width:14px;height:14px;border-radius:50%;background:${mc.color || '#8B949E'}"></span>
        <span style="font-size:16px;font-weight:600">${esc(mc.id)}</span>
        <span style="font-size:12px;color:var(--text-muted)">${esc(mc.client_type || '')}</span>
        <span id="am-dirty-indicator" class="am-dirty-indicator" style="display:none;margin-left:auto">저장 안 됨</span>
      </div>

      <div>
        ${_amLabel('역할 프리셋', '빠르게 역할/포커스/프롬프트를 채웁니다.')}
        <div style="display:flex;gap:6px;flex-wrap:wrap">
          ${ROLE_PRESETS.map(rp => `<button class="btn" onclick="_amApplyRolePreset('${rp.key}')" style="font-size:11px;padding:4px 10px">${rp.icon} ${rp.label}</button>`).join('')}
        </div>
      </div>

      <div>
        ${_amLabel('역할', AGENT_FIELD_HELP.role)}
        <input id="am-role" value="${esc(mc.role || '')}" style="${inputStyle}" placeholder="예: Security Reviewer">
      </div>

      <div>
        ${_amLabel('설명', AGENT_FIELD_HELP.description)}
        <input id="am-description" value="${esc(mc.description || '')}" style="${inputStyle}" placeholder="에이전트 설명">
      </div>

      <div>
        ${_amLabel('엄격도', AGENT_FIELD_HELP.strictness)}
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
          ${STRICTNESS_OPTIONS.map(so => `<label title="${esc(so.desc)}" onclick="const el=document.getElementById('am-strictness-${so.value}'); if(el){ el.checked=true; el.dispatchEvent(new Event('change', { bubbles:true })); }" style="display:flex;flex-direction:column;gap:4px;padding:10px;border:1px solid ${strictness === so.value ? 'var(--accent)' : 'var(--border)'};border-radius:8px;cursor:pointer;background:${strictness === so.value ? 'rgba(88,166,255,0.08)' : 'var(--bg)'};transition:all 0.15s">
            <div style="display:flex;align-items:center;gap:6px">
              <input type="radio" name="am-strictness" id="am-strictness-${so.value}" value="${so.value}" ${strictness === so.value ? 'checked' : ''} onchange="_amUpdateStrictnessUI()" style="accent-color:var(--accent)">
              <span style="font-size:13px;font-weight:600">${so.label}</span>
            </div>
            <span style="font-size:11px;color:var(--text-muted)">${so.desc}</span>
          </label>`).join('')}
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <div style="flex:1">
          ${_amLabel('클라이언트 타입', AGENT_FIELD_HELP.client_type)}
          <select id="am-client-type" style="${inputStyle}" onchange="_amOnClientTypeChange()">
            ${['claude-code','codex','opencode','gemini'].map(t => `<option value="${t}" ${clientType === t ? 'selected' : ''}>${t}</option>`).join('')}
          </select>
        </div>
        <div style="flex:1">
          ${_amLabel('세부 모델', AGENT_FIELD_HELP.model_id)}
          <select id="am-model-id-select" style="${inputStyle}" onchange="document.getElementById('am-model-id').value=this.value">
            <option value="">기본값 (클라이언트 설정)</option>
            ${models.map(m => `<option value="${m.model_id}" ${mc.model_id === m.model_id ? 'selected' : ''}>${m.label}</option>`).join('')}
          </select>
          <input id="am-model-id" value="${esc(mc.model_id || '')}" placeholder="또는 직접 입력" style="${inputStyle};margin-top:4px;font-size:11px">
          <div id="am-model-default-hint" class="field-hint"></div>
          <div class="field-hint">프리셋은 일부만 노출됩니다. 필요한 모델은 직접 입력하세요.</div>
        </div>
      </div>

      <div id="am-provider-row" style="${clientType === 'opencode' ? '' : 'display:none'}">
        ${_amLabel('Provider', AGENT_FIELD_HELP.provider)}
        <input id="am-provider" value="${esc(mc.provider || '')}" style="${inputStyle}" placeholder="예: openai">
      </div>

      <div>
        ${_amLabel('색상', '에이전트 카드/표시에 사용됩니다.')}
        <div style="display:flex;gap:8px;align-items:center">
          <input id="am-color" type="color" value="${mc.color || '#8B949E'}" style="width:40px;height:32px;border:1px solid var(--border);border-radius:6px;background:none;cursor:pointer" oninput="document.getElementById('am-color-text').value=this.value">
          <input id="am-color-text" value="${esc(mc.color || '')}" placeholder="#8B5CF6" style="flex:1;${inputStyle}" oninput="if(/^#[0-9a-fA-F]{6}$/.test(this.value))document.getElementById('am-color').value=this.value">
        </div>
      </div>

      <div>
        ${_amLabel('시스템 프롬프트', AGENT_FIELD_HELP.system_prompt)}
        <textarea id="am-system-prompt" rows="3" style="${inputStyle};resize:vertical">${esc(mc.system_prompt || '')}</textarea>
      </div>

      <div style="display:flex;gap:8px">
        <div style="flex:1">
          ${_amLabel('Temperature', AGENT_FIELD_HELP.temperature)}
          <input id="am-temperature" type="number" step="0.1" min="0" max="2" value="${mc.temperature != null ? mc.temperature : ''}" placeholder="기본값" style="${inputStyle}">
          <div class="field-hint">낮을수록 일관되고, 높을수록 다양한 답변이 나옵니다.</div>
        </div>
        <div style="flex:2">
          ${_amLabel('리뷰 포커스 (쉼표 구분)', AGENT_FIELD_HELP.review_focus)}
          <input id="am-review-focus" value="${esc(focus)}" placeholder="security, performance, ..." style="${inputStyle}">
        </div>
      </div>

      <div>
        ${_amLabel('연결 테스트 Endpoint (자동)', AGENT_FIELD_HELP.test_endpoint)}
        <div id="am-test-target" class="field-hint"></div>
        <div style="margin-top:6px">
          <button class="btn" type="button" onclick="_amTestConnection('edit', this)">연결 테스트</button>
        </div>
        <div id="am-test-result" class="conn-test-result"></div>
      </div>

      <label style="display:flex;align-items:center;gap:8px;font-size:13px;cursor:pointer;padding:4px 0">
        <input type="checkbox" id="am-enabled" ${mc.enabled !== false ? 'checked' : ''} style="accent-color:var(--accent)">
        활성화
      </label>

      <div class="am-action-footer">
        <button class="btn btn-primary" onclick="_amSaveAgent('${esc(mc.id)}')" style="padding:8px 24px">저장</button>
      </div>
    </div>`;
  _amUpdateStrictnessUI();
  _amRefreshModelHint('edit');
  _amRefreshConnectionHint('edit');
  _amBindDirtyTracking();
}

function _amApplyRolePreset(key) {
  const rp = ROLE_PRESETS.find(r => r.key === key);
  if (!rp) return;
  const roleEl = document.getElementById('am-role');
  const focusEl = document.getElementById('am-review-focus');
  const promptEl = document.getElementById('am-system-prompt');
  if (roleEl) roleEl.value = rp.role;
  if (focusEl) focusEl.value = rp.review_focus.join(', ');
  if (promptEl) promptEl.value = rp.system_prompt;
  _amSetDirty(true);
}

function _amUpdateStrictnessUI() {
  const checked = document.querySelector('input[name="am-strictness"]:checked');
  if (!checked) return;
  STRICTNESS_OPTIONS.forEach(so => {
    const label = document.getElementById('am-strictness-' + so.value)?.closest('label');
    if (!label) return;
    const sel = so.value === checked.value;
    label.style.borderColor = sel ? 'var(--accent)' : 'var(--border)';
    label.style.background = sel ? 'rgba(88,166,255,0.08)' : 'var(--bg)';
  });
}

function _amOnClientTypeChange() {
  const ct = document.getElementById('am-client-type')?.value || 'claude-code';
  const providerRow = document.getElementById('am-provider-row');
  if (providerRow) providerRow.style.display = ct === 'opencode' ? '' : 'none';
  // Update model dropdown
  const modelSelect = document.getElementById('am-model-id-select');
  if (modelSelect) {
    const models = _amAvailableModels[ct] || [];
    modelSelect.innerHTML = '<option value="">기본값 (클라이언트 설정)</option>' + models.map(m => `<option value="${m.model_id}">${m.label}</option>`).join('');
  }
  _amRefreshModelHint('edit');
  _amRefreshConnectionHint('edit');
}

async function _amSaveAgent(modelId) {
  const tempVal = (document.getElementById('am-temperature')?.value || '').trim();
  const focusVal = (document.getElementById('am-review-focus')?.value || '').trim();
  const strictnessEl = document.querySelector('input[name="am-strictness"]:checked');
  const payload = {
    role: (document.getElementById('am-role')?.value || '').trim(),
    description: (document.getElementById('am-description')?.value || '').trim(),
    strictness: strictnessEl?.value || 'balanced',
    color: (document.getElementById('am-color-text')?.value || '').trim(),
    client_type: document.getElementById('am-client-type')?.value || 'claude-code',
    provider: (document.getElementById('am-provider')?.value || '').trim(),
    model_id: (document.getElementById('am-model-id')?.value || '').trim(),
    system_prompt: document.getElementById('am-system-prompt')?.value || '',
    temperature: tempVal ? parseFloat(tempVal) : null,
    review_focus: focusVal ? focusVal.split(',').map(s => s.trim()).filter(Boolean) : [],
    enabled: document.getElementById('am-enabled')?.checked ?? true,
  };
  try {
    const r = await fetch(`/api/agent-presets/${modelId}`, {
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload),
    });
    if (!r.ok) { const e = await r.json(); showToast(e.detail || '저장 실패', 'error'); alert(e.detail || '저장 실패'); return; }
    _amSetDirty(false);
    showToast('프리셋이 저장되었습니다.', 'success');
    window.dispatchEvent(new CustomEvent('agent-presets-updated'));
    // Re-fetch and re-render
    let agents = [];
    try { const r2 = await fetch('/api/agent-presets'); if (r2.ok) agents = await r2.json(); } catch (e) {}
    _amRenderList(agents);
    const mc = agents.find(a => a.id === modelId);
    if (mc) _amRenderEditForm(mc, agents);
  } catch (e) { showToast('저장 실패', 'error'); alert('저장 실패'); }
}

async function _amDeleteAgent(modelId) {
  if (!confirm(`${modelId} 프리셋을 삭제하시겠습니까?`)) return;
  try {
    const r = await fetch(`/api/agent-presets/${modelId}`, { method: 'DELETE' });
    if (!r.ok) { const e = await r.json(); alert(e.detail || '삭제 실패'); return; }
    window.dispatchEvent(new CustomEvent('agent-presets-updated'));
    // Re-fetch and re-render
    let agents = [];
    try { const r2 = await fetch('/api/agent-presets'); if (r2.ok) agents = await r2.json(); } catch (e) {}
    _amSelectedAgentId = null;
    _amRenderList(agents);
    const right = _amOverlay?.querySelector('#am-right');
    if (right) right.innerHTML = '<div style="color:var(--text-muted);font-size:13px;text-align:center;margin-top:40px">좌측에서 프리셋을 선택하거나 추가하세요</div>';
    _amSetDirty(false);
    showToast('프리셋이 삭제되었습니다.', 'success');
  } catch (e) { alert('삭제 실패'); }
}

function _amShowAddPanel(force = false) {
  if (!force && !_amConfirmDiscardChanges('프리셋 추가 화면으로 이동')) return;
  _amSelectedAgentId = null;
  _amMode = 'add';
  // Update left list selection
  try {
    const listEl = _amOverlay?.querySelector('#am-agent-list');
    // Just de-select visually
    if (listEl) {
      listEl.querySelectorAll('[onclick^="_amSelectAgent"]').forEach(el => {
        el.style.background = 'transparent';
        el.style.borderLeft = '3px solid transparent';
      });
    }
  } catch (e) {}

  const right = _amOverlay?.querySelector('#am-right');
  if (!right) return;
  const inputStyle = 'background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;font-family:inherit;width:100%';

  right.innerHTML = `
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:16px">
      <h3 style="font-size:14px;font-weight:600">프리셋 추가</h3>
      <span id="am-dirty-indicator" class="am-dirty-indicator" style="display:none">저장 안 됨</span>
    </div>
    <div style="margin-bottom:16px">
      <label style="font-size:11px;color:var(--text-muted);margin-bottom:6px;display:block">클라이언트 프리셋</label>
      <div class="preset-grid" style="grid-template-columns:repeat(3,1fr);gap:8px">
        ${AGENT_PRESETS.map((p, i) => `<div class="preset-card" onclick="_amSelectAddPreset(${i})" style="padding:12px 8px"><span class="preset-icon" style="font-size:20px">${p.icon}</span><span class="preset-label" style="font-size:12px">${p.label}</span></div>`).join('')}
        <div class="preset-card preset-card-custom" onclick="_amSelectAddPreset(-1)" style="padding:12px 8px"><span class="preset-icon" style="font-size:20px">⚙️</span><span class="preset-label" style="font-size:12px">커스텀</span></div>
      </div>
    </div>
    <div id="am-add-form" style="display:none"></div>`;
  _amSetDirty(false);
}

function _amSelectAddPreset(presetIdx) {
  const isCustom = presetIdx === -1;
  const preset = isCustom ? null : AGENT_PRESETS[presetIdx];
  const inputStyle = 'background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;font-family:inherit;width:100%';
  const defaultId = preset ? getUniqueAgentId(preset.id) : '';
  const defaultColor = preset ? preset.color : '#8B5CF6';
  const defaultClientType = preset ? preset.client_type : 'claude-code';
  const showProvider = isCustom || (preset && preset.needsProvider);
  const models = _amAvailableModels[defaultClientType] || [];

  const form = _amOverlay?.querySelector('#am-add-form');
  if (!form) return;
  form.style.display = 'block';
  form.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:12px">
      <div>
        ${_amLabel('에이전트 ID', '중복되지 않는 고유 ID입니다. 예: codex, gemini-sec')}
        <input id="am-new-id" value="${esc(defaultId)}" placeholder="id (예: codex2)" style="${inputStyle}">
      </div>

      <div>
        ${_amLabel('역할 프리셋', '빠르게 역할/포커스/프롬프트를 채웁니다.')}
        <div style="display:flex;gap:6px;flex-wrap:wrap">
          ${ROLE_PRESETS.map(rp => `<button class="btn" onclick="_amApplyNewRolePreset('${rp.key}')" style="font-size:11px;padding:4px 10px">${rp.icon} ${rp.label}</button>`).join('')}
        </div>
      </div>

      <div>
        ${_amLabel('역할', AGENT_FIELD_HELP.role)}
        <input id="am-new-role" placeholder="예: Security Reviewer" style="${inputStyle}">
      </div>

      <div>
        ${_amLabel('설명', AGENT_FIELD_HELP.description)}
        <input id="am-new-description" placeholder="에이전트 설명" style="${inputStyle}">
      </div>

      <div>
        ${_amLabel('엄격도', AGENT_FIELD_HELP.strictness)}
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
          ${STRICTNESS_OPTIONS.map(so => `<label title="${esc(so.desc)}" onclick="const el=document.getElementById('am-new-strictness-${so.value}'); if(el){ el.checked=true; el.dispatchEvent(new Event('change', { bubbles:true })); }" style="display:flex;flex-direction:column;gap:4px;padding:10px;border:1px solid ${so.value === 'balanced' ? 'var(--accent)' : 'var(--border)'};border-radius:8px;cursor:pointer;background:${so.value === 'balanced' ? 'rgba(88,166,255,0.08)' : 'var(--bg)'};transition:all 0.15s">
            <div style="display:flex;align-items:center;gap:6px">
              <input type="radio" name="am-new-strictness" id="am-new-strictness-${so.value}" value="${so.value}" ${so.value === 'balanced' ? 'checked' : ''} onchange="_amUpdateNewStrictnessUI()" style="accent-color:var(--accent)">
              <span style="font-size:13px;font-weight:600">${so.label}</span>
            </div>
            <span style="font-size:11px;color:var(--text-muted)">${so.desc}</span>
          </label>`).join('')}
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <div style="flex:1">
          ${_amLabel('클라이언트 타입', AGENT_FIELD_HELP.client_type)}
          <select id="am-new-client-type" style="${inputStyle}" ${!isCustom ? 'disabled' : ''} onchange="_amOnNewClientTypeChange()">
            ${['claude-code','codex','opencode','gemini'].map(t => `<option value="${t}" ${defaultClientType === t ? 'selected' : ''}>${t}</option>`).join('')}
          </select>
        </div>
        <div style="flex:1">
          ${_amLabel('세부 모델', AGENT_FIELD_HELP.model_id)}
          <select id="am-new-model-id-select" style="${inputStyle}" onchange="document.getElementById('am-new-model-id').value=this.value">
            <option value="">기본값 (클라이언트 설정)</option>
            ${models.map(m => `<option value="${m.model_id}">${m.label}</option>`).join('')}
          </select>
          <input id="am-new-model-id" value="" placeholder="또는 직접 입력" style="${inputStyle};margin-top:4px;font-size:11px">
          <div id="am-new-model-default-hint" class="field-hint"></div>
          <div class="field-hint">프리셋은 일부만 노출됩니다. 필요한 모델은 직접 입력하세요.</div>
        </div>
      </div>

      <div id="am-new-provider-row" style="${showProvider ? '' : 'display:none'}">
        ${_amLabel('Provider', AGENT_FIELD_HELP.provider)}
        <input id="am-new-provider" placeholder="provider (예: openai)" style="${inputStyle}">
      </div>

      <div>
        ${_amLabel('색상', '에이전트 카드/표시에 사용됩니다.')}
        <div style="display:flex;gap:8px;align-items:center">
          <input id="am-new-color" type="color" value="${defaultColor}" style="width:40px;height:32px;border:1px solid var(--border);border-radius:6px;background:none;cursor:pointer" oninput="document.getElementById('am-new-color-text').value=this.value">
          <input id="am-new-color-text" value="${defaultColor}" placeholder="#8B5CF6" style="flex:1;${inputStyle}" oninput="if(/^#[0-9a-fA-F]{6}$/.test(this.value))document.getElementById('am-new-color').value=this.value">
        </div>
      </div>

      <div>
        ${_amLabel('시스템 프롬프트', AGENT_FIELD_HELP.system_prompt)}
        <textarea id="am-new-system-prompt" rows="2" placeholder="시스템 프롬프트 (선택)" style="${inputStyle};resize:vertical"></textarea>
      </div>

      <div style="display:flex;gap:8px">
        <div style="flex:1">
          ${_amLabel('Temperature', AGENT_FIELD_HELP.temperature)}
          <input id="am-new-temperature" type="number" step="0.1" min="0" max="2" placeholder="기본값" style="${inputStyle}">
          <div class="field-hint">낮을수록 일관되고, 높을수록 다양한 답변이 나옵니다.</div>
        </div>
        <div style="flex:2">
          ${_amLabel('리뷰 포커스 (쉼표 구분)', AGENT_FIELD_HELP.review_focus)}
          <input id="am-new-review-focus" placeholder="security, performance, ..." style="${inputStyle}">
        </div>
      </div>

      <div>
        ${_amLabel('연결 테스트 Endpoint (자동)', AGENT_FIELD_HELP.test_endpoint)}
        <div id="am-new-test-target" class="field-hint"></div>
        <div style="margin-top:6px">
          <button class="btn" type="button" onclick="_amTestConnection('new', this)">연결 테스트</button>
        </div>
        <div id="am-new-test-result" class="conn-test-result"></div>
      </div>

      <button class="btn btn-primary" onclick="_amSubmitNewAgent(this)" style="align-self:flex-end;padding:8px 24px">추가</button>
    </div>`;
  _amUpdateNewStrictnessUI();
  _amRefreshModelHint('new');
  _amRefreshConnectionHint('new');
  _amBindDirtyTracking();
}

function _amApplyNewRolePreset(key) {
  const rp = ROLE_PRESETS.find(r => r.key === key);
  if (!rp) return;
  const roleEl = document.getElementById('am-new-role');
  const focusEl = document.getElementById('am-new-review-focus');
  const promptEl = document.getElementById('am-new-system-prompt');
  if (roleEl) roleEl.value = rp.role;
  if (focusEl) focusEl.value = rp.review_focus.join(', ');
  if (promptEl) promptEl.value = rp.system_prompt;
  _amSetDirty(true);
}

function _amUpdateNewStrictnessUI() {
  const checked = document.querySelector('input[name="am-new-strictness"]:checked');
  if (!checked) return;
  STRICTNESS_OPTIONS.forEach(so => {
    const label = document.getElementById('am-new-strictness-' + so.value)?.closest('label');
    if (!label) return;
    const sel = so.value === checked.value;
    label.style.borderColor = sel ? 'var(--accent)' : 'var(--border)';
    label.style.background = sel ? 'rgba(88,166,255,0.08)' : 'var(--bg)';
  });
}

function _amOnNewClientTypeChange() {
  const ct = document.getElementById('am-new-client-type')?.value || 'claude-code';
  const providerRow = document.getElementById('am-new-provider-row');
  if (providerRow) providerRow.style.display = ct === 'opencode' ? '' : 'none';
  const modelSelect = document.getElementById('am-new-model-id-select');
  if (modelSelect) {
    const models = _amAvailableModels[ct] || [];
    modelSelect.innerHTML = '<option value="">기본값 (클라이언트 설정)</option>' + models.map(m => `<option value="${m.model_id}">${m.label}</option>`).join('');
  }
  _amRefreshModelHint('new');
  _amRefreshConnectionHint('new');
}

function _amRenderConnectionTestDetail(data) {
  const detail = {
    status: data?.status || '',
    elapsed_ms: data?.elapsed_ms ?? null,
    reason: data?.reason || data?.detail || '',
    test_token: data?.test_token || '',
    session_marker: data?.session_marker || '',
    callback: data?.callback || null,
    trigger: data?.trigger || null,
  };
  return `<details class="conn-test-detail"><summary>상세 보기</summary><pre class="conn-test-json">${esc(JSON.stringify(detail, null, 2))}</pre></details>`;
}

async function _amTestConnection(mode, btn) {
  const isNew = mode === 'new';
  const prefix = isNew ? 'am-new' : 'am';
  const resultEl = document.getElementById(`${prefix}-test-result`);
  const clientType = document.getElementById(`${prefix}-client-type`)?.value || 'claude-code';
  const provider = (document.getElementById(`${prefix}-provider`)?.value || '').trim();
  const modelId = (document.getElementById(`${prefix}-model-id`)?.value || '').trim();

  if (btn) btn.disabled = true;
  const startTime = Date.now();
  let timerInterval = null;
  if (resultEl) {
    resultEl.className = 'conn-test-result';
    resultEl.textContent = '테스트 중... 0초';
    timerInterval = setInterval(() => {
      const sec = Math.floor((Date.now() - startTime) / 1000);
      resultEl.textContent = `테스트 중... ${sec}초`;
    }, 1000);
  }

  try {
    const r = await fetch('/api/agents/connection-test', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ client_type: clientType, provider, model_id: modelId, timeout_seconds: 60 }),
    });
    const data = await r.json();
    if (!r.ok) {
      if (resultEl) {
        resultEl.className = 'conn-test-result fail';
        resultEl.innerHTML = `${esc(data.detail || '연결 테스트 실패')}${_amRenderConnectionTestDetail(data)}`;
      }
      return;
    }
    if (data.ok) {
      if (resultEl) {
        const elapsed = data.elapsed_ms != null ? `${(data.elapsed_ms / 1000).toFixed(1)}초` : '-';
        resultEl.className = 'conn-test-result ok';
        resultEl.innerHTML = `${esc(`성공 (${elapsed}) · 콜백 수신 완료`)}${_amRenderConnectionTestDetail(data)}`;
      }
    } else if (resultEl) {
      resultEl.className = 'conn-test-result fail';
      const reason = data.reason || data.error || data.status || '연결 실패';
      resultEl.innerHTML = `${esc(`실패: ${reason}`)}${_amRenderConnectionTestDetail(data)}`;
    }
  } catch (e) {
    if (resultEl) {
      resultEl.className = 'conn-test-result fail';
      resultEl.innerHTML = `${esc(`요청 실패: ${e.message}`)}${_amRenderConnectionTestDetail({ reason: e.message, status: 'request_error' })}`;
    }
  } finally {
    if (timerInterval) clearInterval(timerInterval);
    if (btn) btn.disabled = false;
  }
}

async function _amSubmitNewAgent(btn) {
  btn.disabled = true;
  const tempVal = (document.getElementById('am-new-temperature')?.value || '').trim();
  const focusVal = (document.getElementById('am-new-review-focus')?.value || '').trim();
  const strictnessEl = document.querySelector('input[name="am-new-strictness"]:checked');
  const payload = {
    id: (document.getElementById('am-new-id')?.value || '').trim(),
    role: (document.getElementById('am-new-role')?.value || '').trim(),
    description: (document.getElementById('am-new-description')?.value || '').trim(),
    strictness: strictnessEl?.value || 'balanced',
    client_type: document.getElementById('am-new-client-type')?.value || 'claude-code',
    provider: (document.getElementById('am-new-provider')?.value || '').trim(),
    model_id: (document.getElementById('am-new-model-id')?.value || '').trim(),
    color: (document.getElementById('am-new-color-text')?.value || '').trim(),
    system_prompt: document.getElementById('am-new-system-prompt')?.value || '',
    temperature: tempVal ? parseFloat(tempVal) : null,
    review_focus: focusVal ? focusVal.split(',').map(s => s.trim()).filter(Boolean) : [],
  };
  if (!payload.id) { showToast('id는 필수입니다', 'error'); alert('id는 필수입니다'); btn.disabled = false; return; }
  try {
    const r = await fetch('/api/agent-presets', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload),
    });
    const data = await r.json();
    if (!r.ok) { showToast(data.detail || '프리셋 추가 실패', 'error'); alert(data.detail || '프리셋 추가 실패'); btn.disabled = false; return; }
    _amSetDirty(false);
    showToast('프리셋이 추가되었습니다.', 'success');
    window.dispatchEvent(new CustomEvent('agent-presets-updated'));
    // Re-fetch and show the new agent
    let agents = [];
    try { const r2 = await fetch('/api/agent-presets'); if (r2.ok) agents = await r2.json(); } catch (e) {}
    _amSelectedAgentId = payload.id;
    _amRenderList(agents);
    const mc = agents.find(a => a.id === payload.id);
    if (mc) _amRenderEditForm(mc, agents);
  } catch (e) {
    showToast('프리셋 추가 실패', 'error');
    alert('프리셋 추가 실패');
    btn.disabled = false;
  }
}

// --- Redirect legacy functions ---
async function openAddAgentModal() { await openAgentManager(); }
async function openEditAgentModal(modelId) { await openAgentManager(modelId); }

async function removeAgent(modelId) {
  if (!confirm(`${modelId} 에이전트를 제거하시겠습니까?`)) return;
  try {
    const r = await fetch(`/api/sessions/current/agents/${modelId}`, { method: 'DELETE' });
    const data = await r.json();
    if (!r.ok) { alert(data.detail || '에이전트 제거 실패'); return; }
    await pollStatus();
  } catch (e) {
    alert('에이전트 제거 실패');
  }
}

async function toggleAgentEnabled(modelId) {
  const agent = state.agents.find(a => a.model_id === modelId);
  if (!agent) return;
  const newEnabled = agent.enabled === false ? true : false;
  try {
    const r = await fetch(`/api/sessions/current/agents/${modelId}`, {
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ enabled: newEnabled }),
    });
    if (!r.ok) { const e = await r.json(); alert(e.detail || '변경 실패'); return; }
    await pollStatus();
  } catch (e) { alert('변경 실패'); }
}

function renderAgentChatMessages(messages) {
  return messages.map((m) => {
    if (m.role === 'user') {
      return `<div class="assist-msg assist-msg-user"><div class="bubble">${esc(m.content)}</div></div>`;
    }
    return `<div class="assist-msg assist-msg-ai"><div class="bubble">${esc(m.content)}</div></div>`;
  }).join('');
}

function renderAgentRuntime(runtime) {
  if (!runtime) return '<div class="agent-runtime-card">상태 정보를 불러오지 못했습니다.</div>';
  const pending = (runtime.pending_issue_ids || []).join(', ') || '-';
  const prompt = runtime.prompt_full ? esc(runtime.prompt_full) : (runtime.prompt_preview ? esc(runtime.prompt_preview) : '(프롬프트 미기록)');
  const out = runtime.last_output ? esc(runtime.last_output) : '(출력 없음)';
  const err = runtime.last_error ? esc(runtime.last_error) : '(오류 없음)';
  return `<div class="agent-runtime-card">
    <div class="agent-runtime-grid">
      <div><span class="k">상태:</span> <span class="v">${esc(runtime.status || '-')}</span></div>
      <div><span class="k">작업:</span> <span class="v">${esc(runtime.task_type || '-')}</span></div>
      <div><span class="k">역할:</span> <span class="v">${esc(runtime.role || '-')}</span></div>
      <div><span class="k">경과:</span> <span class="v">${runtime.elapsed_seconds != null ? esc(formatElapsed(runtime.elapsed_seconds)) : '-'}</span></div>
      <div><span class="k">대기 이슈 수:</span> <span class="v">${runtime.pending_count ?? 0}</span></div>
      <div><span class="k">대기 이슈 ID:</span> <span class="v">${esc(pending)}</span></div>
      <div><span class="k">최근 사유:</span> <span class="v">${esc(runtime.last_reason || '-')}</span></div>
      <div><span class="k">갱신 시각:</span> <span class="v">${runtime.updated_at ? esc(formatTs(runtime.updated_at)) : '-'}</span></div>
    </div>
    <div class="agent-runtime-log-title">최근 stdout</div>
    <div class="agent-runtime-log">${out}</div>
    <div class="agent-runtime-log-title">최근 stderr</div>
    <div class="agent-runtime-log">${err}</div>
    <div class="agent-runtime-log-title">프롬프트 미리보기</div>
    <div class="agent-runtime-log">${prompt}</div>
  </div>`;
}

async function openAgentChat(modelId) {
  state.selectedAgent = modelId;
  agentChatLastMessageCount = 0;
  const overlay = document.createElement('div');
  overlay.className = 'report-overlay';
  overlay.id = 'agent-chat-overlay';
  overlay.innerHTML = `<div class="report-card" style="max-width:760px">
    <div class="report-header"><h2>@${esc(modelId)} 직접 대화</h2><button class="report-close" onclick="closeAgentChat()">\u2715</button></div>
    <div id="agent-runtime"></div>
    <div class="assist-messages" id="agent-chat-messages" style="max-height:55vh"></div>
    <div class="assist-input-bar">
      <textarea class="assist-input" id="agent-chat-input" placeholder="@${esc(modelId)} 에게 메시지를 입력하세요..." rows="2" onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendAgentChat()}"></textarea>
      <button class="btn-assist-send" id="agent-chat-send" onclick="sendAgentChat()">전송</button>
    </div>
  </div>`;
  document.body.appendChild(overlay);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) closeAgentChat(); });
  await refreshAgentChat();
  if (agentChatRuntimeInterval) clearInterval(agentChatRuntimeInterval);
  agentChatRuntimeInterval = setInterval(() => {
    if (!state.selectedAgent || !document.getElementById('agent-chat-overlay')) {
      clearInterval(agentChatRuntimeInterval);
      agentChatRuntimeInterval = null;
      return;
    }
    refreshAgentChat();
  }, 3000);
}

function closeAgentChat() {
  document.getElementById('agent-chat-overlay')?.remove();
  if (agentChatRuntimeInterval) {
    clearInterval(agentChatRuntimeInterval);
    agentChatRuntimeInterval = null;
  }
  agentChatLastMessageCount = 0;
  state.selectedAgent = null;
}

async function refreshAgentChat() {
  if (!state.selectedAgent) return;
  const [chatResp, runtimeResp] = await Promise.all([
    fetch(`/api/sessions/current/agents/${state.selectedAgent}/chat`),
    fetch(`/api/sessions/current/agents/${state.selectedAgent}/runtime`),
  ]);
  const data = await chatResp.json();
  if (!chatResp.ok) return;
  const el = document.getElementById('agent-chat-messages');
  if (!el) return;
  const prevCount = agentChatLastMessageCount;
  const nextCount = data.messages?.length || 0;
  const wasNearBottom = (el.scrollHeight - el.scrollTop - el.clientHeight) < 24;
  el.innerHTML = data.messages?.length ? renderAgentChatMessages(data.messages) : '<div style="padding:8px;color:var(--text-muted);font-size:13px;text-align:center">아직 대화가 없습니다</div>';
  if (nextCount > prevCount || wasNearBottom) {
    el.scrollTop = el.scrollHeight;
  }
  agentChatLastMessageCount = nextCount;
  const runtimeEl = document.getElementById('agent-runtime');
  if (runtimeEl) {
    const oldLogs = Array.from(runtimeEl.querySelectorAll('.agent-runtime-log'));
    const oldScrolls = oldLogs.map((node) => node.scrollTop);
    if (runtimeResp.ok) {
      const runtime = await runtimeResp.json();
      runtimeEl.innerHTML = renderAgentRuntime(runtime);
    } else {
      runtimeEl.innerHTML = renderAgentRuntime(null);
    }
    const newLogs = Array.from(runtimeEl.querySelectorAll('.agent-runtime-log'));
    newLogs.forEach((node, idx) => {
      if (oldScrolls[idx] != null) node.scrollTop = oldScrolls[idx];
    });
  }
}

async function sendAgentChat() {
  if (!state.selectedAgent) return;
  const input = document.getElementById('agent-chat-input');
  const send = document.getElementById('agent-chat-send');
  const message = input?.value?.trim();
  if (!message) return;
  send.disabled = true;
  try {
    const r = await fetch(`/api/sessions/current/agents/${state.selectedAgent}/chat`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ message }),
    });
    const data = await r.json();
    if (!r.ok) { alert(data.detail || '전송 실패'); return; }
    input.value = '';
    const el = document.getElementById('agent-chat-messages');
    if (el) {
      el.innerHTML = renderAgentChatMessages(data.messages || []);
      el.scrollTop = el.scrollHeight;
    }
  } catch (e) {
    alert('전송 실패');
  } finally {
    send.disabled = false;
  }
}

// --- Assist (issue resolution helper) ---

function renderAssistMessages(messages) {
  return messages.map(m => {
    if (m.role === 'user') {
      return `<div class="assist-msg assist-msg-user"><div class="bubble">${esc(m.content)}</div></div>`;
    }
    return `<div class="assist-msg assist-msg-ai"><div class="bubble">${renderMd(m.content)}</div></div>`;
  }).join('');
}

function toggleAssist(issueId) {
  const chat = document.getElementById('assist-chat-' + issueId);
  if (chat) chat.classList.toggle('open');
}

async function sendAssist(issueId, message) {
  if (!message?.trim()) return;
  const messagesEl = document.getElementById('assist-messages-' + issueId);
  const sendBtn = document.getElementById('assist-send-' + issueId);
  const inputEl = document.getElementById('assist-input-' + issueId);

  // Show user message immediately
  messagesEl.innerHTML += `<div class="assist-msg assist-msg-user"><div class="bubble">${esc(message)}</div></div>`;
  // Show thinking
  messagesEl.innerHTML += '<div class="assist-thinking" id="assist-thinking"><span>생각하는 중</span><span class="dots"><span></span><span></span><span></span></span></div>';
  messagesEl.scrollTop = messagesEl.scrollHeight;

  if (sendBtn) sendBtn.disabled = true;
  if (inputEl) inputEl.value = '';

  try {
    const r = await fetch(`/api/issues/${issueId}/assist`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message }),
    });
    const data = await r.json();
    if (!r.ok) { alert(data.detail || '오류가 발생했습니다'); return; }

    // Re-render all messages from server response
    messagesEl.innerHTML = renderAssistMessages(data.messages);

    // Update CLI command if available
    if (data.cli_command) {
      const cliEl = document.getElementById('assist-cli-' + issueId);
      if (cliEl) cliEl.textContent = data.cli_command;
    }
  } catch (e) {
    // Remove thinking indicator
    const thinking = document.getElementById('assist-thinking');
    if (thinking) thinking.remove();
    messagesEl.innerHTML += `<div class="assist-msg assist-msg-ai"><div class="bubble" style="color:var(--severity-critical)">요청 실패: ${esc(e.message)}</div></div>`;
  } finally {
    if (sendBtn) sendBtn.disabled = false;
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
}

async function issueHumanAssistKey() {
  if (!state.sessionId) {
    showToast('활성 세션이 없습니다', 'error');
    return '';
  }
  try {
    const r = await fetch(`/api/sessions/${state.sessionId}/assist/key`, { method: 'POST' });
    const data = await r.json();
    if (!r.ok) {
      showToast(data.detail || '도우미 키 발급 실패', 'error');
      return '';
    }
    const key = String(data.access_key || '').trim();
    if (!key) {
      showToast('도우미 키 응답이 비어 있습니다', 'error');
      return '';
    }
    state.humanAssistAccessKey = key;
    _humanAssistKeyBySession[state.sessionId] = key;
    showToast('human-assist 접근 키가 발급되었습니다', 'success');
    return key;
  } catch (e) {
    showToast('도우미 키 발급 실패', 'error');
    return '';
  }
}

async function submitAssistOpinion(issueId) {
  const input = document.getElementById('assist-input-' + issueId);
  const msg = input?.value?.trim() || '';
  let key = (state.humanAssistAccessKey || '').trim();
  if (!key && state.sessionId) key = (_humanAssistKeyBySession[state.sessionId] || '').trim();
  if (!key) {
    alert('먼저 도우미 키를 발급해주세요.');
    return;
  }
  try {
    const r = await fetch(`/api/issues/${issueId}/assist/opinion`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Agent-Key': key },
      body: JSON.stringify({ message: msg }),
    });
    const data = await r.json();
    if (!r.ok) {
      if (r.status === 403) {
        state.humanAssistAccessKey = null;
        if (state.sessionId) delete _humanAssistKeyBySession[state.sessionId];
      }
      alert(data.detail || 'AI 의견 제출 실패');
      return;
    }
    if (input) input.value = '';
    await pollStatus();
    if (state.selectedIssue === issueId) await renderIssueDetail();
  } catch (e) {
    alert('AI 의견 제출 실패');
  }
}

function sendAssistFromInput(issueId) {
  const input = document.getElementById('assist-input-' + issueId);
  if (!input?.value?.trim()) return;
  sendAssist(issueId, input.value.trim());
}

function copyCliCommand(issueId) {
  const el = document.getElementById('assist-cli-' + issueId);
  if (!el) return;
  navigator.clipboard.writeText(el.textContent).then(() => {
    const hint = el.parentElement.querySelector('.copy-hint');
    if (hint) { hint.textContent = '복사됨!'; setTimeout(() => { hint.textContent = '복사'; }, 1500); }
  });
}

function createIssueFromFile(filePath) {
  const overlay = document.createElement('div');
  overlay.className = 'report-overlay';
  const inputStyle = 'background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;font-family:inherit;width:100%';
  overlay.innerHTML = `<div class="report-card" style="max-width:500px">
    <div class="report-header"><h2>이슈 등록</h2><button class="report-close" onclick="this.closest('.report-overlay').remove()">\u2715</button></div>
    <div style="padding:20px;display:flex;flex-direction:column;gap:12px">
      <input id="new-issue-title" placeholder="제목" style="${inputStyle}">
      <div style="display:flex;gap:8px">
        <input id="new-issue-file" value="${esc(filePath)}" style="flex:1;${inputStyle}">
        <input id="new-issue-line" placeholder="라인" type="number" style="width:80px;${inputStyle}">
      </div>
      <select id="new-issue-severity" style="${inputStyle}">
        <option value="critical">심각</option>
        <option value="high">높음</option>
        <option value="medium" selected>보통</option>
        <option value="low">낮음</option>
      </select>
      <textarea id="new-issue-desc" placeholder="설명" rows="4" style="${inputStyle};resize:vertical"></textarea>
      <textarea id="new-issue-suggestion" placeholder="수정 제안 (선택)" rows="2" style="${inputStyle};resize:vertical"></textarea>
      <button class="btn btn-primary" onclick="submitNewIssue(this)" style="align-self:flex-end">등록</button>
    </div>
  </div>`;
  document.body.appendChild(overlay);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

async function submitNewIssue(btn) {
  btn.disabled = true;
  const data = {
    title: document.getElementById('new-issue-title').value.trim(),
    severity: document.getElementById('new-issue-severity').value,
    file: document.getElementById('new-issue-file').value.trim(),
    line: parseInt(document.getElementById('new-issue-line').value) || null,
    description: document.getElementById('new-issue-desc').value.trim(),
    suggestion: document.getElementById('new-issue-suggestion').value.trim(),
  };
  if (!data.title || !data.file) { alert('제목과 파일은 필수입니다'); btn.disabled = false; return; }
  try {
    const r = await fetch(`/api/sessions/${state.sessionId}/issues`, {
      method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data),
    });
    if (!r.ok) { const e = await r.json(); alert(e.detail || '오류'); btn.disabled = false; return; }
    btn.closest('.report-overlay').remove();
    await pollStatus();
  } catch (e) { alert('등록 실패'); btn.disabled = false; }
}

async function submitOpinion(issueId, action) {
  const text = document.getElementById('comment-text')?.value?.trim();
  if (!text) { alert('의견을 작성해주세요.'); return; }
  const severity = document.getElementById('comment-severity')?.value || null;
  const mentions = Array.from(new Set((text.match(/@([A-Za-z0-9_-]+)/g) || []).map(m => m.slice(1))));
  try {
    const r = await fetch(`/api/issues/${issueId}/opinions`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ model_id:'human', action, reasoning:text, suggested_severity:severity||undefined, mentions })
    });
    if (!r.ok) { const e = await r.json(); alert(e.detail||'오류가 발생했습니다'); return; }
    await pollStatus();
  } catch(e) { alert('제출에 실패했습니다'); }
}

async function processReviews() {
  if (!state.sessionId) return;
  const btn = document.getElementById('btn-process');
  btn.disabled = true; btn.textContent = '처리 중...';
  try {
    const r = await fetch(`/api/sessions/${state.sessionId}/process`, {method:'POST'});
    if (!r.ok) { const e = await r.json(); alert(e.detail||'오류가 발생했습니다'); return; }
    await pollStatus();
  } catch(e) { alert('처리에 실패했습니다'); }
  btn.disabled = false; btn.textContent = '리뷰 처리';
}

async function finishReview() {
  if (!state.sessionId) return;
  if (!confirm('리뷰 세션을 완료하시겠습니까? 최종 리포트가 생성됩니다.')) return;
  const btn = document.getElementById('btn-finish');
  btn.disabled = true; btn.textContent = '완료 중...';
  try {
    const r = await fetch(`/api/sessions/${state.sessionId}/finish`, {method:'POST'});
    if (!r.ok) { const e = await r.json(); alert(e.detail||'오류가 발생했습니다'); return; }
    const report = await r.json();
    showReport(report);
    await pollStatus();
  } catch(e) { alert('완료에 실패했습니다'); }
  btn.disabled = false; btn.textContent = '리뷰 완료';
}

function showReport(report) {
  const overlay = document.createElement('div');
  overlay.className = 'report-overlay';
  const s = report.stats || {};
  let issuesHtml = '';
  for (const i of (report.issues||[])) {
    const sev = i.final_severity || 'low';
    const sevColor = SEVERITY_COLORS[sev]||'#6B7280';
    const icon = SEVERITY_ICONS[sev]||'\u26AA';
    const cIcon = i.consensus ? '\u2705' : '\u26A0';
    issuesHtml += `<div class="report-issue">
      <span>${icon}</span>
      <span class="severity-badge" style="background:${sevColor}20;color:${sevColor}">${sevLabel(sev)}</span>
      <span style="flex:1">${esc(i.title)}</span>
      <span style="color:var(--text-muted);font-size:11px">${esc(i.file||'')}</span>
      <span>${cIcon}</span>
    </div>`;
  }
  overlay.innerHTML = `<div class="report-card">
    <div class="report-header"><h2>최종 리포트</h2><button class="report-close" onclick="this.closest('.report-overlay').remove()">\u2715</button></div>
    <div class="report-stats">
      <div class="report-stat"><div class="value">${s.total_issues_found||0}</div><div class="label">원본 이슈</div></div>
      <div class="report-stat"><div class="value">${s.after_dedup||0}</div><div class="label">중복 제거 후</div></div>
      <div class="report-stat"><div class="value">${s.consensus_reached||0}</div><div class="label">합의 완료</div></div>
      <div class="report-stat"><div class="value">${s.dismissed||0}</div><div class="label">기각</div></div>
    </div>
    <div class="report-issues">${issuesHtml || '<div style="padding:12px;color:var(--text-muted)">이슈 없음</div>'}</div>
  </div>`;
  document.body.appendChild(overlay);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

function schedulePoll(delay = 0) {
  if (pollScheduled) return;
  pollScheduled = true;
  setTimeout(() => {
    pollScheduled = false;
    pollStatus();
  }, delay);
}

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(() => schedulePoll(0), 5000);
}

function stopStatusPolling() {
  if (!statusPollInterval) return;
  clearInterval(statusPollInterval);
  statusPollInterval = null;
}

async function pollStatus() {
  if (!state.sessionId) return;
  if (_shouldDeferIssueRender()) {
    _pollDeferredWhileSelecting = true;
    return;
  }
  if (pollInFlight) return;
  pollInFlight = true;
  try {
    const r = await fetch(`/api/sessions/${state.sessionId}/status`);
    if (!r.ok) return;
    const d = await r.json();
    state.status = d.status;
    state.currentTurn = Number.isFinite(Number(d.current_turn)) ? Number(d.current_turn) : 0;
    state.files = d.files || [];
    state.agents = d.agents || [];
    document.getElementById('stat-files').textContent = '파일 '+d.files_changed+'개';
    document.getElementById('stat-reviews').textContent = '리뷰 '+d.review_count+'개';
    document.getElementById('stat-issues').textContent = '이슈 '+d.issue_count+'개';
    const branchText = d.head ? `${d.head} \u2192 ${d.base}` : (d.base ? `\u2192 ${d.base}` : '--');
    document.getElementById('branch-info').textContent = branchText;
    updateStepIndicator();
    renderFilePanel();
    renderIssueFilterOptions();

    // Show/hide action buttons based on status
    const btnProcess = document.getElementById('btn-process');
    const btnFinish = document.getElementById('btn-finish');
    btnProcess.style.display = (d.status === 'reviewing' && d.review_count > 0) ? '' : 'none';
    btnFinish.style.display = (d.status === 'deliberating' || d.status === 'reviewing') ? '' : 'none';

    const ir = await fetch(`/api/sessions/${state.sessionId}/issues`);
    if (ir.ok) {
      const prev = state.selectedIssue ? JSON.stringify(state.issues.find(i => i.id === state.selectedIssue)) : null;
      state.issues = await ir.json();
      const restoredIssue = _uiSelectedIssueBySession[state.sessionId];
      if ((!state.selectedIssue || !state.issues.some(i => i.id === state.selectedIssue)) && restoredIssue) {
        if (state.issues.some(i => i.id === restoredIssue)) state.selectedIssue = restoredIssue;
      }
      if (state.selectedIssue && !state.issues.some(i => i.id === state.selectedIssue)) {
        state.selectedIssue = null;
      }
      if (_shouldDeferIssueRender()) {
        _issueRenderPending = true;
      } else {
        renderIssueList();
        const curr = state.selectedIssue ? JSON.stringify(state.issues.find(i => i.id === state.selectedIssue)) : null;
        if (state.detailViewMode !== 'issue') renderIssueDetail();
        else if (!state.selectedIssue) renderIssueDetail();
        else if (prev !== curr) renderIssueDetail();
      }
    } else {
      if (_shouldDeferIssueRender()) _issueRenderPending = true;
      else {
        renderIssueList();
        if (state.detailViewMode !== 'issue' || !state.selectedIssue) renderIssueDetail();
      }
    }
    // Restore agent activities from server on refresh (when client has no data)
    if (d.agent_activities) {
      for (const [modelId, acts] of Object.entries(d.agent_activities)) {
        if (!_agentActivities[modelId] || !_agentActivities[modelId].history.length) {
          if (acts.length) {
            _agentActivities[modelId] = {
              latest: acts[0],
              history: acts.slice(0, MAX_ACTIVITY_HISTORY),
            };
          }
        }
      }
    }
    renderAgentPanel();
    if (state.selectedAgent) refreshAgentChat();
    updateSummary();
    await fetchSessions();
    renderSessionTabs();
  } catch(e) {
  } finally {
    pollInFlight = false;
  }
}

function connectSSE(sid) {
  if (sseSource) sseSource.close();
  const src = new EventSource(`/api/sessions/${sid}/stream`);
  sseSource = src;
  src.onopen = () => {
    stopStatusPolling();
    schedulePoll(0);
  };
  src.addEventListener('phase_change', ()=>schedulePoll(50));
  src.addEventListener('review_submitted', ()=>schedulePoll(50));
  src.addEventListener('opinion_submitted', ()=>schedulePoll(50));
  src.addEventListener('agent_status', ()=>schedulePoll(50));
  src.addEventListener('issue_created', ()=>schedulePoll(50));
  src.addEventListener('agent_config_changed', ()=>schedulePoll(50));
  src.addEventListener('agent_activity', (ev) => {
    try {
      const data = JSON.parse(ev.data);
      _onAgentActivity(data);
    } catch(e) {}
  });
  src.onerror = ()=>{
    src.close();
    if (sseSource === src) sseSource = null;
    startStatusPolling();
    setTimeout(()=>{ if(state.sessionId) connectSSE(state.sessionId); }, 3000);
  };
}

// Panel resize
(function initResize() {
  const handle = document.getElementById('resize-handle');
  const left = document.getElementById('left-panel');
  if (!left) return;
  window.addEventListener('resize', () => _syncLeftPaneLayout());
  setTimeout(() => _syncLeftPaneLayout(), 0);
  if (!handle) return;
  let startX, startW;
  handle.addEventListener('mousedown', (e) => {
    startX = e.clientX; startW = left.offsetWidth;
    handle.classList.add('active');
    const onMove = (e) => {
      left.style.width = Math.max(240, Math.min(760, startW + e.clientX - startX)) + 'px';
      _syncLeftPaneLayout();
    };
    const onUp = () => { handle.classList.remove('active'); document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
})();

(function initReviewersResize() {
  const handle = document.getElementById('right-side-splitter');
  const sidebar = document.getElementById('reviewers-sidebar');
  if (!handle || !sidebar) return;

  const minW = 320;
  const maxW = 900;
  const mobile = window.matchMedia('(max-width: 1200px)');

  const clamp = (w) => Math.max(minW, Math.min(maxW, Math.round(Number(w) || 420)));
  const apply = (w) => { sidebar.style.width = `${clamp(w)}px`; };

  if (!mobile.matches) apply(sidebar.offsetWidth || 420);

  let startX = 0;
  let startW = 0;
  handle.addEventListener('mousedown', (e) => {
    if (mobile.matches) return;
    e.preventDefault();
    startX = e.clientX;
    startW = sidebar.getBoundingClientRect().width;
    handle.classList.add('active');

    const onMove = (ev) => {
      apply(startW - (ev.clientX - startX));
    };
    const onUp = () => {
      handle.classList.remove('active');
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  const onViewportChange = () => {
    if (mobile.matches) {
      sidebar.style.width = '';
      return;
    }
    apply(sidebar.getBoundingClientRect().width || 420);
  };
  if (mobile.addEventListener) mobile.addEventListener('change', onViewportChange);
  else if (mobile.addListener) mobile.addListener(onViewportChange);
  window.addEventListener('resize', onViewportChange);
})();

// Prevent polling re-renders from breaking text drag selection in diff view.
(function initIssueRenderGuard() {
  const detail = document.getElementById('issue-detail');
  if (!detail) return;
  detail.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    const t = e.target;
    if (t && t.closest && t.closest('input, textarea, select, button, a, [contenteditable="true"]')) return;
    _issueRenderPaused = true;
  });
  const release = () => {
    if (!_issueRenderPaused) return;
    _issueRenderPaused = false;
    setTimeout(() => _flushDeferredIssueRender(), 0);
  };
  document.addEventListener('mouseup', release);
  document.addEventListener('dragend', release);
  document.addEventListener('selectionchange', () => {
    if (_shouldDeferIssueRender()) return;
    _flushDeferredIssueRender();
  });
})();

// --- Session management ---

async function fetchSessions() {
  try {
    const r = await fetch('/api/sessions');
    if (r.ok) state.sessions = await r.json();
  } catch (e) { /* ignore */ }
}

function renderSessionTabs() {
  const list = document.getElementById('session-tab-list');
  if (!list) return;
  if (!state.sessions.length) {
    list.innerHTML = '<span class="session-tabs-empty">세션 없음</span>';
    return;
  }
  list.innerHTML = state.sessions.map(s => {
    const shortId = s.session_id.slice(0, 6);
    const isActive = s.session_id === state.sessionId;
    const activeCls = isActive ? ' active' : '';
    const st = STATUS_TAB_STYLES[s.status] || STATUS_TAB_STYLES.idle;
    const stLabel = STATUS_TAB_LABELS[s.status] || s.status;
    return `<div class="session-tab${activeCls}" onclick="switchSession('${esc(s.session_id)}')">
      <span class="tab-id">${esc(shortId)}</span>
      <span class="tab-base">${esc(s.base || '')}</span>
      <span class="tab-status" style="background:${st.bg};color:${st.color}">${esc(stLabel)}</span>
      <button class="tab-close" onclick="event.stopPropagation();deleteSession('${esc(s.session_id)}')" title="세션 삭제">&times;</button>
    </div>`;
  }).join('');
}

async function switchSession(sid) {
  if (sid === state.sessionId) return;
  if (sseSource) { sseSource.close(); sseSource = null; }
  try {
    const r = await fetch(`/api/sessions/${sid}/activate`, { method: 'POST' });
    if (!r.ok) { await fetchSessions(); renderSessionTabs(); return; }
  } catch (e) { await fetchSessions(); renderSessionTabs(); return; }
  // Reset state
  state.sessionId = sid;
  state.status = 'idle';
  state.currentTurn = 0;
  state.detailViewMode = 'issue';
  state.issues = [];
  state.humanAssistAccessKey = _humanAssistKeyBySession[sid] || null;
  state.issueNumberById = {};
  state.nextIssueNumber = 1;
  state.selectedIssue = _uiSelectedIssueBySession[sid] || null;
  state.selectedAgent = null;
  state.selectedFileDiff = null;
  state.diffCache = {};
  state.files = [];
  state.fileTreeExpanded = {};
  _fileTreeAutoExpandedPath = '';
  state.agents = [];
  state.expandedDiffByIssue = {};
  state.collapsedIssueGroups = {};
  state.expandedReasoning = {};
  state.reviewerExpanded = {};
  _uiSaveStateToStorage();
  router.push({ sessionId: sid, viewMode: 'issue', issueId: state.selectedIssue });
  renderSessionTabs();
  connectSSE(sid);
  await pollStatus();
}

async function deleteSession(sid) {
  if (!confirm('이 세션을 삭제하시겠습니까?')) return;
  try {
    const r = await fetch(`/api/sessions/${sid}`, { method: 'DELETE' });
    if (!r.ok && r.status !== 404) { alert('세션 삭제 실패'); return; }
  } catch (e) { alert('세션 삭제 실패'); return; }
  delete _uiSelectedIssueBySession[sid];
  delete _humanAssistKeyBySession[sid];
  await fetchSessions();
  if (sid === state.sessionId) {
    if (state.sessions.length) {
      await switchSession(state.sessions[0].session_id);
    } else {
      if (sseSource) { sseSource.close(); sseSource = null; }
      state.sessionId = null;
      state.status = 'idle';
      state.currentTurn = 0;
      state.detailViewMode = 'issue';
      state.issues = [];
      state.humanAssistAccessKey = null;
      state.files = [];
      state.fileTreeExpanded = {};
      _fileTreeAutoExpandedPath = '';
      state.agents = [];
      state.reviewerExpanded = {};
      renderSessionTabs();
      updateStepIndicator();
      updateSummary();
      document.getElementById('issue-list').innerHTML = '<div class="empty-state"><div class="icon">&#128269;</div><div class="message">이슈가 없습니다</div><div class="hint">리뷰 세션을 시작하세요</div></div>';
      renderDetailViewBar();
      document.getElementById('issue-detail').innerHTML = renderIssueDetailEmpty();
      renderAgentPanel();
      document.getElementById('file-panel').style.display = 'none';
      _uiSaveStateToStorage();
      router.replace({ sessionId: null });
    }
  } else {
    renderSessionTabs();
    _uiSaveStateToStorage();
  }
}

function _getRecentRepos() {
  try { return JSON.parse(localStorage.getItem('ai-review-recent-repos') || '[]'); } catch { return []; }
}
function _saveRecentRepo(path) {
  if (!path) return;
  let repos = _getRecentRepos().filter(r => r !== path);
  repos.unshift(path);
  if (repos.length > 5) repos = repos.slice(0, 5);
  localStorage.setItem('ai-review-recent-repos', JSON.stringify(repos));
}

// --- Branch picker modal ---
let _nsmBranches = [];
let _nsmBaseValue = '';
let _nsmHeadValue = '';
let _nsmPresetList = [];
let _nsmSelectedPresetIds = [];
let _nsmRepoValidated = false;

function _nsmCanSubmit() {
  return _nsmRepoValidated && _nsmSelectedPresetIds.length > 0;
}

function _nsmUpdateSubmitState() {
  const submitBtn = document.getElementById('nsm-submit');
  if (submitBtn) submitBtn.disabled = !_nsmCanSubmit();
}

async function _nsmRefreshPresets(preserveSelection = true) {
  const prev = [..._nsmSelectedPresetIds];
  let list = [];
  try {
    const r = await fetch('/api/agent-presets');
    if (r.ok) list = await r.json();
  } catch (e) {}

  _nsmPresetList = list;
  const ids = _nsmPresetList.map(p => p.id);
  const idSet = new Set(ids);

  if (!preserveSelection) {
    _nsmSelectedPresetIds = [...ids];
  } else {
    let selected = prev.filter(id => idSet.has(id));
    if (!prev.length && ids.length) selected = [...ids];
    if (prev.length && !selected.length && ids.length) selected = [...ids];
    _nsmSelectedPresetIds = selected;
  }

  _nsmRenderPresetList();
  _nsmUpdateSubmitState();
}

async function _nsmOpenPresetManager(editModelId = null) {
  if (editModelId) {
    await openEditAgentModal(editModelId);
    return;
  }
  await openAgentManager();
}

async function _nsmOpenPresetAdd() {
  await openAgentManager();
  _amShowAddPanel(true);
}

window.addEventListener('agent-presets-updated', () => {
  if (document.getElementById('nsm-preset-list')) {
    _nsmRefreshPresets(true);
  }
});

function _nsmTogglePreset(id) {
  if (_nsmSelectedPresetIds.includes(id)) {
    _nsmSelectedPresetIds = _nsmSelectedPresetIds.filter(v => v !== id);
  } else {
    _nsmSelectedPresetIds.push(id);
  }
  _nsmRenderPresetList();
  _nsmUpdateSubmitState();
}

function _nsmRenderPresetList() {
  const wrap = document.getElementById('nsm-preset-list');
  if (!wrap) return;
  if (!_nsmPresetList.length) {
    wrap.innerHTML = `<div style="grid-column:1 / -1;padding:10px;border:1px dashed var(--border);border-radius:8px;color:var(--text-muted);font-size:12px;display:flex;align-items:center;justify-content:space-between;gap:8px">
      <span>등록된 프리셋이 없습니다.</span>
      <button class="btn" type="button" onclick="_nsmOpenPresetAdd()">프리셋 추가</button>
    </div>`;
    return;
  }
  wrap.innerHTML = _nsmPresetList.map((p) => {
    const checked = _nsmSelectedPresetIds.includes(p.id);
    const color = p.color || '#8B949E';
    const encoded = encodeURIComponent(p.id);
    return `<label style="display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid ${checked ? 'var(--accent)' : 'var(--border)'};border-radius:8px;cursor:pointer;background:${checked ? 'rgba(88,166,255,0.08)' : 'var(--bg)'}">
      <input type="checkbox" ${checked ? 'checked' : ''} onchange="_nsmTogglePreset(decodeURIComponent('${encoded}'))" style="accent-color:var(--accent)">
      <span style="width:10px;height:10px;border-radius:999px;background:${color};display:inline-block"></span>
      <span style="font-size:12px;font-weight:600">${esc(p.id)}</span>
      <span style="font-size:11px;color:var(--text-muted)">${esc(p.role || p.client_type || '')}</span>
      <button class="btn" type="button" style="margin-left:auto;font-size:10px;padding:2px 6px" onclick="event.preventDefault();event.stopPropagation();_nsmOpenPresetManager(decodeURIComponent('${encoded}'))">수정</button>
    </label>`;
  }).join('');
}

function _openBranchPicker(target, currentValue, onSelect) {
  const existing = document.querySelector('.branch-picker-overlay');
  if (existing) existing.remove();

  const locals = _nsmBranches.filter(b => b.type === 'local');
  const remotes = _nsmBranches.filter(b => b.type === 'remote');

  const overlay = document.createElement('div');
  overlay.className = 'branch-picker-overlay';

  function renderList(filter) {
    const q = (filter || '').toLowerCase();
    const fl = locals.filter(b => b.name.toLowerCase().includes(q));
    const fr = remotes.filter(b => b.name.toLowerCase().includes(q));
    if (!fl.length && !fr.length) return '<div class="bp-empty">일치하는 브랜치 없음</div>';
    let html = '';
    if (fl.length) {
      html += '<div class="bp-group-label">Local</div>';
      fl.forEach(b => {
        const sel = b.name === currentValue ? ' selected' : '';
        const check = b.name === currentValue ? '\u2713' : '';
        html += `<div class="bp-item${sel}" data-value="${esc(b.name)}"><span class="bp-check">${check}</span>${esc(b.name)}</div>`;
      });
    }
    if (fr.length) {
      html += '<div class="bp-group-label">Remote</div>';
      fr.forEach(b => {
        const sel = b.name === currentValue ? ' selected' : '';
        const check = b.name === currentValue ? '\u2713' : '';
        html += `<div class="bp-item${sel}" data-value="${esc(b.name)}"><span class="bp-check">${check}</span>${esc(b.name)}</div>`;
      });
    }
    return html;
  }

  const card = document.createElement('div');
  card.className = 'branch-picker-card';
  card.innerHTML = `<input class="bp-search" placeholder="브랜치 검색..." autofocus><div class="bp-list">${renderList('')}</div>`;
  overlay.appendChild(card);
  document.body.appendChild(overlay);

  const searchInput = card.querySelector('.bp-search');
  const listEl = card.querySelector('.bp-list');

  searchInput.addEventListener('input', () => { listEl.innerHTML = renderList(searchInput.value); });
  listEl.addEventListener('click', (e) => {
    const item = e.target.closest('.bp-item');
    if (!item) return;
    const val = item.dataset.value;
    onSelect(val);
    overlay.remove();
  });
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
  searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') overlay.remove();
    if (e.key === 'Enter') {
      const first = listEl.querySelector('.bp-item');
      if (first) { onSelect(first.dataset.value); overlay.remove(); }
    }
  });
}

async function openNewSessionModal() {
  _nsmBranches = [];
  _nsmBaseValue = '';
  _nsmHeadValue = '';
  _nsmRepoValidated = false;
  _nsmPresetList = [];
  _nsmSelectedPresetIds = [];

  const overlay = document.createElement('div');
  overlay.className = 'report-overlay';
  const inputStyle = 'background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;font-family:inherit;width:100%';
  const recentRepos = _getRecentRepos();
  const recentHtml = recentRepos.length
    ? `<div id="nsm-recent" style="display:flex;flex-wrap:wrap;gap:6px">${recentRepos.map(r => {
        const short = r.split('/').pop();
        return `<button type="button" class="btn" style="font-size:11px;padding:3px 8px" onclick="document.getElementById('nsm-repo-path').value='${esc(r)}';_nsmValidateRepo()">${esc(short)}</button>`;
      }).join('')}</div>`
    : '';

  overlay.innerHTML = `<div class="report-card" style="max-width:480px">
    <div class="report-header"><h2>새 리뷰 세션</h2><button class="report-close" onclick="this.closest('.report-overlay').remove()">\u2715</button></div>
    <div style="padding:20px;display:flex;flex-direction:column;gap:14px">
      <div>
        <label style="font-size:12px;color:var(--text-muted);display:block;margin-bottom:4px">Git 레포 경로</label>
        <div style="display:flex;gap:8px">
          <input id="nsm-repo-path" placeholder="/Users/.../project" style="${inputStyle};flex:1">
          <button class="btn" type="button" onclick="_nsmPickRepoPath()" title="폴더 선택" style="width:38px;padding:0">...</button>
          <button class="btn" id="nsm-validate-btn" onclick="_nsmValidateRepo()" style="white-space:nowrap">검증</button>
        </div>
        <div id="nsm-repo-status" style="font-size:12px;margin-top:6px"></div>
      </div>
      <div>
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px">
          <label style="font-size:12px;color:var(--text-muted);display:block">에이전트 프리셋</label>
          <div style="display:flex;align-items:center;gap:6px">
            <button class="btn" type="button" style="font-size:11px;padding:3px 8px" onclick="_nsmOpenPresetAdd()">추가</button>
            <button class="btn" type="button" style="font-size:11px;padding:3px 8px" onclick="_nsmOpenPresetManager()">관리</button>
            <button class="btn" type="button" style="font-size:11px;padding:3px 8px" onclick="_nsmRefreshPresets(true)">새로고침</button>
          </div>
        </div>
        <div id="nsm-preset-list" style="display:grid;grid-template-columns:1fr 1fr;gap:8px"></div>
        <div style="font-size:11px;color:var(--text-muted);margin-top:6px">선택한 프리셋의 리뷰어로 세션이 시작됩니다.</div>
      </div>
      ${recentRepos.length ? `<div><label style="font-size:12px;color:var(--text-muted);display:block;margin-bottom:4px">최근 사용</label>${recentHtml}</div>` : ''}
      <div id="nsm-branch-section" style="display:none">
        <div style="display:flex;gap:12px">
          <div style="flex:1">
            <label style="font-size:12px;color:var(--text-muted);display:block;margin-bottom:4px">머지 대상 (Base)</label>
            <button type="button" class="branch-picker-trigger" id="nsm-base-btn" onclick="_openBranchPicker(this, _nsmBaseValue, v=>{_nsmBaseValue=v;this.querySelector('.bp-label').textContent=v;})">
              <span class="bp-label">선택...</span><span class="bp-arrow">\u25BC</span>
            </button>
          </div>
          <div style="flex:1">
            <label style="font-size:12px;color:var(--text-muted);display:block;margin-bottom:4px">작업 브랜치 (Head)</label>
            <button type="button" class="branch-picker-trigger" id="nsm-head-btn" onclick="_openBranchPicker(this, _nsmHeadValue, v=>{_nsmHeadValue=v;this.querySelector('.bp-label').textContent=v;})">
              <span class="bp-label">선택...</span><span class="bp-arrow">\u25BC</span>
            </button>
          </div>
        </div>
      </div>
      <details id="nsm-context-section" style="margin-top:12px">
        <summary style="cursor:pointer;font-weight:600;font-size:13px;color:var(--text-secondary)">변경 설명 (선택)</summary>
        <div style="margin-top:8px">
          <textarea id="nsm-context-summary" placeholder="이 변경의 목적과 핵심 내용..."
                    rows="3" style="width:100%;resize:vertical;font-size:13px;padding:8px;border:1px solid var(--border);border-radius:6px;background:var(--bg-secondary);color:var(--text-primary);box-sizing:border-box"></textarea>
          <textarea id="nsm-context-decisions" placeholder="의도적 결정 (줄별 하나씩)"
                    rows="2" style="width:100%;resize:vertical;font-size:13px;padding:8px;margin-top:6px;border:1px solid var(--border);border-radius:6px;background:var(--bg-secondary);color:var(--text-primary);box-sizing:border-box"></textarea>
        </div>
      </details>
      <button class="btn btn-primary" id="nsm-submit" onclick="submitNewSession(this)" style="align-self:flex-end" disabled>생성</button>
    </div>
  </div>`;
  document.body.appendChild(overlay);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });

  const repoInput = overlay.querySelector('#nsm-repo-path');
  repoInput.focus();
  let _debounce;
  repoInput.addEventListener('input', () => { clearTimeout(_debounce); _debounce = setTimeout(() => _nsmValidateRepo(), 500); });
  repoInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); _nsmValidateRepo(); } });
  await _nsmRefreshPresets(false);
}

async function _nsmPickRepoPath() {
  const statusEl = document.getElementById('nsm-repo-status');
  const pathInput = document.getElementById('nsm-repo-path');
  if (!statusEl || !pathInput) return;

  statusEl.innerHTML = '<span style="color:var(--text-muted)">폴더 선택기 여는 중...</span>';
  try {
    const pickResult = await _nsmRequestDirectoryPath();
    if (!pickResult.ok) {
      const msg = pickResult.detail || '폴더 선택 실패';
      statusEl.innerHTML = `<span style="color:var(--severity-critical)">\u274C ${esc(msg)}</span>`;
      return;
    }
    const data = pickResult.data || {};
    if (data.cancelled || !data.path) {
      statusEl.innerHTML = '<span style="color:var(--text-muted)">폴더 선택이 취소되었습니다.</span>';
      return;
    }
    pathInput.value = data.path;
    await _nsmValidateRepo();
  } catch (e) {
    statusEl.innerHTML = `<span style="color:var(--severity-critical)">\u274C 폴더 선택 실패: ${esc(e.message)}</span>`;
  }
}

async function _nsmRequestDirectoryPath() {
  const endpoints = ['/api/fs/pick-directory', '/api/pick-directory'];
  let lastDetail = '';

  for (const endpoint of endpoints) {
    try {
      const r = await fetch(endpoint);
      let data = {};
      try {
        data = await r.json();
      } catch (e) {}
      if (r.ok) return { ok: true, data };
      const detail = (data && data.detail) ? String(data.detail) : `${r.status} ${r.statusText}`.trim();
      if (r.status === 404) {
        lastDetail = detail || 'Not found';
        continue;
      }
      return { ok: false, detail: detail || '폴더 선택 실패' };
    } catch (e) {
      lastDetail = e?.message || String(e);
    }
  }

  return {
    ok: false,
    detail: `폴더 선택 API를 찾지 못했습니다. (${lastDetail || 'Not found'})`,
  };
}

async function _nsmValidateRepo() {
  const pathInput = document.getElementById('nsm-repo-path');
  const statusEl = document.getElementById('nsm-repo-status');
  const branchSection = document.getElementById('nsm-branch-section');
  const path = pathInput.value.trim();
  if (!path) {
    statusEl.textContent = '';
    branchSection.style.display = 'none';
    _nsmRepoValidated = false;
    _nsmUpdateSubmitState();
    return;
  }
  statusEl.innerHTML = '<span style="color:var(--text-muted)">검증 중...</span>';
  try {
    const r = await fetch('/api/git/validate', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({path}) });
    const data = await r.json();
    if (!data.valid) {
      statusEl.innerHTML = `<span style="color:var(--severity-critical)">\u274C ${esc(data.error || '유효하지 않은 경로')}</span>`;
      branchSection.style.display = 'none';
      _nsmRepoValidated = false;
      _nsmUpdateSubmitState();
      return;
    }
    pathInput.value = data.root;
    statusEl.innerHTML = `<span style="color:var(--severity-dismissed)">\u2705 유효한 Git 저장소 (${esc(data.current_branch)})</span>`;
    await _nsmLoadBranches(data.root, data.current_branch);
  } catch (e) {
    statusEl.innerHTML = `<span style="color:var(--severity-critical)">\u274C 검증 실패</span>`;
    branchSection.style.display = 'none';
    _nsmRepoValidated = false;
    _nsmUpdateSubmitState();
  }
}

async function _nsmLoadBranches(repoPath, currentBranch) {
  const branchSection = document.getElementById('nsm-branch-section');
  try {
    const r = await fetch(`/api/git/branches?repo_path=${encodeURIComponent(repoPath)}`);
    _nsmBranches = await r.json();

    const locals = _nsmBranches.filter(b => b.type === 'local');
    const remotes = _nsmBranches.filter(b => b.type === 'remote');

    // base default: origin/main > origin/master > main > first
    _nsmBaseValue = remotes.find(b => b.name === 'origin/main')?.name
      || remotes.find(b => b.name === 'origin/master')?.name
      || locals.find(b => b.name === 'main')?.name
      || locals.find(b => b.name === 'master')?.name
      || (_nsmBranches[0]?.name || 'main');
    _nsmHeadValue = currentBranch;

    document.querySelector('#nsm-base-btn .bp-label').textContent = _nsmBaseValue;
    document.querySelector('#nsm-head-btn .bp-label').textContent = _nsmHeadValue;

    branchSection.style.display = '';
    _nsmRepoValidated = true;
    _nsmUpdateSubmitState();
  } catch (e) {
    branchSection.style.display = 'none';
    _nsmRepoValidated = false;
    _nsmUpdateSubmitState();
  }
}

async function submitNewSession(btn) {
  btn.disabled = true;
  const repoPath = document.getElementById('nsm-repo-path').value.trim();
  const base = _nsmBaseValue;
  const head = _nsmHeadValue;
  const presetIds = [..._nsmSelectedPresetIds];
  if (!presetIds.length) {
    alert('최소 1개 프리셋을 선택해주세요.');
    btn.disabled = false;
    return;
  }

  const contextSummary = (document.getElementById('nsm-context-summary')?.value || '').trim();
  const contextDecisions = (document.getElementById('nsm-context-decisions')?.value || '').trim();

  const body = { repo_path: repoPath, base, head, preset_ids: presetIds };

  if (contextSummary || contextDecisions) {
    body.implementation_context = {
      summary: contextSummary || '',
      decisions: contextDecisions ? contextDecisions.split('\n').filter(Boolean) : [],
    };
  }

  try {
    // 1) Create session
    const r = await fetch('/api/sessions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    const data = await r.json();
    if (!r.ok) { alert(data.detail || '세션 생성 실패'); btn.disabled = false; return; }

    // 2) Start review
    const startR = await fetch(`/api/sessions/${data.session_id}/start`, { method: 'POST' });
    if (!startR.ok) { alert('리뷰 시작 실패'); }

    _saveRecentRepo(repoPath);
    btn.closest('.report-overlay').remove();
    await fetchSessions();
    await switchSession(data.session_id);
  } catch (e) {
    alert('세션 생성 실패');
    btn.disabled = false;
  }
}

async function init() {
  const savedUI = _uiRestoreStateFromStorage();
  renderDetailViewBar();
  _ensureDiffHighlighter();
  _loadFileOpeners();
  await fetchSessions();
  renderSessionTabs();

  // Deep link: URL에서 세션/이슈 파싱
  const urlState = router.parse();
  const urlSessionValid = urlState.sessionId && state.sessions.some(s => s.session_id === urlState.sessionId);

  let currentSessionId = null;
  try {
    const r = await fetch('/api/sessions/current/status');
    if (r.ok) {
      const d = await r.json();
      currentSessionId = d.session_id;
      state.status = d.status;
      state.issueNumberById = {};
      state.nextIssueNumber = 1;
    }
  } catch(e) {}

  // URL 딥링크 우선 → localStorage → 서버 현재 세션
  let targetSessionId;
  if (urlSessionValid) {
    targetSessionId = urlState.sessionId;
  } else {
    const savedSessionId = savedUI?.session_id || '';
    const hasSavedSession = !!savedSessionId && state.sessions.some(s => s.session_id === savedSessionId);
    targetSessionId = hasSavedSession ? savedSessionId : currentSessionId;
  }

  if (targetSessionId && targetSessionId !== currentSessionId) {
    state.sessionId = currentSessionId || null;
    renderSessionTabs();
    await switchSession(targetSessionId);
  } else {
    state.sessionId = targetSessionId || null;
    state.humanAssistAccessKey = state.sessionId ? (_humanAssistKeyBySession[state.sessionId] || null) : null;
    renderSessionTabs();
    if (state.sessionId) {
      connectSSE(state.sessionId);
      await pollStatus();
    } else {
      updateStepIndicator();
      startStatusPolling();
    }
  }

  // URL에서 이슈/뷰 모드 복원
  if (urlSessionValid && state.sessionId === urlState.sessionId) {
    if (urlState.issueId) {
      const issueExists = state.issues.some(i => i.id === urlState.issueId);
      if (issueExists) selectIssue(urlState.issueId);
    }
    if (urlState.opinionId) {
      setTimeout(() => _scrollToOpinion(urlState.opinionId), 200);
    }
  }

  // 초기 URL 동기화
  router.sync();
}
init();
</script>
</body>
</html>
