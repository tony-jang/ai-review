{"diff":"diff --git a/backend/api/build.gradle.kts b/backend/api/build.gradle.kts\nindex ed96ec86f..cae8e6167 100644\n--- a/backend/api/build.gradle.kts\n+++ b/backend/api/build.gradle.kts\n@@ -32,6 +32,7 @@ dependencies {\n     // 개발 속도를 위해서 일단 상위 모듈의 의존성을 모두 가진채로 서비스한다.\n     implementation(project(\":mcp:proxy\"))\n     implementation(project(\":mcp:connector-api\"))\n+    implementation(project(\":mcp:grpc\"))\n \n     implementation(project(\":tunnel\"))\n \n@@ -136,7 +137,7 @@ dependencies {\n }\n \n tasks.compileKotlin {\n-    dependsOn(\":common:assemble\", \":mcp:proxy:assemble\", \":mcp:connector-api:assemble\", \":tunnel:assemble\")\n+    dependsOn(\":common:assemble\", \":mcp:proxy:assemble\", \":mcp:connector-api:assemble\", \":mcp:grpc:assemble\", \":tunnel:assemble\")\n }\n \n tasks.withType<Test> {\ndiff --git a/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcAccessKeyVerifierImpl.kt b/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcAccessKeyVerifierImpl.kt\nnew file mode 100644\nindex 000000000..3bb1cef06\n--- /dev/null\n+++ b/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcAccessKeyVerifierImpl.kt\n@@ -0,0 +1,31 @@\n+package com.querypie.duplo.api.preset.proxy.grpc\n+\n+import com.querypie.duplo.api.preset.service.PresetCliService\n+import com.querypie.duplo.mcp.grpc.spi.AccessKeyResult\n+import com.querypie.duplo.mcp.grpc.spi.GrpcAccessKeyVerifier\n+import io.github.oshai.kotlinlogging.KotlinLogging\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty\n+import org.springframework.stereotype.Component\n+\n+private val logger = KotlinLogging.logger {}\n+\n+@Component\n+@ConditionalOnProperty(\"duplo.grpc.enabled\", havingValue = \"true\")\n+internal class GrpcAccessKeyVerifierImpl(\n+    private val presetCliService: PresetCliService,\n+) : GrpcAccessKeyVerifier {\n+\n+    override fun verify(accessKey: String, presetId: String): AccessKeyResult {\n+        return try {\n+            val entity = presetCliService.verifyAccessKey(accessKey)\n+            AccessKeyResult(\n+                valid = true,\n+                userId = entity.userId,\n+                deviceId = entity.deviceId,\n+            )\n+        } catch (e: Exception) {\n+            logger.debug(e) { \"AccessKey verification failed: presetId=$presetId\" }\n+            AccessKeyResult(valid = false)\n+        }\n+    }\n+}\ndiff --git a/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcConnectorProviderImpl.kt b/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcConnectorProviderImpl.kt\nnew file mode 100644\nindex 000000000..598906164\n--- /dev/null\n+++ b/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcConnectorProviderImpl.kt\n@@ -0,0 +1,123 @@\n+package com.querypie.duplo.api.preset.proxy.grpc\n+\n+import com.querypie.duplo.api.audit.service.McpAuditService\n+import com.querypie.duplo.api.payment.service.PaymentService\n+import com.querypie.duplo.api.preset.proxy.McpSessionConfig\n+import com.querypie.duplo.api.preset.proxy.McpSessionConfigResolver\n+import com.querypie.duplo.api.preset.proxy.connector.AgentIntegrationMcpConnectorFactory\n+import com.querypie.duplo.api.preset.proxy.connector.BuiltinMcpConnectorFactory\n+import com.querypie.duplo.api.preset.proxy.connector.PrimaryMcpConnectorFactory\n+import com.querypie.duplo.api.preset.proxy.interceptor.*\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnector\n+import com.querypie.duplo.mcp.connector.api.v2.dsl.intercept\n+import com.querypie.duplo.mcp.grpc.spi.ConnectorSession\n+import com.querypie.duplo.mcp.grpc.spi.GrpcAuthContext\n+import com.querypie.duplo.mcp.grpc.spi.GrpcClientInfo\n+import com.querypie.duplo.mcp.grpc.spi.GrpcConnectorProvider\n+import com.querypie.duplo.mcp.proxy.mcp.ClientInfo\n+import com.querypie.duplo.mcp.proxy.mcp.McpSessionInfo\n+import io.github.oshai.kotlinlogging.KotlinLogging\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty\n+import org.springframework.stereotype.Component\n+import java.util.UUID\n+\n+private val logger = KotlinLogging.logger {}\n+\n+@Component\n+@ConditionalOnProperty(\"duplo.grpc.enabled\", havingValue = \"true\")\n+internal class GrpcConnectorProviderImpl(\n+    private val mcpSessionConfigResolver: McpSessionConfigResolver,\n+    private val primaryMcpConnectorFactory: PrimaryMcpConnectorFactory,\n+    private val agentIntegrationMcpConnectorFactory: AgentIntegrationMcpConnectorFactory,\n+    private val builtinMcpConnectorFactory: BuiltinMcpConnectorFactory,\n+    private val mcpAuditService: McpAuditService,\n+    private val paymentService: PaymentService,\n+) : GrpcConnectorProvider {\n+\n+    override fun createSession(\n+        baseUrl: String,\n+        authContext: GrpcAuthContext,\n+        clientInfo: GrpcClientInfo,\n+    ): ConnectorSession? {\n+        val config = mcpSessionConfigResolver.resolve(baseUrl) ?: return null\n+\n+        val sessionInfo = McpSessionInfo(\n+            id = UUID.randomUUID().toString(),\n+            clientInfo = ClientInfo(\n+                ip = clientInfo.ip,\n+                userAgent = clientInfo.userAgent,\n+                conversationId = clientInfo.conversationId,\n+            ),\n+        )\n+\n+        return when (config) {\n+            is McpSessionConfig.Preset -> createPresetSession(config, sessionInfo, baseUrl)\n+            is McpSessionConfig.AgentIntegration -> createAgentSession(config, sessionInfo, baseUrl)\n+            is McpSessionConfig.Builtin -> createBuiltinSession(config, sessionInfo, baseUrl)\n+        }\n+    }\n+\n+    private fun createPresetSession(config: McpSessionConfig.Preset, sessionInfo: McpSessionInfo, baseUrl: String): ConnectorSession {\n+        val connector = primaryMcpConnectorFactory.create(config.presetEntity, sessionInfo)\n+        val intercepted = applyInterceptors(connector, config.auditContext, config.billingContext, sessionInfo)\n+\n+        return ConnectorSession(\n+            connector = intercepted,\n+            serverName = \"duplo-${config.presetEntity.name}\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = config.presetEntity.prompt,\n+            baseUrl = baseUrl,\n+        )\n+    }\n+\n+    private fun createAgentSession(config: McpSessionConfig.AgentIntegration, sessionInfo: McpSessionInfo, baseUrl: String): ConnectorSession {\n+        val connector = agentIntegrationMcpConnectorFactory.create(config, sessionInfo)\n+        val intercepted = applyInterceptors(connector, config.auditContext, config.billingContext, sessionInfo)\n+\n+        return ConnectorSession(\n+            connector = intercepted,\n+            serverName = \"duplo-agent-${config.installedAgent.installationId}\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = config.installedAgent.description,\n+            baseUrl = baseUrl,\n+        )\n+    }\n+\n+    private fun createBuiltinSession(config: McpSessionConfig.Builtin, sessionInfo: McpSessionInfo, baseUrl: String): ConnectorSession {\n+        val connector = builtinMcpConnectorFactory.create(config)\n+        val intercepted = applyInterceptors(connector, config.auditContext, config.billingContext, sessionInfo)\n+\n+        return ConnectorSession(\n+            connector = intercepted,\n+            serverName = \"duplo-builtin-${config.builtinType.kebabCase}\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = \"\",\n+            baseUrl = baseUrl,\n+        )\n+    }\n+\n+    private fun applyInterceptors(\n+        connector: McpConnector,\n+        auditContext: com.querypie.duplo.api.preset.proxy.McpAuditContext,\n+        billingContext: com.querypie.duplo.api.preset.proxy.McpBillingContext,\n+        sessionInfo: McpSessionInfo,\n+    ): McpConnector {\n+        return try {\n+            connector.intercept {\n+                add(ClientInfoContextInterceptor(sessionInfo.clientInfo))\n+                add(LoggingToolHandlerInterceptor)\n+                add(ErrorHandlingToolHandlerInterceptor)\n+                add(MetadataToolHandlerInterceptor)\n+                add(BillingToolHandlerInterceptor(billingContext, sessionInfo, paymentService))\n+                add(AuditToolHandlerInterceptor(mcpAuditService, auditContext, sessionInfo))\n+                add(ToolCallContextInterceptor(auditContext.integrationBundleId))\n+            }\n+        } catch (t: Throwable) {\n+            connector.close()\n+            throw t\n+        }\n+    }\n+}\ndiff --git a/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/interceptor/ClientInfoContextInterceptor.kt b/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/interceptor/ClientInfoContextInterceptor.kt\nnew file mode 100644\nindex 000000000..58fbfd325\n--- /dev/null\n+++ b/backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/interceptor/ClientInfoContextInterceptor.kt\n@@ -0,0 +1,30 @@\n+package com.querypie.duplo.api.preset.proxy.interceptor\n+\n+import com.querypie.duplo.mcp.connector.api.Mcp\n+import com.querypie.duplo.mcp.connector.api.v2.CallToolRequest\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnector\n+import com.querypie.duplo.mcp.connector.api.v2.ToolHandlerInterceptor\n+import com.querypie.duplo.mcp.proxy.mcp.ClientInfo\n+import com.querypie.duplo.mcp.proxy.mcp.ClientInfoContext\n+\n+/**\n+ * gRPC 경로에서 tool 호출 시 ClientInfoContext ThreadLocal을 설정하는 인터셉터.\n+ * HTTP 경로에서는 서블릿 레벨에서 설정되지만, gRPC 경로에서는 별도 설정이 필요하다.\n+ */\n+class ClientInfoContextInterceptor(\n+    private val clientInfo: ClientInfo,\n+) : ToolHandlerInterceptor {\n+    override fun handle(\n+        mcpConnector: McpConnector,\n+        mcpTool: Mcp.Tool,\n+        request: CallToolRequest,\n+        next: (CallToolRequest) -> Mcp.CallToolResult,\n+    ): Mcp.CallToolResult {\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+        try {\n+            return next(request)\n+        } finally {\n+            ClientInfoContext.clearCurrentClientInfo()\n+        }\n+    }\n+}\ndiff --git a/backend/app/build.gradle.kts b/backend/app/build.gradle.kts\nindex 3319ae993..b8d7a10d7 100644\n--- a/backend/app/build.gradle.kts\n+++ b/backend/app/build.gradle.kts\n@@ -23,6 +23,7 @@ dependencies {\n     implementation(project(\":common\"))\n     implementation(project(\":api\"))\n     implementation(project(\":mcp:proxy\"))\n+    implementation(project(\":mcp:grpc\"))\n     implementation(project(\":tunnel\"))\n \n     // MCP Connector implementations - loaded at runtime\ndiff --git a/backend/app/src/main/resources/application.yaml b/backend/app/src/main/resources/application.yaml\nindex a33597513..3ee9fdfe2 100644\n--- a/backend/app/src/main/resources/application.yaml\n+++ b/backend/app/src/main/resources/application.yaml\n@@ -322,6 +322,10 @@ duplo:\n       image-ttl: '${IMAGE_GENERATION_TTL:24h}'\n   whitelist:\n     api-key: '${BACKEND_WHITELIST_API_KEY}'\n+  # TODO: gRPC 설정은 현재 FF(환경변수)로 제어되지만, 안정화 후 직접 설정으로 전환 필요\n+  grpc:\n+    enabled: ${DUPLO_GRPC_ENABLED:false}\n+    port: ${DUPLO_GRPC_PORT:9091}\n   tunnel:\n     listener:\n       port: 9090\ndiff --git a/backend/buildSrc/build.gradle.kts b/backend/buildSrc/build.gradle.kts\nindex 60dc2e9eb..dde6d2194 100644\n--- a/backend/buildSrc/build.gradle.kts\n+++ b/backend/buildSrc/build.gradle.kts\n@@ -58,6 +58,7 @@ dependencies {\n     implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\")\n \n     implementation(\"org.openapitools:openapi-generator:7.12.0\")\n+    implementation(\"com.google.protobuf:protobuf-gradle-plugin:0.9.5\")\n }\n \n tasks.withType<Test> {\ndiff --git a/backend/gradle/libs.versions.toml b/backend/gradle/libs.versions.toml\nindex 00dbb0219..a5ba569bc 100644\n--- a/backend/gradle/libs.versions.toml\n+++ b/backend/gradle/libs.versions.toml\n@@ -15,6 +15,9 @@ google-api-client = \"2.7.2\"\n ktor = \"3.2.3\"\n retrofit = \"3.0.0\"\n moshi = \"1.15.2\"\n+grpc = \"1.73.0\"\n+protobuf = \"4.31.1\"\n+protobuf-plugin = \"0.9.5\"\n \n # dependency versions\n \n@@ -47,5 +50,16 @@ retrofit = { module = \"com.squareup.retrofit2:retrofit\", version.ref = \"retrofit\n retrofit-converter-scalars = { module = \"com.squareup.retrofit2:converter-scalars\", version.ref = \"retrofit\" }\n retrofit-converter-moshi = { module = \"com.squareup.retrofit2:converter-moshi\", version.ref = \"retrofit\" }\n \n+grpc-bom = { module = \"io.grpc:grpc-bom\", version.ref = \"grpc\" }\n+grpc-protobuf = { module = \"io.grpc:grpc-protobuf\" }\n+grpc-stub = { module = \"io.grpc:grpc-stub\" }\n+grpc-kotlin-stub = { module = \"io.grpc:grpc-kotlin-stub\", version = \"1.4.3\" }\n+grpc-netty-shaded = { module = \"io.grpc:grpc-netty-shaded\" }\n+protobuf-java = { module = \"com.google.protobuf:protobuf-java\", version.ref = \"protobuf\" }\n+protobuf-kotlin = { module = \"com.google.protobuf:protobuf-kotlin\", version.ref = \"protobuf\" }\n+protoc = { module = \"com.google.protobuf:protoc\", version.ref = \"protobuf\" }\n+grpc-protoc-gen-java = { module = \"io.grpc:protoc-gen-grpc-java\", version.ref = \"grpc\" }\n+grpc-protoc-gen-kotlin = { module = \"io.grpc:protoc-gen-grpc-kotlin\", version = \"1.4.3:jdk8@jar\" }\n+\n # Libraries can be bundled together for easier import\n [bundles]\ndiff --git a/backend/mcp/grpc/build.gradle.kts b/backend/mcp/grpc/build.gradle.kts\nnew file mode 100644\nindex 000000000..0ea7db6b5\n--- /dev/null\n+++ b/backend/mcp/grpc/build.gradle.kts\n@@ -0,0 +1,59 @@\n+import com.google.protobuf.gradle.*\n+\n+plugins {\n+    id(\"kotlin-conventions\")\n+    id(\"spring-conventions\")\n+    id(\"testing-conventions\")\n+    id(\"modelcontextprotocol-conventions\")\n+    id(\"com.google.protobuf\")\n+}\n+\n+dependencies {\n+    implementation(platform(libs.grpc.bom))\n+    implementation(libs.grpc.protobuf)\n+    implementation(libs.grpc.stub)\n+    implementation(libs.grpc.kotlin.stub)\n+    implementation(libs.grpc.netty.shaded)\n+    implementation(libs.protobuf.java)\n+    implementation(libs.protobuf.kotlin)\n+    implementation(\"javax.annotation:javax.annotation-api:1.3.2\")\n+\n+    implementation(project(\":mcp:connector-api\"))\n+    implementation(\"io.modelcontextprotocol.sdk:mcp\")\n+\n+    implementation(\"org.springframework.boot:spring-boot-starter\")\n+    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core\")\n+    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n+\n+    testImplementation(\"org.mockito.kotlin:mockito-kotlin\")\n+    testImplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-test\")\n+}\n+\n+protobuf {\n+    protoc {\n+        artifact = libs.protoc.get().toString()\n+    }\n+    plugins {\n+        create(\"grpc\") { artifact = libs.grpc.protoc.gen.java.get().toString() }\n+        create(\"grpckt\") { artifact = libs.grpc.protoc.gen.kotlin.get().toString() }\n+    }\n+    generateProtoTasks {\n+        all().forEach { task ->\n+            task.plugins {\n+                create(\"grpc\")\n+                create(\"grpckt\")\n+            }\n+            task.builtins {\n+                create(\"kotlin\")\n+            }\n+        }\n+    }\n+}\n+\n+sourceSets {\n+    main {\n+        proto {\n+            srcDir(\"${rootProject.projectDir}/../resource/proto\")\n+        }\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerConfig.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerConfig.kt\nnew file mode 100644\nindex 000000000..9529cd4e6\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerConfig.kt\n@@ -0,0 +1,117 @@\n+package com.querypie.duplo.mcp.grpc.config\n+\n+import com.querypie.duplo.mcp.grpc.service.ChannelHandler\n+import com.querypie.duplo.mcp.grpc.service.McpConnectorGrpcService\n+import com.querypie.duplo.mcp.grpc.service.SendHandler\n+import com.querypie.duplo.mcp.grpc.session.GrpcSessionManager\n+import com.querypie.duplo.mcp.grpc.spi.GrpcAccessKeyVerifier\n+import com.querypie.duplo.mcp.grpc.spi.GrpcConnectorProvider\n+import io.github.oshai.kotlinlogging.KotlinLogging\n+import io.grpc.Server\n+import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder\n+import jakarta.annotation.PreDestroy\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty\n+import org.springframework.boot.context.properties.EnableConfigurationProperties\n+import org.springframework.context.annotation.Bean\n+import org.springframework.context.annotation.Configuration\n+import org.springframework.context.event.ContextRefreshedEvent\n+import org.springframework.context.event.EventListener\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+private val logger = KotlinLogging.logger {}\n+\n+@Configuration\n+@ConditionalOnProperty(\"duplo.grpc.enabled\", havingValue = \"true\")\n+@EnableConfigurationProperties(GrpcServerProperties::class)\n+class GrpcServerConfig {\n+\n+    @Bean\n+    fun grpcSessionManager(): GrpcSessionManager = GrpcSessionManager()\n+\n+    @Bean\n+    fun sendHandler(\n+        sessionManager: GrpcSessionManager,\n+        connectorProvider: GrpcConnectorProvider,\n+        accessKeyVerifier: GrpcAccessKeyVerifier,\n+    ): SendHandler = SendHandler(sessionManager, connectorProvider, accessKeyVerifier)\n+\n+    @Bean\n+    fun channelHandler(sessionManager: GrpcSessionManager): ChannelHandler = ChannelHandler(sessionManager)\n+\n+    @Bean\n+    fun mcpConnectorGrpcService(\n+        sendHandler: SendHandler,\n+        channelHandler: ChannelHandler,\n+    ): McpConnectorGrpcService = McpConnectorGrpcService(sendHandler, channelHandler)\n+\n+    @Bean\n+    fun grpcServer(\n+        properties: GrpcServerProperties,\n+        grpcService: McpConnectorGrpcService,\n+        sessionManager: GrpcSessionManager,\n+    ): GrpcServerLifecycle = GrpcServerLifecycle(properties, grpcService, sessionManager)\n+}\n+\n+class GrpcServerLifecycle(\n+    private val properties: GrpcServerProperties,\n+    private val grpcService: McpConnectorGrpcService,\n+    private val sessionManager: GrpcSessionManager,\n+) {\n+    private val started = AtomicBoolean(false)\n+    private var server: Server? = null\n+    private var cleanupScheduler: ScheduledExecutorService? = null\n+\n+    @EventListener(ContextRefreshedEvent::class)\n+    fun start() {\n+        if (!started.compareAndSet(false, true)) return\n+\n+        val maxMessageSize = properties.maxMessageSizeMb * 1024 * 1024\n+        val srv = NettyServerBuilder.forPort(properties.port)\n+            .addService(grpcService)\n+            .maxInboundMessageSize(maxMessageSize)\n+            .build()\n+            .start()\n+\n+        server = srv\n+        logger.info { \"gRPC server started on port ${properties.port}\" }\n+\n+        startSessionCleanup()\n+    }\n+\n+    private fun startSessionCleanup() {\n+        val ttlMinutes = properties.sessionTtlMinutes\n+        if (ttlMinutes <= 0) return\n+\n+        val scheduler = Executors.newSingleThreadScheduledExecutor { r ->\n+            Thread(r, \"grpc-session-cleanup\").apply { isDaemon = true }\n+        }\n+        val ttlMillis = TimeUnit.MINUTES.toMillis(ttlMinutes)\n+        val intervalMinutes = maxOf(ttlMinutes / 2, 1)\n+\n+        scheduler.scheduleAtFixedRate(\n+            { sessionManager.evictExpired(ttlMillis) },\n+            intervalMinutes,\n+            intervalMinutes,\n+            TimeUnit.MINUTES,\n+        )\n+        cleanupScheduler = scheduler\n+        logger.info { \"Session cleanup scheduled: TTL=${ttlMinutes}min, interval=${intervalMinutes}min\" }\n+    }\n+\n+    @PreDestroy\n+    fun stop() {\n+        cleanupScheduler?.shutdown()\n+        server?.let {\n+            logger.info { \"Shutting down gRPC server...\" }\n+            it.shutdown()\n+            if (!it.awaitTermination(30, TimeUnit.SECONDS)) {\n+                logger.warn { \"gRPC server did not terminate in time, forcing shutdown\" }\n+                it.shutdownNow()\n+            }\n+            logger.info { \"gRPC server stopped\" }\n+        }\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerProperties.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerProperties.kt\nnew file mode 100644\nindex 000000000..0afb8b0f0\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerProperties.kt\n@@ -0,0 +1,11 @@\n+package com.querypie.duplo.mcp.grpc.config\n+\n+import org.springframework.boot.context.properties.ConfigurationProperties\n+\n+@ConfigurationProperties(prefix = \"duplo.grpc\")\n+data class GrpcServerProperties(\n+    val enabled: Boolean = false,\n+    val port: Int = 9090,\n+    val maxMessageSizeMb: Int = 16,\n+    val sessionTtlMinutes: Long = 30,\n+)\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConverters.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConverters.kt\nnew file mode 100644\nindex 000000000..c900a2095\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConverters.kt\n@@ -0,0 +1,138 @@\n+package com.querypie.duplo.mcp.grpc.converter\n+\n+import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\n+import com.fasterxml.jackson.module.kotlin.readValue\n+import com.google.protobuf.ListValue\n+import com.google.protobuf.NullValue\n+import com.google.protobuf.Struct\n+import com.google.protobuf.Value\n+import com.querypie.duplo.mcp.connector.api.Mcp\n+import com.querypie.duplo.mcp.connector.api.v2.CallToolRequest\n+import io.modelcontextprotocol.spec.McpSchema\n+import io.querypie.duplo.mcp.v1.CallToolPayload\n+import io.querypie.duplo.mcp.v1.callToolResult\n+import io.querypie.duplo.mcp.v1.content\n+import io.querypie.duplo.mcp.v1.imageContent\n+import io.querypie.duplo.mcp.v1.loggingMessageEvent\n+import io.querypie.duplo.mcp.v1.progressNotification\n+import io.querypie.duplo.mcp.v1.textContent\n+import io.querypie.duplo.mcp.v1.tool\n+import io.querypie.duplo.mcp.v1.CallToolResult as ProtoCallToolResult\n+import io.querypie.duplo.mcp.v1.LoggingMessageEvent as ProtoLoggingMessageEvent\n+import io.querypie.duplo.mcp.v1.ProgressNotification as ProtoProgressNotification\n+import io.querypie.duplo.mcp.v1.Tool as ProtoTool\n+\n+private val objectMapper = jacksonObjectMapper()\n+\n+fun Mcp.Tool.toProto(): ProtoTool = tool {\n+    name = this@toProto.name\n+    description = this@toProto.description\n+    inputSchemaJson = this@toProto.inputSchema\n+    displayedDescription = this@toProto.displayedDescription ?: \"\"\n+    integrationId = this@toProto.integrationId ?: \"\"\n+    integrationName = this@toProto.integrationName ?: \"\"\n+    installedIntegrationId = this@toProto.installedIntegrationId ?: \"\"\n+    installedIntegrationName = this@toProto.installedIntegrationName ?: \"\"\n+    if (this@toProto.meta.isNotEmpty()) {\n+        meta = this@toProto.meta.toProtoStruct()\n+    }\n+}\n+\n+fun CallToolPayload.toCallToolRequest(): CallToolRequest {\n+    val args: Map<String, Any?> = if (argumentsJson.isBlank()) {\n+        emptyMap()\n+    } else {\n+        objectMapper.readValue(argumentsJson)\n+    }\n+    return CallToolRequest(\n+        name = name,\n+        arguments = args,\n+        meta = if (hasMeta()) meta.toMap() else emptyMap(),\n+    )\n+}\n+\n+fun Mcp.CallToolResult.toProto(): ProtoCallToolResult = callToolResult {\n+    this@toProto.content.forEach { c ->\n+        content += c.toProto()\n+    }\n+    isError = this@toProto.isError\n+    this@toProto.meta?.takeIf { it.isNotEmpty() }?.let {\n+        meta = it.toProtoStruct()\n+    }\n+}\n+\n+fun McpSchema.ProgressNotification.toProto(): ProtoProgressNotification {\n+    val src = this\n+    return progressNotification {\n+        progressToken = src.progressToken() ?: \"\"\n+        src.progress()?.let { progress = it }\n+        src.total()?.let { total = it }\n+        message = src.message() ?: \"\"\n+    }\n+}\n+\n+fun McpSchema.LoggingMessageNotification.toProto(): ProtoLoggingMessageEvent {\n+    val src = this\n+    return loggingMessageEvent {\n+        level = src.level()?.name?.lowercase() ?: \"\"\n+        logger = src.logger() ?: \"\"\n+        dataJson = src.data() ?: \"\"\n+    }\n+}\n+\n+private fun Mcp.Content.toProto(): io.querypie.duplo.mcp.v1.Content = content {\n+    when (val c = this@toProto) {\n+        is Mcp.Content.TextContent -> text = textContent { text = c.text }\n+        is Mcp.Content.ImageContent -> image = imageContent {\n+            data = c.data\n+            mimeType = c.mimeType\n+        }\n+    }\n+}\n+\n+// --- Map ↔ google.protobuf.Struct conversion ---\n+\n+fun Map<String, Any>.toProtoStruct(): Struct {\n+    val builder = Struct.newBuilder()\n+    forEach { (key, value) -> builder.putFields(key, value.toProtoValue()) }\n+    return builder.build()\n+}\n+\n+private fun Any?.toProtoValue(): Value {\n+    val builder = Value.newBuilder()\n+    when (this) {\n+        null -> builder.nullValue = NullValue.NULL_VALUE\n+        is String -> builder.stringValue = this\n+        is Number -> builder.numberValue = this.toDouble()\n+        is Boolean -> builder.boolValue = this\n+        is Map<*, *> -> {\n+            @Suppress(\"UNCHECKED_CAST\")\n+            builder.structValue = (this as Map<String, Any>).toProtoStruct()\n+        }\n+        is List<*> -> {\n+            val listBuilder = ListValue.newBuilder()\n+            forEach { listBuilder.addValues(it.toProtoValue()) }\n+            builder.listValue = listBuilder.build()\n+        }\n+        else -> builder.stringValue = this.toString()\n+    }\n+    return builder.build()\n+}\n+\n+fun Struct.toMap(): Map<String, Any> {\n+    val result = mutableMapOf<String, Any>()\n+    fieldsMap.forEach { (key, value) ->\n+        value.toKotlinValue()?.let { result[key] = it }\n+    }\n+    return result\n+}\n+\n+private fun Value.toKotlinValue(): Any? = when (kindCase) {\n+    Value.KindCase.NULL_VALUE -> null\n+    Value.KindCase.NUMBER_VALUE -> numberValue\n+    Value.KindCase.STRING_VALUE -> stringValue\n+    Value.KindCase.BOOL_VALUE -> boolValue\n+    Value.KindCase.STRUCT_VALUE -> structValue.toMap()\n+    Value.KindCase.LIST_VALUE -> listValue.valuesList.map { it.toKotlinValue() }\n+    Value.KindCase.KIND_NOT_SET, null -> null\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandler.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandler.kt\nnew file mode 100644\nindex 000000000..a06e75ece\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandler.kt\n@@ -0,0 +1,152 @@\n+package com.querypie.duplo.mcp.grpc.service\n+\n+import com.querypie.duplo.mcp.connector.api.v2.dsl.McpConnectorEventSubscription\n+import com.querypie.duplo.mcp.connector.api.v2.dsl.subscribe\n+import com.querypie.duplo.mcp.grpc.converter.toCallToolRequest\n+import com.querypie.duplo.mcp.grpc.converter.toProto\n+import com.querypie.duplo.mcp.grpc.session.GrpcSessionManager\n+import com.querypie.duplo.mcp.grpc.session.SessionRemoveListener\n+import io.github.oshai.kotlinlogging.KotlinLogging\n+import io.querypie.duplo.mcp.v1.ChannelRequest\n+import io.querypie.duplo.mcp.v1.ChannelResponse\n+import io.querypie.duplo.mcp.v1.channelResponse\n+import io.querypie.duplo.mcp.v1.errorResponse\n+import io.querypie.duplo.mcp.v1.pongPayload\n+import io.querypie.duplo.mcp.v1.toolListChangedEvent\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.channelFlow\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.withContext\n+import java.util.concurrent.ConcurrentHashMap\n+\n+private val logger = KotlinLogging.logger {}\n+\n+class ChannelHandler(\n+    private val sessionManager: GrpcSessionManager,\n+) {\n+    fun handle(requests: Flow<ChannelRequest>): Flow<ChannelResponse> = channelFlow {\n+        val subscriptions = ConcurrentHashMap<String, McpConnectorEventSubscription>()\n+        val removeListener = SessionRemoveListener { sessionId ->\n+            subscriptions.remove(sessionId)?.unsubscribe()\n+        }\n+        sessionManager.addRemoveListener(removeListener)\n+        try {\n+            requests.collect { request ->\n+                when (request.payloadCase) {\n+                    ChannelRequest.PayloadCase.PING -> {\n+                        send(channelResponse {\n+                            sessionId = request.sessionId\n+                            requestId = request.requestId\n+                            pong = pongPayload {}\n+                        })\n+                    }\n+\n+                    ChannelRequest.PayloadCase.CALL_TOOL -> {\n+                        launch { handleCallTool(request)?.let { send(it) } }\n+                    }\n+\n+                    ChannelRequest.PayloadCase.SUBSCRIBE_EVENTS -> {\n+                        val sid = request.sessionId\n+                        val session = sessionManager.get(sid)\n+                        if (session == null) {\n+                            send(errorResponse(request, GrpcErrorCodes.INVALID_PARAMS, \"Session not found: $sid\"))\n+                            return@collect\n+                        }\n+\n+                        subscriptions.remove(sid)?.unsubscribe()\n+\n+                        val subscription = session.connector.subscribe {\n+                            onToolListChanged { _, _ ->\n+                                val result = trySend(channelResponse {\n+                                    sessionId = sid\n+                                    toolListChanged = toolListChangedEvent {}\n+                                })\n+                                if (result.isFailure) {\n+                                    logger.debug { \"Failed to send ToolListChanged for session=$sid\" }\n+                                }\n+                            }\n+                            onProgress { n ->\n+                                val result = trySend(channelResponse {\n+                                    sessionId = sid\n+                                    progress = n.toProto()\n+                                })\n+                                if (result.isFailure) {\n+                                    logger.debug { \"Failed to send Progress for session=$sid\" }\n+                                }\n+                            }\n+                            onLoggingMessage { n ->\n+                                val result = trySend(channelResponse {\n+                                    sessionId = sid\n+                                    loggingMessage = n.toProto()\n+                                })\n+                                if (result.isFailure) {\n+                                    logger.debug { \"Failed to send LoggingMessage for session=$sid\" }\n+                                }\n+                            }\n+                        }\n+                        subscriptions[sid] = subscription\n+                        logger.debug { \"SubscribeEvents for session=$sid\" }\n+                    }\n+\n+                    ChannelRequest.PayloadCase.UNSUBSCRIBE_EVENTS -> {\n+                        val sid = request.sessionId\n+                        subscriptions.remove(sid)?.unsubscribe()\n+                        logger.debug { \"UnsubscribeEvents for session=$sid\" }\n+                    }\n+\n+                    ChannelRequest.PayloadCase.ERROR -> {\n+                        logger.warn { \"Received error from proxy: session=${request.sessionId}, error=${request.error.message}\" }\n+                    }\n+\n+                    ChannelRequest.PayloadCase.PAYLOAD_NOT_SET, null -> {\n+                        send(errorResponse(request, GrpcErrorCodes.INVALID_REQUEST, \"Empty channel payload\"))\n+                    }\n+                }\n+            }\n+        } finally {\n+            sessionManager.removeRemoveListener(removeListener)\n+            subscriptions.values.forEach { runCatching { it.unsubscribe() } }\n+            subscriptions.clear()\n+        }\n+    }\n+\n+    private suspend fun handleCallTool(request: ChannelRequest): ChannelResponse? {\n+        val sessionId = request.sessionId\n+        val session = sessionManager.get(sessionId)\n+            ?: return errorResponse(request, GrpcErrorCodes.INVALID_PARAMS, \"Session not found: $sessionId\")\n+\n+        val payload = request.callTool\n+        val toolHandler = session.connector.findToolHandler(payload.name)\n+            ?: return errorResponse(request, GrpcErrorCodes.METHOD_NOT_FOUND, \"Tool not found: ${payload.name}\")\n+\n+        val callToolRequest = payload.toCallToolRequest()\n+\n+        return try {\n+            val result = withContext(Dispatchers.IO) {\n+                toolHandler.handle(callToolRequest)\n+            }\n+\n+            channelResponse {\n+                this.sessionId = sessionId\n+                requestId = request.requestId\n+                callToolResult = result.toProto()\n+            }\n+        } catch (e: Exception) {\n+            logger.error(e) { \"Tool execution failed: tool=${payload.name}, session=$sessionId\" }\n+            errorResponse(request, GrpcErrorCodes.INTERNAL_ERROR, \"Tool execution failed: ${e.message}\")\n+        }\n+    }\n+\n+    companion object {\n+        private fun errorResponse(request: ChannelRequest, code: Int, message: String): ChannelResponse =\n+            channelResponse {\n+                sessionId = request.sessionId\n+                requestId = request.requestId\n+                error = errorResponse {\n+                    this.code = code\n+                    this.message = message\n+                }\n+            }\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/GrpcErrorCodes.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/GrpcErrorCodes.kt\nnew file mode 100644\nindex 000000000..53e204bcc\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/GrpcErrorCodes.kt\n@@ -0,0 +1,19 @@\n+package com.querypie.duplo.mcp.grpc.service\n+\n+/**\n+ * JSON-RPC 2.0 표준 에러 코드.\n+ * @see <a href=\"https://www.jsonrpc.org/specification#error_object\">JSON-RPC 2.0 Specification</a>\n+ */\n+object GrpcErrorCodes {\n+    /** 요청 페이로드가 비어있거나 해석 불가 */\n+    const val INVALID_REQUEST = -32600\n+\n+    /** 요청한 tool을 찾을 수 없음 */\n+    const val METHOD_NOT_FOUND = -32601\n+\n+    /** session_id 등 파라미터가 유효하지 않음 (세션 없음 등) */\n+    const val INVALID_PARAMS = -32602\n+\n+    /** 내부 서버 에러 (예외 발생) */\n+    const val INTERNAL_ERROR = -32603\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/McpConnectorGrpcService.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/McpConnectorGrpcService.kt\nnew file mode 100644\nindex 000000000..7172cc3d6\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/McpConnectorGrpcService.kt\n@@ -0,0 +1,22 @@\n+package com.querypie.duplo.mcp.grpc.service\n+\n+import io.querypie.duplo.mcp.v1.ChannelRequest\n+import io.querypie.duplo.mcp.v1.ChannelResponse\n+import io.querypie.duplo.mcp.v1.McpConnectorServiceGrpcKt\n+import io.querypie.duplo.mcp.v1.SendRequest\n+import io.querypie.duplo.mcp.v1.SendResponse\n+import kotlinx.coroutines.flow.Flow\n+\n+class McpConnectorGrpcService(\n+    private val sendHandler: SendHandler,\n+    private val channelHandler: ChannelHandler,\n+) : McpConnectorServiceGrpcKt.McpConnectorServiceCoroutineImplBase() {\n+\n+    override suspend fun send(request: SendRequest): SendResponse {\n+        return sendHandler.handle(request)\n+    }\n+\n+    override fun channel(requests: Flow<ChannelRequest>): Flow<ChannelResponse> {\n+        return channelHandler.handle(requests)\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandler.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandler.kt\nnew file mode 100644\nindex 000000000..b4ae2d745\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandler.kt\n@@ -0,0 +1,231 @@\n+package com.querypie.duplo.mcp.grpc.service\n+\n+import com.querypie.duplo.mcp.grpc.converter.toCallToolRequest\n+import com.querypie.duplo.mcp.grpc.converter.toProto\n+import com.querypie.duplo.mcp.grpc.session.GrpcSessionManager\n+import com.querypie.duplo.mcp.grpc.spi.GrpcAccessKeyVerifier\n+import com.querypie.duplo.mcp.grpc.spi.GrpcAuthContext\n+import com.querypie.duplo.mcp.grpc.spi.GrpcClientInfo\n+import com.querypie.duplo.mcp.grpc.spi.GrpcConnectorProvider\n+import io.github.oshai.kotlinlogging.KotlinLogging\n+import io.querypie.duplo.mcp.v1.AuthMethod\n+import io.querypie.duplo.mcp.v1.SendRequest\n+import io.querypie.duplo.mcp.v1.SendResponse\n+import io.querypie.duplo.mcp.v1.SessionExistence\n+import io.querypie.duplo.mcp.v1.closeSessionResponse\n+import io.querypie.duplo.mcp.v1.createSessionResponse\n+import io.querypie.duplo.mcp.v1.deleteSessionResponse\n+import io.querypie.duplo.mcp.v1.errorResponse\n+import io.querypie.duplo.mcp.v1.listToolsResponse\n+import io.querypie.duplo.mcp.v1.querySessionResponse\n+import io.querypie.duplo.mcp.v1.sendNotificationResponse\n+import io.querypie.duplo.mcp.v1.sendResponse\n+import io.querypie.duplo.mcp.v1.serverCapabilities\n+import io.querypie.duplo.mcp.v1.serverInfo\n+import io.querypie.duplo.mcp.v1.toolsCapability\n+import io.querypie.duplo.mcp.v1.verifyAccessKeyResponse\n+\n+private val logger = KotlinLogging.logger {}\n+\n+class SendHandler(\n+    private val sessionManager: GrpcSessionManager,\n+    private val connectorProvider: GrpcConnectorProvider,\n+    private val accessKeyVerifier: GrpcAccessKeyVerifier,\n+) {\n+    fun handle(request: SendRequest): SendResponse = when (request.payloadCase) {\n+        SendRequest.PayloadCase.CREATE_SESSION -> handleCreateSession(request)\n+        SendRequest.PayloadCase.LIST_TOOLS -> handleListTools(request)\n+        SendRequest.PayloadCase.CLOSE_SESSION -> handleCloseSession(request)\n+        SendRequest.PayloadCase.QUERY_SESSION -> handleQuerySession(request)\n+        SendRequest.PayloadCase.DELETE_SESSION -> handleDeleteSession(request)\n+        SendRequest.PayloadCase.VERIFY_ACCESS_KEY -> handleVerifyAccessKey(request)\n+        SendRequest.PayloadCase.SEND_NOTIFICATION -> handleSendNotification(request)\n+        SendRequest.PayloadCase.CALL_TOOL -> handleCallTool(request)\n+        SendRequest.PayloadCase.PAYLOAD_NOT_SET, null -> errorResponse(GrpcErrorCodes.INVALID_REQUEST, \"Empty payload\")\n+    }\n+\n+    private fun handleCreateSession(request: SendRequest): SendResponse {\n+        val req = request.createSession\n+\n+        if (req.sessionId.isBlank()) {\n+            return errorResponse(GrpcErrorCodes.INVALID_PARAMS, \"session_id is required\")\n+        }\n+        val sessionId = req.sessionId\n+\n+        val authCtx = req.authContext\n+        val clientInfo = req.clientInfo\n+\n+        val authContext = GrpcAuthContext(\n+            userId = authCtx.userId,\n+            authMethod = authCtx.authMethod.toReadableString(),\n+            metadata = authCtx.metadataMap,\n+        )\n+        val grpcClientInfo = GrpcClientInfo(\n+            ip = clientInfo.ip,\n+            userAgent = clientInfo.userAgent,\n+            conversationId = clientInfo.conversationId,\n+            mcpClientName = req.mcpClientInfo.name,\n+            mcpClientVersion = req.mcpClientInfo.version,\n+        )\n+\n+        val session = try {\n+            connectorProvider.createSession(req.baseUrl, authContext, grpcClientInfo)\n+        } catch (e: Exception) {\n+            logger.error(e) { \"Failed to create session for baseUrl=${req.baseUrl}\" }\n+            return errorResponse(GrpcErrorCodes.INTERNAL_ERROR, \"Failed to create session: ${e.message}\")\n+        }\n+\n+        if (session == null) {\n+            return errorResponse(GrpcErrorCodes.INVALID_PARAMS, \"Cannot resolve session config for: ${req.baseUrl}\")\n+        }\n+        sessionManager.remove(sessionId)\n+        sessionManager.put(sessionId, session)\n+\n+        val tools = try {\n+            session.connector.getTools()\n+        } catch (e: Exception) {\n+            logger.error(e) { \"Failed to load initial tools for session $sessionId, removing session\" }\n+            sessionManager.remove(sessionId)\n+            return errorResponse(GrpcErrorCodes.INTERNAL_ERROR, \"Session created but failed to initialize: ${e.message}\")\n+        }\n+\n+        return sendResponse {\n+            createSession = createSessionResponse {\n+                this.sessionId = sessionId\n+                this.serverInfo = serverInfo {\n+                    name = session.serverName\n+                    version = session.serverVersion\n+                }\n+                protocolVersion = req.protocolVersion.ifBlank { \"2025-03-26\" }\n+                instructions = session.instructions\n+                serverCapabilities = serverCapabilities {\n+                    this.tools = toolsCapability { listChanged = session.toolsListChanged }\n+                }\n+                tools.forEach { tool -> this.tools += tool.toProto() }\n+            }\n+        }\n+    }\n+\n+    private fun handleListTools(request: SendRequest): SendResponse {\n+        val req = request.listTools\n+        val session = sessionManager.get(req.sessionId)\n+            ?: return errorResponse(GrpcErrorCodes.INVALID_PARAMS, \"Session not found: ${req.sessionId}\")\n+\n+        val tools = session.connector.getTools()\n+        return sendResponse {\n+            listTools = listToolsResponse {\n+                tools.forEach { tool -> this.tools += tool.toProto() }\n+            }\n+        }\n+    }\n+\n+    private fun handleCloseSession(request: SendRequest): SendResponse {\n+        val req = request.closeSession\n+        sessionManager.remove(req.sessionId)\n+        return sendResponse { closeSession = closeSessionResponse {} }\n+    }\n+\n+    private fun handleQuerySession(request: SendRequest): SendResponse {\n+        val req = request.querySession\n+        val exists = sessionManager.exists(req.sessionId)\n+        return sendResponse {\n+            querySession = querySessionResponse {\n+                existence = if (exists) {\n+                    SessionExistence.SESSION_EXISTENCE_EXISTS\n+                } else {\n+                    SessionExistence.SESSION_EXISTENCE_NOT_EXISTS\n+                }\n+            }\n+        }\n+    }\n+\n+    private fun handleDeleteSession(request: SendRequest): SendResponse {\n+        val req = request.deleteSession\n+        val count = when (req.targetCase) {\n+            io.querypie.duplo.mcp.v1.DeleteSessionRequest.TargetCase.SESSION_ID -> {\n+                if (sessionManager.remove(req.sessionId) != null) 1 else 0\n+            }\n+            io.querypie.duplo.mcp.v1.DeleteSessionRequest.TargetCase.AGENT_INSTALLATION_ID -> {\n+                val agentInstallationId = req.agentInstallationId\n+                if (agentInstallationId.isBlank()) {\n+                    0\n+                } else {\n+                    val segment = \"/$agentInstallationId/\"\n+                    val removed = sessionManager.removeAll { _, session ->\n+                        session.baseUrl.contains(segment)\n+                    }\n+                    removed.size\n+                }\n+            }\n+            io.querypie.duplo.mcp.v1.DeleteSessionRequest.TargetCase.TARGET_NOT_SET, null -> 0\n+        }\n+\n+        return sendResponse {\n+            deleteSession = deleteSessionResponse { deletedCount = count }\n+        }\n+    }\n+\n+    private fun handleVerifyAccessKey(request: SendRequest): SendResponse {\n+        val req = request.verifyAccessKey\n+        val result = try {\n+            accessKeyVerifier.verify(req.accessKey, req.presetId)\n+        } catch (e: Exception) {\n+            logger.error(e) { \"AccessKey verification failed\" }\n+            return sendResponse {\n+                verifyAccessKey = verifyAccessKeyResponse { valid = false }\n+            }\n+        }\n+\n+        return sendResponse {\n+            verifyAccessKey = verifyAccessKeyResponse {\n+                valid = result.valid\n+                userId = result.userId\n+                deviceId = result.deviceId\n+            }\n+        }\n+    }\n+\n+    private fun handleCallTool(request: SendRequest): SendResponse {\n+        val req = request.callTool\n+        val session = sessionManager.get(req.sessionId)\n+            ?: return errorResponse(GrpcErrorCodes.INVALID_PARAMS, \"Session not found: ${req.sessionId}\")\n+\n+        val payload = req.payload\n+        val toolHandler = session.connector.findToolHandler(payload.name)\n+            ?: return errorResponse(GrpcErrorCodes.METHOD_NOT_FOUND, \"Tool not found: ${payload.name}\")\n+\n+        val callToolRequest = payload.toCallToolRequest()\n+\n+        return try {\n+            val result = toolHandler.handle(callToolRequest)\n+            sendResponse { callTool = result.toProto() }\n+        } catch (e: Exception) {\n+            logger.error(e) { \"Tool execution failed: tool=${payload.name}, session=${req.sessionId}\" }\n+            errorResponse(GrpcErrorCodes.INTERNAL_ERROR, \"Tool execution failed: ${e.message}\")\n+        }\n+    }\n+\n+    private fun handleSendNotification(request: SendRequest): SendResponse {\n+        val req = request.sendNotification\n+        if (req.sessionId.isNotBlank() && !sessionManager.exists(req.sessionId)) {\n+            return errorResponse(GrpcErrorCodes.INVALID_PARAMS, \"Session not found: ${req.sessionId}\")\n+        }\n+        logger.debug { \"Received notification: method=${req.method}, session=${req.sessionId}\" }\n+        return sendResponse { sendNotification = sendNotificationResponse {} }\n+    }\n+\n+    private fun AuthMethod.toReadableString(): String = when (this) {\n+        AuthMethod.AUTH_METHOD_OAUTH -> \"oauth\"\n+        AuthMethod.AUTH_METHOD_HTTP_SIGNATURE -> \"http_signature\"\n+        else -> \"unspecified\"\n+    }\n+\n+    companion object {\n+        private fun errorResponse(code: Int, message: String): SendResponse = sendResponse {\n+            error = errorResponse {\n+                this.code = code\n+                this.message = message\n+            }\n+        }\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManager.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManager.kt\nnew file mode 100644\nindex 000000000..d5f757264\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManager.kt\n@@ -0,0 +1,92 @@\n+package com.querypie.duplo.mcp.grpc.session\n+\n+import com.querypie.duplo.mcp.grpc.spi.ConnectorSession\n+import io.github.oshai.kotlinlogging.KotlinLogging\n+import java.util.UUID\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.CopyOnWriteArrayList\n+\n+private val logger = KotlinLogging.logger {}\n+\n+fun interface SessionRemoveListener {\n+    fun onSessionRemoved(sessionId: String)\n+}\n+\n+class GrpcSessionManager {\n+    private val sessions = ConcurrentHashMap<String, ConnectorSession>()\n+    private val lastAccessed = ConcurrentHashMap<String, Long>()\n+    private val removeListeners = CopyOnWriteArrayList<SessionRemoveListener>()\n+\n+    fun generateSessionId(): String = UUID.randomUUID().toString()\n+\n+    fun put(sessionId: String, session: ConnectorSession) {\n+        sessions[sessionId] = session\n+        lastAccessed[sessionId] = System.currentTimeMillis()\n+    }\n+\n+    fun get(sessionId: String): ConnectorSession? {\n+        val session = sessions[sessionId] ?: return null\n+        lastAccessed[sessionId] = System.currentTimeMillis()\n+        return session\n+    }\n+\n+    fun exists(sessionId: String): Boolean = sessions.containsKey(sessionId)\n+\n+    fun addRemoveListener(listener: SessionRemoveListener) {\n+        removeListeners.add(listener)\n+    }\n+\n+    fun removeRemoveListener(listener: SessionRemoveListener) {\n+        removeListeners.remove(listener)\n+    }\n+\n+    fun remove(sessionId: String): ConnectorSession? {\n+        val session = sessions.remove(sessionId) ?: return null\n+        lastAccessed.remove(sessionId)\n+        notifyRemoved(sessionId)\n+        runCatching { session.connector.close() }\n+        return session\n+    }\n+\n+    fun removeAll(predicate: (String, ConnectorSession) -> Boolean): List<ConnectorSession> {\n+        val toRemove = sessions.entries.filter { (id, session) -> predicate(id, session) }\n+        val removed = mutableListOf<ConnectorSession>()\n+        for ((id, session) in toRemove) {\n+            if (sessions.remove(id, session)) {\n+                lastAccessed.remove(id)\n+                notifyRemoved(id)\n+                runCatching { session.connector.close() }\n+                removed.add(session)\n+            }\n+        }\n+        return removed\n+    }\n+\n+    fun evictExpired(ttlMillis: Long): Int {\n+        val now = System.currentTimeMillis()\n+        val expiredIds = lastAccessed.entries\n+            .filter { (_, ts) -> now - ts > ttlMillis }\n+            .map { it.key }\n+            .filter { sessions.containsKey(it) }\n+\n+        var count = 0\n+        for (sessionId in expiredIds) {\n+            remove(sessionId)?.let {\n+                logger.info { \"Evicted expired session: $sessionId\" }\n+                count++\n+            }\n+        }\n+        return count\n+    }\n+\n+    /** Test-only: override lastAccessed timestamp */\n+    internal fun setLastAccessedForTest(sessionId: String, timestamp: Long) {\n+        lastAccessed[sessionId] = timestamp\n+    }\n+\n+    private fun notifyRemoved(sessionId: String) {\n+        removeListeners.forEach { listener ->\n+            runCatching { listener.onSessionRemoved(sessionId) }\n+        }\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcAccessKeyVerifier.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcAccessKeyVerifier.kt\nnew file mode 100644\nindex 000000000..f24d28a28\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcAccessKeyVerifier.kt\n@@ -0,0 +1,15 @@\n+package com.querypie.duplo.mcp.grpc.spi\n+\n+/**\n+ * CLI AccessKey 검증을 위한 SPI.\n+ * `api` 모듈에서 구현을 제공한다.\n+ */\n+fun interface GrpcAccessKeyVerifier {\n+    fun verify(accessKey: String, presetId: String): AccessKeyResult\n+}\n+\n+data class AccessKeyResult(\n+    val valid: Boolean,\n+    val userId: String = \"\",\n+    val deviceId: String = \"\",\n+)\ndiff --git a/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcConnectorProvider.kt b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcConnectorProvider.kt\nnew file mode 100644\nindex 000000000..74e02c751\n--- /dev/null\n+++ b/backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcConnectorProvider.kt\n@@ -0,0 +1,38 @@\n+package com.querypie.duplo.mcp.grpc.spi\n+\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnector\n+\n+/**\n+ * gRPC 세션 생성 시 커넥터를 생성하는 SPI.\n+ * `api` 모듈에서 구현을 제공한다.\n+ */\n+interface GrpcConnectorProvider {\n+    fun createSession(\n+        baseUrl: String,\n+        authContext: GrpcAuthContext,\n+        clientInfo: GrpcClientInfo,\n+    ): ConnectorSession?\n+}\n+\n+data class GrpcAuthContext(\n+    val userId: String,\n+    val authMethod: String,\n+    val metadata: Map<String, String>,\n+)\n+\n+data class GrpcClientInfo(\n+    val ip: String,\n+    val userAgent: String,\n+    val conversationId: String,\n+    val mcpClientName: String,\n+    val mcpClientVersion: String,\n+)\n+\n+data class ConnectorSession(\n+    val connector: McpConnector,\n+    val serverName: String,\n+    val serverVersion: String,\n+    val toolsListChanged: Boolean,\n+    val instructions: String,\n+    val baseUrl: String = \"\",\n+)\ndiff --git a/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConvertersTest.kt b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConvertersTest.kt\nnew file mode 100644\nindex 000000000..aec41b9c8\n--- /dev/null\n+++ b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConvertersTest.kt\n@@ -0,0 +1,357 @@\n+package com.querypie.duplo.mcp.grpc.converter\n+\n+import com.google.protobuf.NullValue\n+import com.google.protobuf.Struct\n+import com.google.protobuf.Value\n+import com.querypie.duplo.mcp.connector.api.Mcp\n+import io.modelcontextprotocol.spec.McpSchema\n+import io.querypie.duplo.mcp.v1.CallToolPayload\n+import io.querypie.duplo.mcp.v1.callToolPayload\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+\n+class ProtoConvertersTest {\n+\n+    @Test\n+    fun `Mcp Tool to proto Tool`() {\n+        val mcpTool = Mcp.Tool(\n+            name = \"weather\",\n+            description = \"Get weather\",\n+            inputSchema = \"\"\"{\"type\":\"object\",\"properties\":{\"city\":{\"type\":\"string\"}}}\"\"\",\n+            integrationId = \"int-1\",\n+            integrationName = \"Weather API\",\n+            installedIntegrationId = \"inst-1\",\n+            installedIntegrationName = \"My Weather\",\n+            displayedDescription = \"Get current weather\",\n+        )\n+\n+        val proto = mcpTool.toProto()\n+\n+        assertEquals(\"weather\", proto.name)\n+        assertEquals(\"Get weather\", proto.description)\n+        assertEquals(\"\"\"{\"type\":\"object\",\"properties\":{\"city\":{\"type\":\"string\"}}}\"\"\", proto.inputSchemaJson)\n+        assertEquals(\"int-1\", proto.integrationId)\n+        assertEquals(\"Weather API\", proto.integrationName)\n+        assertEquals(\"inst-1\", proto.installedIntegrationId)\n+        assertEquals(\"My Weather\", proto.installedIntegrationName)\n+        assertEquals(\"Get current weather\", proto.displayedDescription)\n+    }\n+\n+    @Test\n+    fun `Mcp Tool with null optional fields to proto Tool`() {\n+        val mcpTool = Mcp.Tool(\n+            name = \"test\",\n+            description = \"A test tool\",\n+        )\n+\n+        val proto = mcpTool.toProto()\n+\n+        assertEquals(\"test\", proto.name)\n+        assertEquals(\"A test tool\", proto.description)\n+        assertEquals(\"\", proto.integrationId)\n+        assertEquals(\"\", proto.integrationName)\n+    }\n+\n+    @Test\n+    fun `CallToolPayload to CallToolRequest`() {\n+        val payload = callToolPayload {\n+            name = \"test-tool\"\n+            argumentsJson = \"\"\"{\"key\":\"value\",\"num\":42}\"\"\"\n+        }\n+\n+        val request = payload.toCallToolRequest()\n+\n+        assertEquals(\"test-tool\", request.name)\n+        assertEquals(\"value\", request.arguments[\"key\"])\n+        assertEquals(42, request.arguments[\"num\"])\n+    }\n+\n+    @Test\n+    fun `CallToolPayload with empty arguments`() {\n+        val payload = callToolPayload {\n+            name = \"simple-tool\"\n+            argumentsJson = \"\"\n+        }\n+\n+        val request = payload.toCallToolRequest()\n+\n+        assertEquals(\"simple-tool\", request.name)\n+        assertTrue(request.arguments.isEmpty())\n+    }\n+\n+    @Test\n+    fun `Mcp CallToolResult to proto CallToolResult - text content`() {\n+        val result = Mcp.CallToolResult(\n+            content = listOf(Mcp.Content.TextContent(\"hello world\")),\n+            isError = false,\n+        )\n+\n+        val proto = result.toProto()\n+\n+        assertEquals(1, proto.contentCount)\n+        assertTrue(proto.contentList[0].hasText())\n+        assertEquals(\"hello world\", proto.contentList[0].text.text)\n+        assertFalse(proto.isError)\n+    }\n+\n+    @Test\n+    fun `Mcp CallToolResult to proto CallToolResult - image content`() {\n+        val result = Mcp.CallToolResult(\n+            content = listOf(Mcp.Content.ImageContent(\"base64data\", \"image/png\")),\n+            isError = false,\n+        )\n+\n+        val proto = result.toProto()\n+\n+        assertEquals(1, proto.contentCount)\n+        assertTrue(proto.contentList[0].hasImage())\n+        assertEquals(\"base64data\", proto.contentList[0].image.data)\n+        assertEquals(\"image/png\", proto.contentList[0].image.mimeType)\n+    }\n+\n+    @Test\n+    fun `Mcp CallToolResult error to proto`() {\n+        val result = Mcp.CallToolResult(\n+            content = listOf(Mcp.Content.TextContent(\"something failed\")),\n+            isError = true,\n+        )\n+\n+        val proto = result.toProto()\n+\n+        assertTrue(proto.isError)\n+        assertEquals(\"something failed\", proto.contentList[0].text.text)\n+    }\n+\n+    @Test\n+    fun `Mcp CallToolResult with multiple content items`() {\n+        val result = Mcp.CallToolResult(\n+            content = listOf(\n+                Mcp.Content.TextContent(\"text part\"),\n+                Mcp.Content.ImageContent(\"img-data\", \"image/jpeg\"),\n+            ),\n+            isError = false,\n+        )\n+\n+        val proto = result.toProto()\n+\n+        assertEquals(2, proto.contentCount)\n+        assertTrue(proto.contentList[0].hasText())\n+        assertTrue(proto.contentList[1].hasImage())\n+    }\n+\n+    @Test\n+    fun `ProgressNotification to proto`() {\n+        val notification = McpSchema.ProgressNotification(\n+            \"token-1\",\n+            50.0,\n+            100.0,\n+            \"Processing...\",\n+        )\n+\n+        val proto = notification.toProto()\n+\n+        assertEquals(\"token-1\", proto.progressToken)\n+        assertTrue(proto.hasProgress())\n+        assertEquals(50.0, proto.progress)\n+        assertTrue(proto.hasTotal())\n+        assertEquals(100.0, proto.total)\n+        assertEquals(\"Processing...\", proto.message)\n+    }\n+\n+    @Test\n+    fun `ProgressNotification with null fields to proto`() {\n+        val notification = McpSchema.ProgressNotification(\n+            null,\n+            null,\n+            null,\n+            null,\n+            null,\n+        )\n+\n+        val proto = notification.toProto()\n+\n+        assertEquals(\"\", proto.progressToken)\n+        assertFalse(proto.hasProgress())\n+        assertFalse(proto.hasTotal())\n+        assertEquals(\"\", proto.message)\n+    }\n+\n+    @Test\n+    fun `LoggingMessageNotification to proto`() {\n+        val notification = McpSchema.LoggingMessageNotification(\n+            McpSchema.LoggingLevel.WARNING,\n+            \"mcp.connector\",\n+            \"\"\"{\"detail\":\"something happened\"}\"\"\",\n+        )\n+\n+        val proto = notification.toProto()\n+\n+        assertEquals(\"warning\", proto.level)\n+        assertEquals(\"mcp.connector\", proto.logger)\n+        assertEquals(\"\"\"{\"detail\":\"something happened\"}\"\"\", proto.dataJson)\n+    }\n+\n+    @Test\n+    fun `LoggingMessageNotification with null fields to proto`() {\n+        val notification = McpSchema.LoggingMessageNotification(\n+            null,\n+            null,\n+            null,\n+        )\n+\n+        val proto = notification.toProto()\n+\n+        assertEquals(\"\", proto.level)\n+        assertEquals(\"\", proto.logger)\n+        assertEquals(\"\", proto.dataJson)\n+    }\n+\n+    // --- Map ↔ Struct conversion ---\n+\n+    @Test\n+    fun `Map to Struct roundtrip - basic types`() {\n+        val original = mapOf(\n+            \"string\" to \"hello\",\n+            \"number\" to 42.0,\n+            \"bool\" to true,\n+        )\n+\n+        val struct = original.toProtoStruct()\n+        val restored = struct.toMap()\n+\n+        assertEquals(\"hello\", restored[\"string\"])\n+        assertEquals(42.0, restored[\"number\"])\n+        assertEquals(true, restored[\"bool\"])\n+    }\n+\n+    @Test\n+    fun `Map to Struct roundtrip - nested map and list`() {\n+        val original = mapOf(\n+            \"nested\" to mapOf(\"inner\" to \"value\"),\n+            \"list\" to listOf(\"a\", \"b\", 1.0),\n+        )\n+\n+        val struct = original.toProtoStruct()\n+        val restored = struct.toMap()\n+\n+        @Suppress(\"UNCHECKED_CAST\")\n+        val nested = restored[\"nested\"] as Map<String, Any>\n+        assertEquals(\"value\", nested[\"inner\"])\n+\n+        @Suppress(\"UNCHECKED_CAST\")\n+        val list = restored[\"list\"] as List<Any?>\n+        assertEquals(listOf(\"a\", \"b\", 1.0), list)\n+    }\n+\n+    @Test\n+    fun `Map to Struct - null values are filtered out`() {\n+        val struct = Struct.newBuilder()\n+            .putFields(\"present\", Value.newBuilder().setStringValue(\"yes\").build())\n+            .putFields(\"absent\", Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build())\n+            .build()\n+\n+        val map = struct.toMap()\n+\n+        assertEquals(\"yes\", map[\"present\"])\n+        assertFalse(map.containsKey(\"absent\"))\n+    }\n+\n+    @Test\n+    fun `empty Map to Struct`() {\n+        val struct = emptyMap<String, Any>().toProtoStruct()\n+        assertEquals(0, struct.fieldsCount)\n+    }\n+\n+    // --- Tool meta ---\n+\n+    @Test\n+    fun `Tool with meta to proto preserves meta`() {\n+        val mcpTool = Mcp.Tool(\n+            name = \"tool-with-meta\",\n+            description = \"A tool\",\n+            meta = mapOf(\"errorType\" to \"AUTH_REQUIRED\", \"retryable\" to true),\n+        )\n+\n+        val proto = mcpTool.toProto()\n+\n+        assertTrue(proto.hasMeta())\n+        assertEquals(\"AUTH_REQUIRED\", proto.meta.fieldsMap[\"errorType\"]?.stringValue)\n+        assertEquals(true, proto.meta.fieldsMap[\"retryable\"]?.boolValue)\n+    }\n+\n+    @Test\n+    fun `Tool with empty meta to proto has no meta`() {\n+        val mcpTool = Mcp.Tool(\n+            name = \"tool-no-meta\",\n+            description = \"A tool\",\n+            meta = emptyMap(),\n+        )\n+\n+        val proto = mcpTool.toProto()\n+\n+        assertFalse(proto.hasMeta())\n+    }\n+\n+    // --- CallToolPayload meta ---\n+\n+    @Test\n+    fun `CallToolPayload with meta to CallToolRequest preserves meta`() {\n+        val payload = CallToolPayload.newBuilder()\n+            .setName(\"test-tool\")\n+            .setArgumentsJson(\"\"\"{\"key\":\"value\"}\"\"\")\n+            .setMeta(\n+                Struct.newBuilder()\n+                    .putFields(\"errorType\", Value.newBuilder().setStringValue(\"AUTH_REQUIRED\").build())\n+                    .build()\n+            )\n+            .build()\n+\n+        val request = payload.toCallToolRequest()\n+\n+        assertEquals(\"AUTH_REQUIRED\", request.meta[\"errorType\"])\n+    }\n+\n+    @Test\n+    fun `CallToolPayload without meta to CallToolRequest has empty meta`() {\n+        val payload = callToolPayload {\n+            name = \"simple-tool\"\n+            argumentsJson = \"{}\"\n+        }\n+\n+        val request = payload.toCallToolRequest()\n+\n+        assertTrue(request.meta.isEmpty())\n+    }\n+\n+    // --- CallToolResult meta ---\n+\n+    @Test\n+    fun `CallToolResult with meta to proto preserves meta`() {\n+        val result = Mcp.CallToolResult(\n+            content = listOf(Mcp.Content.TextContent(\"ok\")),\n+            isError = false,\n+            meta = mapOf(\"errorType\" to \"RATE_LIMITED\", \"retryAfter\" to 30.0),\n+        )\n+\n+        val proto = result.toProto()\n+\n+        assertTrue(proto.hasMeta())\n+        assertEquals(\"RATE_LIMITED\", proto.meta.fieldsMap[\"errorType\"]?.stringValue)\n+        assertEquals(30.0, proto.meta.fieldsMap[\"retryAfter\"]?.numberValue)\n+    }\n+\n+    @Test\n+    fun `CallToolResult with null meta to proto has no meta`() {\n+        val result = Mcp.CallToolResult(\n+            content = listOf(Mcp.Content.TextContent(\"ok\")),\n+            isError = false,\n+            meta = null,\n+        )\n+\n+        val proto = result.toProto()\n+\n+        assertFalse(proto.hasMeta())\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandlerTest.kt b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandlerTest.kt\nnew file mode 100644\nindex 000000000..2c8b0b7db\n--- /dev/null\n+++ b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandlerTest.kt\n@@ -0,0 +1,435 @@\n+package com.querypie.duplo.mcp.grpc.service\n+\n+import com.querypie.duplo.mcp.connector.api.Mcp\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnector\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnectorEventListener\n+import com.querypie.duplo.mcp.connector.api.v2.McpToolHandler\n+import com.querypie.duplo.mcp.grpc.session.GrpcSessionManager\n+import com.querypie.duplo.mcp.grpc.spi.ConnectorSession\n+import io.modelcontextprotocol.spec.McpSchema\n+import io.querypie.duplo.mcp.v1.ChannelRequest\n+import io.querypie.duplo.mcp.v1.ChannelResponse\n+import io.querypie.duplo.mcp.v1.callToolPayload\n+import io.querypie.duplo.mcp.v1.channelRequest\n+import io.querypie.duplo.mcp.v1.pingPayload\n+import io.querypie.duplo.mcp.v1.subscribeEventsPayload\n+import io.querypie.duplo.mcp.v1.unsubscribeEventsPayload\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.channels.Channel\n+import kotlinx.coroutines.flow.consumeAsFlow\n+import kotlinx.coroutines.flow.flowOf\n+import kotlinx.coroutines.flow.toList\n+import kotlinx.coroutines.launch\n+import kotlinx.coroutines.test.advanceUntilIdle\n+import kotlinx.coroutines.test.runTest\n+import org.mockito.kotlin.any\n+import org.mockito.kotlin.argumentCaptor\n+import org.mockito.kotlin.mock\n+import org.mockito.kotlin.verify\n+import org.mockito.kotlin.whenever\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertTrue\n+\n+@OptIn(ExperimentalCoroutinesApi::class)\n+class ChannelHandlerTest {\n+\n+    private val sessionManager = GrpcSessionManager()\n+    private val channelHandler = ChannelHandler(sessionManager)\n+\n+    private fun createMockSession(toolResult: Mcp.CallToolResult? = null): ConnectorSession {\n+        val connector = mock<McpConnector>()\n+        if (toolResult != null) {\n+            val toolHandler = McpToolHandler { toolResult }\n+            whenever(connector.findToolHandler(any())).thenReturn(toolHandler)\n+        }\n+        return ConnectorSession(\n+            connector = connector,\n+            serverName = \"test\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = \"\",\n+        )\n+    }\n+\n+    @Test\n+    fun `Ping returns Pong`() = runTest {\n+        val request = channelRequest {\n+            sessionId = \"\"\n+            requestId = \"req-1\"\n+            ping = pingPayload {}\n+        }\n+\n+        val responses = channelHandler.handle(flowOf(request)).toList()\n+\n+        assertEquals(1, responses.size)\n+        assertTrue(responses[0].hasPong())\n+        assertEquals(\"req-1\", responses[0].requestId)\n+    }\n+\n+    @Test\n+    fun `CallTool returns CallToolResult`() = runTest {\n+        val result = Mcp.CallToolResult.ofText(\"hello from tool\")\n+        val session = createMockSession(result)\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = channelRequest {\n+            sessionId = \"s1\"\n+            requestId = \"req-2\"\n+            callTool = callToolPayload {\n+                name = \"my-tool\"\n+                argumentsJson = \"\"\"{\"arg\":\"value\"}\"\"\"\n+            }\n+        }\n+\n+        val responses = channelHandler.handle(flowOf(request)).toList()\n+\n+        val toolResponse = responses.first { it.hasCallToolResult() }\n+        assertEquals(\"s1\", toolResponse.sessionId)\n+        assertEquals(\"req-2\", toolResponse.requestId)\n+        assertEquals(1, toolResponse.callToolResult.contentCount)\n+        assertEquals(\"hello from tool\", toolResponse.callToolResult.contentList[0].text.text)\n+    }\n+\n+    @Test\n+    fun `CallTool with unknown session returns error`() = runTest {\n+        val request = channelRequest {\n+            sessionId = \"unknown\"\n+            requestId = \"req-3\"\n+            callTool = callToolPayload { name = \"tool\" }\n+        }\n+\n+        val responses = channelHandler.handle(flowOf(request)).toList()\n+\n+        assertEquals(1, responses.size)\n+        assertTrue(responses[0].hasError())\n+        assertEquals(\"unknown\", responses[0].sessionId)\n+    }\n+\n+    @Test\n+    fun `CallTool with unknown tool returns error`() = runTest {\n+        val connector = mock<McpConnector>()\n+        whenever(connector.findToolHandler(any())).thenReturn(null)\n+        val session = ConnectorSession(connector, \"test\", \"1.0.0\", true, \"\")\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = channelRequest {\n+            sessionId = \"s1\"\n+            requestId = \"req-4\"\n+            callTool = callToolPayload { name = \"nonexistent\" }\n+        }\n+\n+        val responses = channelHandler.handle(flowOf(request)).toList()\n+\n+        assertEquals(1, responses.size)\n+        assertTrue(responses[0].hasError())\n+    }\n+\n+    @Test\n+    fun `multiple sessions multiplexed on same stream`() = runTest {\n+        val result1 = Mcp.CallToolResult.ofText(\"from session 1\")\n+        val result2 = Mcp.CallToolResult.ofText(\"from session 2\")\n+        sessionManager.put(\"s1\", createMockSession(result1))\n+        sessionManager.put(\"s2\", createMockSession(result2))\n+\n+        val requests = flowOf(\n+            channelRequest {\n+                sessionId = \"s1\"\n+                requestId = \"r1\"\n+                callTool = callToolPayload { name = \"tool\"; argumentsJson = \"{}\" }\n+            },\n+            channelRequest {\n+                sessionId = \"s2\"\n+                requestId = \"r2\"\n+                callTool = callToolPayload { name = \"tool\"; argumentsJson = \"{}\" }\n+            },\n+        )\n+\n+        val responses = channelHandler.handle(requests).toList()\n+\n+        val toolResponses = responses.filter { it.hasCallToolResult() }\n+        assertEquals(2, toolResponses.size)\n+\n+        val r1 = toolResponses.first { it.requestId == \"r1\" }\n+        val r2 = toolResponses.first { it.requestId == \"r2\" }\n+        assertEquals(\"s1\", r1.sessionId)\n+        assertEquals(\"s2\", r2.sessionId)\n+        assertEquals(\"from session 1\", r1.callToolResult.contentList[0].text.text)\n+        assertEquals(\"from session 2\", r2.callToolResult.contentList[0].text.text)\n+    }\n+\n+    // --- Event subscription tests ---\n+\n+    private fun createMockConnector(): McpConnector = mock<McpConnector>()\n+\n+    private fun createSession(connector: McpConnector): ConnectorSession =\n+        ConnectorSession(connector, \"test\", \"1.0.0\", true, \"\")\n+\n+    @Test\n+    fun `SubscribeEvents - ToolListChanged event is pushed`() = runTest {\n+        val connector = createMockConnector()\n+        val listenerCaptor = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).addListener(listenerCaptor.capture())\n+        val listener = listenerCaptor.firstValue\n+\n+        listener.onToolListChanged(emptyList(), emptyList())\n+        advanceUntilIdle()\n+\n+        val response = responseChannel.receive()\n+        assertTrue(response.hasToolListChanged())\n+        assertEquals(\"s1\", response.sessionId)\n+\n+        requestChannel.close()\n+        job.join()\n+    }\n+\n+    @Test\n+    fun `SubscribeEvents - ProgressNotification event is pushed`() = runTest {\n+        val connector = createMockConnector()\n+        val listenerCaptor = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).addListener(listenerCaptor.capture())\n+        val listener = listenerCaptor.firstValue\n+\n+        val notification = McpSchema.ProgressNotification(\"tok-1\", 25.0, 100.0, \"quarter done\")\n+        listener.onProgress(notification)\n+        advanceUntilIdle()\n+\n+        val response = responseChannel.receive()\n+        assertTrue(response.hasProgress())\n+        assertEquals(\"s1\", response.sessionId)\n+        assertEquals(\"tok-1\", response.progress.progressToken)\n+        assertEquals(25.0, response.progress.progress)\n+        assertEquals(100.0, response.progress.total)\n+        assertEquals(\"quarter done\", response.progress.message)\n+\n+        requestChannel.close()\n+        job.join()\n+    }\n+\n+    @Test\n+    fun `SubscribeEvents - LoggingMessage event is pushed`() = runTest {\n+        val connector = createMockConnector()\n+        val listenerCaptor = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).addListener(listenerCaptor.capture())\n+        val listener = listenerCaptor.firstValue\n+\n+        val notification = McpSchema.LoggingMessageNotification(McpSchema.LoggingLevel.ERROR, \"test.logger\", \"error data\")\n+        listener.onLoggingMessage(notification)\n+        advanceUntilIdle()\n+\n+        val response = responseChannel.receive()\n+        assertTrue(response.hasLoggingMessage())\n+        assertEquals(\"s1\", response.sessionId)\n+        assertEquals(\"error\", response.loggingMessage.level)\n+        assertEquals(\"test.logger\", response.loggingMessage.logger)\n+        assertEquals(\"error data\", response.loggingMessage.dataJson)\n+\n+        requestChannel.close()\n+        job.join()\n+    }\n+\n+    @Test\n+    fun `UnsubscribeEvents - listener is removed`() = runTest {\n+        val connector = createMockConnector()\n+        val listenerCaptor = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).addListener(listenerCaptor.capture())\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            unsubscribeEvents = unsubscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).removeListener(listenerCaptor.firstValue)\n+\n+        requestChannel.close()\n+        job.join()\n+    }\n+\n+    @Test\n+    fun `channelFlow close unsubscribes all listeners`() = runTest {\n+        val connector = createMockConnector()\n+        val listenerCaptor = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).addListener(listenerCaptor.capture())\n+\n+        requestChannel.close()\n+        job.join()\n+\n+        verify(connector).removeListener(listenerCaptor.firstValue)\n+    }\n+\n+    @Test\n+    fun `SubscribeEvents with unknown session returns error`() = runTest {\n+        val request = channelRequest {\n+            sessionId = \"nonexistent\"\n+            requestId = \"req-sub\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        }\n+\n+        val responses = channelHandler.handle(flowOf(request)).toList()\n+\n+        assertEquals(1, responses.size)\n+        assertTrue(responses[0].hasError())\n+        assertEquals(\"nonexistent\", responses[0].sessionId)\n+    }\n+\n+    @Test\n+    fun `multiple sessions independent subscriptions`() = runTest {\n+        val connector1 = createMockConnector()\n+        val connector2 = createMockConnector()\n+        val listenerCaptor1 = argumentCaptor<McpConnectorEventListener>()\n+        val listenerCaptor2 = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector1))\n+        sessionManager.put(\"s2\", createSession(connector2))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s2\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector1).addListener(listenerCaptor1.capture())\n+        verify(connector2).addListener(listenerCaptor2.capture())\n+\n+        listenerCaptor1.firstValue.onToolListChanged(emptyList(), emptyList())\n+        advanceUntilIdle()\n+        val r1 = responseChannel.receive()\n+        assertTrue(r1.hasToolListChanged())\n+        assertEquals(\"s1\", r1.sessionId)\n+\n+        val notification = McpSchema.ProgressNotification(\"p1\", 10.0, 50.0, \"half\")\n+        listenerCaptor2.firstValue.onProgress(notification)\n+        advanceUntilIdle()\n+        val r2 = responseChannel.receive()\n+        assertTrue(r2.hasProgress())\n+        assertEquals(\"s2\", r2.sessionId)\n+\n+        requestChannel.close()\n+        job.join()\n+    }\n+\n+    @Test\n+    fun `session removal via sessionManager unsubscribes listener`() = runTest {\n+        val connector = createMockConnector()\n+        val listenerCaptor = argumentCaptor<McpConnectorEventListener>()\n+        sessionManager.put(\"s1\", createSession(connector))\n+\n+        val requestChannel = Channel<ChannelRequest>(Channel.UNLIMITED)\n+        val responseChannel = Channel<ChannelResponse>(Channel.UNLIMITED)\n+\n+        val job = launch {\n+            channelHandler.handle(requestChannel.consumeAsFlow()).collect { responseChannel.send(it) }\n+            responseChannel.close()\n+        }\n+\n+        requestChannel.send(channelRequest {\n+            sessionId = \"s1\"\n+            subscribeEvents = subscribeEventsPayload {}\n+        })\n+        advanceUntilIdle()\n+\n+        verify(connector).addListener(listenerCaptor.capture())\n+\n+        // 세션을 sessionManager에서 직접 제거 (SendHandler.closeSession 시뮬레이션)\n+        sessionManager.remove(\"s1\")\n+        advanceUntilIdle()\n+\n+        // 구독이 해제되었는지 확인 (removeListener 호출)\n+        verify(connector).removeListener(listenerCaptor.firstValue)\n+\n+        requestChannel.close()\n+        job.join()\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandlerTest.kt b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandlerTest.kt\nnew file mode 100644\nindex 000000000..29584d6f6\n--- /dev/null\n+++ b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandlerTest.kt\n@@ -0,0 +1,558 @@\n+package com.querypie.duplo.mcp.grpc.service\n+\n+import com.querypie.duplo.mcp.connector.api.Mcp\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnector\n+import com.querypie.duplo.mcp.connector.api.v2.McpToolHandler\n+import com.querypie.duplo.mcp.grpc.session.GrpcSessionManager\n+import com.querypie.duplo.mcp.grpc.spi.AccessKeyResult\n+import com.querypie.duplo.mcp.grpc.spi.ConnectorSession\n+import com.querypie.duplo.mcp.grpc.spi.GrpcAccessKeyVerifier\n+import com.querypie.duplo.mcp.grpc.spi.GrpcConnectorProvider\n+import io.querypie.duplo.mcp.v1.SendRequest\n+import io.querypie.duplo.mcp.v1.SessionExistence\n+import io.querypie.duplo.mcp.v1.authContext\n+import io.querypie.duplo.mcp.v1.callToolPayload\n+import io.querypie.duplo.mcp.v1.callToolSendRequest\n+import io.querypie.duplo.mcp.v1.closeSessionRequest\n+import io.querypie.duplo.mcp.v1.createSessionRequest\n+import io.querypie.duplo.mcp.v1.deleteSessionRequest\n+import io.querypie.duplo.mcp.v1.listToolsRequest\n+import io.querypie.duplo.mcp.v1.querySessionRequest\n+import io.querypie.duplo.mcp.v1.sendNotificationRequest\n+import io.querypie.duplo.mcp.v1.sendRequest\n+import io.querypie.duplo.mcp.v1.verifyAccessKeyRequest\n+import org.mockito.kotlin.any\n+import org.mockito.kotlin.eq\n+import org.mockito.kotlin.mock\n+import org.mockito.kotlin.verify\n+import org.mockito.kotlin.whenever\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+\n+class SendHandlerTest {\n+\n+    private val sessionManager = GrpcSessionManager()\n+    private val connectorProvider = mock<GrpcConnectorProvider>()\n+    private val accessKeyVerifier = mock<GrpcAccessKeyVerifier>()\n+    private val handler = SendHandler(sessionManager, connectorProvider, accessKeyVerifier)\n+\n+    private fun mockConnectorSession(tools: List<Mcp.Tool> = emptyList()): ConnectorSession {\n+        val connector = mock<McpConnector>()\n+        whenever(connector.getTools()).thenReturn(tools)\n+        return ConnectorSession(\n+            connector = connector,\n+            serverName = \"test-server\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = \"test instructions\",\n+        )\n+    }\n+\n+    @Test\n+    fun `CreateSession - success with tools`() {\n+        val tools = listOf(Mcp.Tool(name = \"tool1\", description = \"A tool\"))\n+        val session = mockConnectorSession(tools)\n+        whenever(connectorProvider.createSession(any(), any(), any())).thenReturn(session)\n+\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/presets/test-uuid\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+                protocolVersion = \"2025-03-26\"\n+                sessionId = \"proxy-session-1\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasCreateSession())\n+        val cs = response.createSession\n+        assertEquals(\"proxy-session-1\", cs.sessionId)\n+        assertEquals(\"test-server\", cs.serverInfo.name)\n+        assertEquals(\"1.0.0\", cs.serverInfo.version)\n+        assertEquals(\"2025-03-26\", cs.protocolVersion)\n+        assertEquals(\"test instructions\", cs.instructions)\n+        assertEquals(1, cs.toolsCount)\n+        assertEquals(\"tool1\", cs.toolsList[0].name)\n+        assertTrue(cs.serverCapabilities.tools.listChanged)\n+    }\n+\n+    @Test\n+    fun `CreateSession - uses proxy-provided session_id when present`() {\n+        val session = mockConnectorSession()\n+        whenever(connectorProvider.createSession(any(), any(), any())).thenReturn(session)\n+\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/presets/test-uuid\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+                protocolVersion = \"2025-03-26\"\n+                sessionId = \"proxy-session-abc\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasCreateSession())\n+        assertEquals(\"proxy-session-abc\", response.createSession.sessionId)\n+        assertTrue(sessionManager.exists(\"proxy-session-abc\"))\n+    }\n+\n+    @Test\n+    fun `CreateSession - missing session_id returns error`() {\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/presets/test-uuid\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.INVALID_PARAMS, response.error.code)\n+    }\n+\n+    @Test\n+    fun `CreateSession - provider returns null`() {\n+        whenever(connectorProvider.createSession(any(), any(), any())).thenReturn(null)\n+\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/unknown\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+                sessionId = \"proxy-session-null\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.INVALID_PARAMS, response.error.code)\n+    }\n+\n+    @Test\n+    fun `ListTools - success`() {\n+        val tools = listOf(\n+            Mcp.Tool(name = \"a\", description = \"Tool A\"),\n+            Mcp.Tool(name = \"b\", description = \"Tool B\"),\n+        )\n+        val session = mockConnectorSession(tools)\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = sendRequest {\n+            listTools = listToolsRequest { sessionId = \"s1\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasListTools())\n+        assertEquals(2, response.listTools.toolsCount)\n+        assertEquals(\"a\", response.listTools.toolsList[0].name)\n+    }\n+\n+    @Test\n+    fun `ListTools - session not found`() {\n+        val request = sendRequest {\n+            listTools = listToolsRequest { sessionId = \"unknown\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+    }\n+\n+    @Test\n+    fun `CloseSession - success`() {\n+        val session = mockConnectorSession()\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = sendRequest {\n+            closeSession = closeSessionRequest { sessionId = \"s1\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasCloseSession())\n+        verify(session.connector).close()\n+        assertFalse(sessionManager.exists(\"s1\"))\n+    }\n+\n+    @Test\n+    fun `QuerySession - exists`() {\n+        sessionManager.put(\"s1\", mockConnectorSession())\n+\n+        val request = sendRequest {\n+            querySession = querySessionRequest { sessionId = \"s1\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasQuerySession())\n+        assertEquals(SessionExistence.SESSION_EXISTENCE_EXISTS, response.querySession.existence)\n+    }\n+\n+    @Test\n+    fun `QuerySession - not exists`() {\n+        val request = sendRequest {\n+            querySession = querySessionRequest { sessionId = \"none\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasQuerySession())\n+        assertEquals(SessionExistence.SESSION_EXISTENCE_NOT_EXISTS, response.querySession.existence)\n+    }\n+\n+    @Test\n+    fun `DeleteSession - by sessionId`() {\n+        val session = mockConnectorSession()\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = sendRequest {\n+            deleteSession = deleteSessionRequest { sessionId = \"s1\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasDeleteSession())\n+        assertEquals(1, response.deleteSession.deletedCount)\n+        verify(session.connector).close()\n+    }\n+\n+    @Test\n+    fun `VerifyAccessKey - valid`() {\n+        whenever(accessKeyVerifier.verify(\"key-123\", \"preset-1\"))\n+            .thenReturn(AccessKeyResult(valid = true, userId = \"user-1\", deviceId = \"dev-1\"))\n+\n+        val request = sendRequest {\n+            verifyAccessKey = verifyAccessKeyRequest {\n+                accessKey = \"key-123\"\n+                presetId = \"preset-1\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasVerifyAccessKey())\n+        assertTrue(response.verifyAccessKey.valid)\n+        assertEquals(\"user-1\", response.verifyAccessKey.userId)\n+        assertEquals(\"dev-1\", response.verifyAccessKey.deviceId)\n+    }\n+\n+    @Test\n+    fun `VerifyAccessKey - invalid`() {\n+        whenever(accessKeyVerifier.verify(\"bad-key\", \"preset-1\"))\n+            .thenReturn(AccessKeyResult(valid = false))\n+\n+        val request = sendRequest {\n+            verifyAccessKey = verifyAccessKeyRequest {\n+                accessKey = \"bad-key\"\n+                presetId = \"preset-1\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasVerifyAccessKey())\n+        assertFalse(response.verifyAccessKey.valid)\n+    }\n+\n+    @Test\n+    fun `DeleteSession - by agentInstallationId removes matching sessions`() {\n+        val session1 = mockConnectorSession().copy(baseUrl = \"/agent-installations/agent-abc/mcp\")\n+        val session2 = mockConnectorSession().copy(baseUrl = \"/agent-installations/agent-abc/other\")\n+        val session3 = mockConnectorSession().copy(baseUrl = \"/presets/some-preset\")\n+        sessionManager.put(\"s1\", session1)\n+        sessionManager.put(\"s2\", session2)\n+        sessionManager.put(\"s3\", session3)\n+\n+        val request = sendRequest {\n+            deleteSession = deleteSessionRequest { agentInstallationId = \"agent-abc\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasDeleteSession())\n+        assertEquals(2, response.deleteSession.deletedCount)\n+        assertFalse(sessionManager.exists(\"s1\"))\n+        assertFalse(sessionManager.exists(\"s2\"))\n+        assertTrue(sessionManager.exists(\"s3\"))\n+    }\n+\n+    @Test\n+    fun `DeleteSession - by agentInstallationId does not match partial id`() {\n+        val session1 = mockConnectorSession().copy(baseUrl = \"/agent-installations/agent-abc/mcp\")\n+        val session2 = mockConnectorSession().copy(baseUrl = \"/agent-installations/agent-abc123/mcp\")\n+        sessionManager.put(\"s1\", session1)\n+        sessionManager.put(\"s2\", session2)\n+\n+        val request = sendRequest {\n+            deleteSession = deleteSessionRequest { agentInstallationId = \"agent-abc\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertEquals(1, response.deleteSession.deletedCount)\n+        assertFalse(sessionManager.exists(\"s1\"))\n+        assertTrue(sessionManager.exists(\"s2\"))\n+    }\n+\n+    @Test\n+    fun `DeleteSession - by agentInstallationId with blank id returns zero`() {\n+        sessionManager.put(\"s1\", mockConnectorSession().copy(baseUrl = \"/presets/test\"))\n+\n+        val request = sendRequest {\n+            deleteSession = deleteSessionRequest { agentInstallationId = \"\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasDeleteSession())\n+        assertEquals(0, response.deleteSession.deletedCount)\n+        assertTrue(sessionManager.exists(\"s1\"))\n+    }\n+\n+    @Test\n+    fun `DeleteSession - by agentInstallationId with no matches returns zero`() {\n+        sessionManager.put(\"s1\", mockConnectorSession().copy(baseUrl = \"/presets/test\"))\n+\n+        val request = sendRequest {\n+            deleteSession = deleteSessionRequest { agentInstallationId = \"nonexistent\" }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasDeleteSession())\n+        assertEquals(0, response.deleteSession.deletedCount)\n+        assertTrue(sessionManager.exists(\"s1\"))\n+    }\n+\n+    @Test\n+    fun `SendNotification - session not found returns error`() {\n+        val request = sendRequest {\n+            sendNotification = sendNotificationRequest {\n+                sessionId = \"nonexistent\"\n+                method = \"notifications/cancelled\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+    }\n+\n+    @Test\n+    fun `SendNotification - success with valid session`() {\n+        sessionManager.put(\"s1\", mockConnectorSession())\n+\n+        val request = sendRequest {\n+            sendNotification = sendNotificationRequest {\n+                sessionId = \"s1\"\n+                method = \"notifications/cancelled\"\n+                paramsJson = \"\"\"{\"requestId\":\"req-1\"}\"\"\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasSendNotification())\n+    }\n+\n+    @Test\n+    fun `CreateSession - getTools failure removes session and returns error`() {\n+        val connector = mock<McpConnector>()\n+        whenever(connector.getTools()).thenThrow(RuntimeException(\"MCP server unreachable\"))\n+        val session = ConnectorSession(\n+            connector = connector,\n+            serverName = \"broken-server\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = \"\",\n+        )\n+        whenever(connectorProvider.createSession(any(), any(), any())).thenReturn(session)\n+\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/presets/broken\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+                sessionId = \"proxy-session-broken\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.INTERNAL_ERROR, response.error.code)\n+        verify(connector).close()\n+    }\n+\n+    @Test\n+    fun `CreateSession - provider throws exception returns error`() {\n+        whenever(connectorProvider.createSession(any(), any(), any()))\n+            .thenThrow(RuntimeException(\"DB connection failed\"))\n+\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/presets/test\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+                sessionId = \"proxy-session-fail\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.INTERNAL_ERROR, response.error.code)\n+    }\n+\n+    // --- CallTool tests ---\n+\n+    @Test\n+    fun `CallTool - success`() {\n+        val toolResult = Mcp.CallToolResult(\n+            content = listOf(Mcp.Content.TextContent(\"hello\")),\n+        )\n+        val toolHandler = mock<McpToolHandler>()\n+        whenever(toolHandler.handle(any())).thenReturn(toolResult)\n+\n+        val connector = mock<McpConnector>()\n+        whenever(connector.getTools()).thenReturn(emptyList())\n+        whenever(connector.findToolHandler(eq(\"myTool\"))).thenReturn(toolHandler)\n+        val session = ConnectorSession(\n+            connector = connector,\n+            serverName = \"test\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = false,\n+            instructions = \"\",\n+        )\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = sendRequest {\n+            callTool = callToolSendRequest {\n+                sessionId = \"s1\"\n+                payload = callToolPayload {\n+                    name = \"myTool\"\n+                    argumentsJson = \"\"\"{\"key\":\"value\"}\"\"\"\n+                }\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasCallTool())\n+        assertEquals(1, response.callTool.contentCount)\n+        assertTrue(response.callTool.contentList[0].hasText())\n+        assertEquals(\"hello\", response.callTool.contentList[0].text.text)\n+    }\n+\n+    @Test\n+    fun `CallTool - session not found`() {\n+        val request = sendRequest {\n+            callTool = callToolSendRequest {\n+                sessionId = \"nonexistent\"\n+                payload = callToolPayload { name = \"tool\" }\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.INVALID_PARAMS, response.error.code)\n+    }\n+\n+    @Test\n+    fun `CallTool - tool not found`() {\n+        val connector = mock<McpConnector>()\n+        whenever(connector.getTools()).thenReturn(emptyList())\n+        whenever(connector.findToolHandler(any())).thenReturn(null)\n+        val session = ConnectorSession(\n+            connector = connector,\n+            serverName = \"test\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = false,\n+            instructions = \"\",\n+        )\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = sendRequest {\n+            callTool = callToolSendRequest {\n+                sessionId = \"s1\"\n+                payload = callToolPayload { name = \"nonexistent\" }\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.METHOD_NOT_FOUND, response.error.code)\n+    }\n+\n+    @Test\n+    fun `CallTool - handler throws exception returns error`() {\n+        val toolHandler = mock<McpToolHandler>()\n+        whenever(toolHandler.handle(any())).thenThrow(RuntimeException(\"boom\"))\n+\n+        val connector = mock<McpConnector>()\n+        whenever(connector.getTools()).thenReturn(emptyList())\n+        whenever(connector.findToolHandler(eq(\"failTool\"))).thenReturn(toolHandler)\n+        val session = ConnectorSession(\n+            connector = connector,\n+            serverName = \"test\",\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = false,\n+            instructions = \"\",\n+        )\n+        sessionManager.put(\"s1\", session)\n+\n+        val request = sendRequest {\n+            callTool = callToolSendRequest {\n+                sessionId = \"s1\"\n+                payload = callToolPayload {\n+                    name = \"failTool\"\n+                    argumentsJson = \"{}\"\n+                }\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+        assertEquals(GrpcErrorCodes.INTERNAL_ERROR, response.error.code)\n+    }\n+\n+    // --- CreateSession duplicate session_id ---\n+\n+    @Test\n+    fun `CreateSession - duplicate session_id closes previous connector`() {\n+        val oldSession = mockConnectorSession()\n+        sessionManager.put(\"s1\", oldSession)\n+\n+        val newSession = mockConnectorSession()\n+        whenever(connectorProvider.createSession(any(), any(), any())).thenReturn(newSession)\n+\n+        val request = sendRequest {\n+            createSession = createSessionRequest {\n+                baseUrl = \"/presets/test\"\n+                this.authContext = authContext { userId = \"user-1\" }\n+                sessionId = \"s1\"\n+            }\n+        }\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasCreateSession())\n+        verify(oldSession.connector).close()\n+    }\n+\n+    @Test\n+    fun `empty payload returns error`() {\n+        val request = SendRequest.getDefaultInstance()\n+\n+        val response = handler.handle(request)\n+\n+        assertTrue(response.hasError())\n+    }\n+}\ndiff --git a/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManagerTest.kt b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManagerTest.kt\nnew file mode 100644\nindex 000000000..1576079fc\n--- /dev/null\n+++ b/backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManagerTest.kt\n@@ -0,0 +1,153 @@\n+package com.querypie.duplo.mcp.grpc.session\n+\n+import com.querypie.duplo.mcp.connector.api.v2.McpConnector\n+import com.querypie.duplo.mcp.grpc.spi.ConnectorSession\n+import org.mockito.kotlin.mock\n+import org.mockito.kotlin.never\n+import org.mockito.kotlin.verify\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertNull\n+import kotlin.test.assertTrue\n+\n+class GrpcSessionManagerTest {\n+    private val manager = GrpcSessionManager()\n+\n+    private fun createSession(name: String = \"test\"): ConnectorSession {\n+        return ConnectorSession(\n+            connector = mock<McpConnector>(),\n+            serverName = name,\n+            serverVersion = \"1.0.0\",\n+            toolsListChanged = true,\n+            instructions = \"\",\n+        )\n+    }\n+\n+    @Test\n+    fun `put and get session`() {\n+        val session = createSession()\n+        manager.put(\"s1\", session)\n+\n+        val result = manager.get(\"s1\")\n+        assertNotNull(result)\n+        assertEquals(\"test\", result.serverName)\n+    }\n+\n+    @Test\n+    fun `get non-existent session returns null`() {\n+        assertNull(manager.get(\"unknown\"))\n+    }\n+\n+    @Test\n+    fun `exists returns true for existing session`() {\n+        manager.put(\"s1\", createSession())\n+        assertTrue(manager.exists(\"s1\"))\n+    }\n+\n+    @Test\n+    fun `exists returns false for missing session`() {\n+        assertFalse(manager.exists(\"missing\"))\n+    }\n+\n+    @Test\n+    fun `remove closes connector and returns session`() {\n+        val session = createSession()\n+        manager.put(\"s1\", session)\n+\n+        val removed = manager.remove(\"s1\")\n+        assertNotNull(removed)\n+        verify(session.connector).close()\n+        assertNull(manager.get(\"s1\"))\n+    }\n+\n+    @Test\n+    fun `remove non-existent session returns null`() {\n+        val removed = manager.remove(\"none\")\n+        assertNull(removed)\n+    }\n+\n+    @Test\n+    fun `removeAll returns all removed sessions and closes connectors`() {\n+        val s1 = createSession(\"a\")\n+        val s2 = createSession(\"b\")\n+        val s3 = createSession(\"c\")\n+        manager.put(\"s1\", s1)\n+        manager.put(\"s2\", s2)\n+        manager.put(\"s3\", s3)\n+\n+        val removed = manager.removeAll { _, session -> session.serverName == \"a\" || session.serverName == \"c\" }\n+\n+        assertEquals(2, removed.size)\n+        verify(s1.connector).close()\n+        verify(s3.connector).close()\n+        verify(s2.connector, never()).close()\n+        assertNull(manager.get(\"s1\"))\n+        assertNotNull(manager.get(\"s2\"))\n+        assertNull(manager.get(\"s3\"))\n+    }\n+\n+    @Test\n+    fun `generateSessionId returns unique ids`() {\n+        val ids = (1..100).map { manager.generateSessionId() }.toSet()\n+        assertEquals(100, ids.size)\n+    }\n+\n+    // --- Session TTL / eviction ---\n+\n+    @Test\n+    fun `evictExpired removes sessions older than TTL`() {\n+        val s1 = createSession(\"old\")\n+        val s2 = createSession(\"fresh\")\n+        manager.put(\"s1\", s1)\n+        manager.put(\"s2\", s2)\n+\n+        // s1을 과거 시점으로 조작\n+        manager.setLastAccessedForTest(\"s1\", System.currentTimeMillis() - 60_000)\n+\n+        val evicted = manager.evictExpired(ttlMillis = 30_000)\n+\n+        assertEquals(1, evicted)\n+        assertNull(manager.get(\"s1\"))\n+        assertNotNull(manager.get(\"s2\"))\n+        verify(s1.connector).close()\n+    }\n+\n+    @Test\n+    fun `evictExpired keeps all sessions within TTL`() {\n+        manager.put(\"s1\", createSession())\n+        manager.put(\"s2\", createSession())\n+\n+        val evicted = manager.evictExpired(ttlMillis = 60_000)\n+\n+        assertEquals(0, evicted)\n+        assertTrue(manager.exists(\"s1\"))\n+        assertTrue(manager.exists(\"s2\"))\n+    }\n+\n+    @Test\n+    fun `get refreshes lastAccessed time`() {\n+        manager.put(\"s1\", createSession())\n+        // 과거로 설정\n+        manager.setLastAccessedForTest(\"s1\", System.currentTimeMillis() - 60_000)\n+\n+        // get 호출로 시간 갱신\n+        manager.get(\"s1\")\n+\n+        // TTL 30초로 evict 시도 → 갱신되었으므로 evict 안됨\n+        val evicted = manager.evictExpired(ttlMillis = 30_000)\n+        assertEquals(0, evicted)\n+        assertTrue(manager.exists(\"s1\"))\n+    }\n+\n+    @Test\n+    fun `remove cleans up lastAccessed entry`() {\n+        manager.put(\"s1\", createSession())\n+        manager.remove(\"s1\")\n+\n+        // evictExpired should not fail on orphan entries\n+        val evicted = manager.evictExpired(ttlMillis = 0)\n+        assertEquals(0, evicted)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/build.gradle.kts b/backend/mcp/proxy/build.gradle.kts\nindex 02e679674..5d5cd645f 100644\n--- a/backend/mcp/proxy/build.gradle.kts\n+++ b/backend/mcp/proxy/build.gradle.kts\n@@ -10,6 +10,8 @@ dependencies {\n     implementation(project(\":common\"))\n     implementation(project(\":mcp:connector-api\"))\n \n+    testImplementation(\"org.mockito.kotlin:mockito-kotlin\")\n+\n     implementation(\"org.springframework.boot:spring-boot-starter-data-redis\")\n \n     implementation(\"io.modelcontextprotocol.sdk:mcp-spring-webmvc\")\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/CollectionUtilsTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/CollectionUtilsTest.kt\nnew file mode 100644\nindex 000000000..7f7b5f549\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/CollectionUtilsTest.kt\n@@ -0,0 +1,140 @@\n+package com.querypie.duplo.mcp.proxy\n+\n+import org.junit.jupiter.api.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertTrue\n+\n+class CollectionUtilsTest {\n+\n+    @Test\n+    fun `diff - items only in right are added`() {\n+        val left = emptyList<Int>()\n+        val right = listOf(1, 2, 3)\n+\n+        val result = CollectionUtils.diff(left, right) { a, b -> a == b }\n+\n+        assertEquals(listOf(1, 2, 3), result.added)\n+        assertTrue(result.same.isEmpty())\n+        assertTrue(result.removed.isEmpty())\n+    }\n+\n+    @Test\n+    fun `diff - items only in left are removed`() {\n+        val left = listOf(1, 2, 3)\n+        val right = emptyList<Int>()\n+\n+        val result = CollectionUtils.diff(left, right) { a, b -> a == b }\n+\n+        assertTrue(result.added.isEmpty())\n+        assertTrue(result.same.isEmpty())\n+        assertEquals(listOf(1, 2, 3), result.removed)\n+    }\n+\n+    @Test\n+    fun `diff - matching items appear in same`() {\n+        val left = listOf(1, 2, 3)\n+        val right = listOf(2, 3, 4)\n+\n+        val result = CollectionUtils.diff(left, right) { a, b -> a == b }\n+\n+        assertEquals(listOf(4), result.added)\n+        assertEquals(listOf(2 to 2, 3 to 3), result.same)\n+        assertEquals(listOf(1), result.removed)\n+    }\n+\n+    @Test\n+    fun `diff - both empty collections`() {\n+        val left = emptyList<String>()\n+        val right = emptyList<String>()\n+\n+        val result = CollectionUtils.diff(left, right) { a, b -> a == b }\n+\n+        assertTrue(result.added.isEmpty())\n+        assertTrue(result.same.isEmpty())\n+        assertTrue(result.removed.isEmpty())\n+    }\n+\n+    @Test\n+    fun `diff - identical collections`() {\n+        val left = listOf(\"a\", \"b\", \"c\")\n+        val right = listOf(\"a\", \"b\", \"c\")\n+\n+        val result = CollectionUtils.diff(left, right) { a, b -> a == b }\n+\n+        assertTrue(result.added.isEmpty())\n+        assertEquals(3, result.same.size)\n+        assertTrue(result.removed.isEmpty())\n+    }\n+\n+    @Test\n+    fun `diff - custom comparator with different types`() {\n+        data class OldItem(val id: Int, val name: String)\n+        data class NewItem(val id: Int, val label: String)\n+\n+        val left = listOf(OldItem(1, \"a\"), OldItem(2, \"b\"))\n+        val right = listOf(NewItem(2, \"B\"), NewItem(3, \"C\"))\n+\n+        val result = CollectionUtils.diff(left, right) { old, new -> old.id == new.id }\n+\n+        assertEquals(listOf(NewItem(3, \"C\")), result.added)\n+        assertEquals(listOf(OldItem(2, \"b\") to NewItem(2, \"B\")), result.same)\n+        assertEquals(listOf(OldItem(1, \"a\")), result.removed)\n+    }\n+\n+    @Test\n+    fun `hasChanges - returns true when there are added items`() {\n+        val result = CollectionUtils.DiffResult(\n+            added = listOf(1),\n+            same = emptyList<Pair<Int, Int>>(),\n+            removed = emptyList(),\n+        )\n+\n+        assertTrue(result.hasChanges())\n+    }\n+\n+    @Test\n+    fun `hasChanges - returns true when there are same items`() {\n+        val result = CollectionUtils.DiffResult(\n+            added = emptyList<Int>(),\n+            same = listOf(1 to 1),\n+            removed = emptyList(),\n+        )\n+\n+        assertTrue(result.hasChanges())\n+    }\n+\n+    @Test\n+    fun `hasChanges - returns true when there are removed items`() {\n+        val result = CollectionUtils.DiffResult(\n+            added = emptyList<Int>(),\n+            same = emptyList<Pair<Int, Int>>(),\n+            removed = listOf(1),\n+        )\n+\n+        assertTrue(result.hasChanges())\n+    }\n+\n+    @Test\n+    fun `hasChanges - returns false when all lists are empty`() {\n+        val result = CollectionUtils.DiffResult(\n+            added = emptyList<Int>(),\n+            same = emptyList<Pair<Int, Int>>(),\n+            removed = emptyList(),\n+        )\n+\n+        assertFalse(result.hasChanges())\n+    }\n+\n+    @Test\n+    fun `diff - duplicate items in right are matched individually`() {\n+        val left = listOf(1, 1)\n+        val right = listOf(1)\n+\n+        val result = CollectionUtils.diff(left, right) { a, b -> a == b }\n+\n+        assertTrue(result.added.isEmpty())\n+        assertEquals(1, result.same.size)\n+        assertEquals(listOf(1), result.removed)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/UnifiedMcpTransportServletTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/UnifiedMcpTransportServletTest.kt\nnew file mode 100644\nindex 000000000..9922e6514\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/UnifiedMcpTransportServletTest.kt\n@@ -0,0 +1,120 @@\n+package com.querypie.duplo.mcp.proxy\n+\n+import com.querypie.duplo.mcp.proxy.mcp.HttpServletSseServerTransportProvider\n+import com.querypie.duplo.mcp.proxy.mcp.HttpServletStreamableHttpTransportProvider\n+import jakarta.servlet.http.HttpServletRequest\n+import jakarta.servlet.http.HttpServletResponse\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.params.ParameterizedTest\n+import org.junit.jupiter.params.provider.ValueSource\n+import org.mockito.kotlin.*\n+import java.io.PrintWriter\n+import java.io.StringWriter\n+\n+class UnifiedMcpTransportServletTest {\n+\n+    private lateinit var sseProvider: HttpServletSseServerTransportProvider\n+    private lateinit var streamableHttpProvider: HttpServletStreamableHttpTransportProvider\n+    private lateinit var servlet: UnifiedMcpTransportServlet\n+\n+    @BeforeEach\n+    fun setup() {\n+        sseProvider = mock()\n+        streamableHttpProvider = mock()\n+        servlet = UnifiedMcpTransportServlet(sseProvider, streamableHttpProvider)\n+    }\n+\n+    private fun mockRequest(uri: String): HttpServletRequest {\n+        return mock {\n+            on { requestURI } doReturn uri\n+            on { method } doReturn \"GET\"\n+        }\n+    }\n+\n+    private fun mockResponse(): HttpServletResponse {\n+        val writer = PrintWriter(StringWriter())\n+        return mock {\n+            on { this.writer } doReturn writer\n+        }\n+    }\n+\n+    @Test\n+    fun `routes SSE request to SSE provider`() {\n+        val req = mockRequest(\"/some/path/sse\")\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(sseProvider).service(req, res)\n+        verify(streamableHttpProvider, never()).service(any(), any())\n+    }\n+\n+    @Test\n+    fun `routes Streamable HTTP request to streamable provider`() {\n+        val req = mockRequest(\"/some/path/mcp\")\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(streamableHttpProvider).service(req, res)\n+        verify(sseProvider, never()).service(any(), any())\n+    }\n+\n+    @Test\n+    fun `routes message endpoint to SSE provider`() {\n+        val req = mockRequest(\"/some/path/message\")\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(sseProvider).service(req, res)\n+        verify(streamableHttpProvider, never()).service(any(), any())\n+    }\n+\n+    @ParameterizedTest(name = \"health check: {0}\")\n+    @ValueSource(strings = [\"/\", \"/health\"])\n+    fun `health check returns OK`(uri: String) {\n+        val req = mockRequest(uri)\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_OK\n+        verify(res).contentType = \"text/plain; charset=UTF-8\"\n+        verify(sseProvider, never()).service(any(), any())\n+        verify(streamableHttpProvider, never()).service(any(), any())\n+    }\n+\n+    @Test\n+    fun `unknown path returns 404`() {\n+        val req = mockRequest(\"/unknown/path\")\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).sendError(HttpServletResponse.SC_NOT_FOUND)\n+        verify(sseProvider, never()).service(any(), any())\n+        verify(streamableHttpProvider, never()).service(any(), any())\n+    }\n+\n+    @Test\n+    fun `routes nested SSE path correctly`() {\n+        val req = mockRequest(\"/agents/abc123/connector/sse\")\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(sseProvider).service(req, res)\n+    }\n+\n+    @Test\n+    fun `routes nested MCP path correctly`() {\n+        val req = mockRequest(\"/agents/abc123/connector/mcp\")\n+        val res = mockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(streamableHttpProvider).service(req, res)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/ClientInfoContextTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/ClientInfoContextTest.kt\nnew file mode 100644\nindex 000000000..797d66f51\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/ClientInfoContextTest.kt\n@@ -0,0 +1,101 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import kotlinx.coroutines.runBlocking\n+import kotlinx.coroutines.withContext\n+import org.junit.jupiter.api.AfterEach\n+import org.junit.jupiter.api.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNull\n+\n+class ClientInfoContextTest {\n+\n+    @AfterEach\n+    fun cleanup() {\n+        ClientInfoContext.clearCurrentClientInfo()\n+    }\n+\n+    @Test\n+    fun `get returns null when not set`() {\n+        assertNull(ClientInfoContext.getCurrentClientInfo())\n+    }\n+\n+    @Test\n+    fun `set and get returns the same ClientInfo`() {\n+        val clientInfo = ClientInfo(ip = \"192.168.1.1\", userAgent = \"TestAgent\", conversationId = \"conv-1\")\n+\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        assertEquals(clientInfo, ClientInfoContext.getCurrentClientInfo())\n+    }\n+\n+    @Test\n+    fun `clear removes the ClientInfo`() {\n+        val clientInfo = ClientInfo(ip = \"10.0.0.1\", userAgent = \"Agent\", conversationId = \"conv-2\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        ClientInfoContext.clearCurrentClientInfo()\n+\n+        assertNull(ClientInfoContext.getCurrentClientInfo())\n+    }\n+\n+    @Test\n+    fun `set null clears the ClientInfo`() {\n+        val clientInfo = ClientInfo(ip = \"10.0.0.1\", userAgent = \"Agent\", conversationId = \"conv-3\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        ClientInfoContext.setCurrentClientInfo(null)\n+\n+        assertNull(ClientInfoContext.getCurrentClientInfo())\n+    }\n+\n+    @Test\n+    fun `asContextElement propagates ClientInfo to coroutine`() = runBlocking {\n+        val clientInfo = ClientInfo(ip = \"172.16.0.1\", userAgent = \"CoroutineAgent\", conversationId = \"conv-4\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        val result = withContext(ClientInfoContext.asContextElement()) {\n+            ClientInfoContext.getCurrentClientInfo()\n+        }\n+\n+        assertEquals(clientInfo, result)\n+    }\n+\n+    @Test\n+    fun `asContextElement restores previous ClientInfo after coroutine`() = runBlocking {\n+        val original = ClientInfo(ip = \"1.1.1.1\", userAgent = \"Original\", conversationId = \"conv-5\")\n+        val coroutineInfo = ClientInfo(ip = \"2.2.2.2\", userAgent = \"Coroutine\", conversationId = \"conv-6\")\n+\n+        ClientInfoContext.setCurrentClientInfo(original)\n+\n+        // asContextElement는 현재 값(original)을 캡처\n+        val contextElement = ClientInfoContext.asContextElement()\n+\n+        // 값을 변경\n+        ClientInfoContext.setCurrentClientInfo(coroutineInfo)\n+\n+        withContext(contextElement) {\n+            // 코루틴 내에서는 캡처된 original이 복원됨\n+            assertEquals(original, ClientInfoContext.getCurrentClientInfo())\n+        }\n+\n+        // 코루틴 종료 후 coroutineInfo가 복원됨\n+        assertEquals(coroutineInfo, ClientInfoContext.getCurrentClientInfo())\n+    }\n+\n+    @Test\n+    fun `asContextElement with null propagates null`() = runBlocking {\n+        // ClientInfo가 설정되지 않은 상태에서 asContextElement 호출\n+        val contextElement = ClientInfoContext.asContextElement()\n+\n+        val clientInfo = ClientInfo(ip = \"3.3.3.3\", userAgent = \"Agent\", conversationId = \"conv-7\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        withContext(contextElement) {\n+            // 코루틴 내에서는 null로 복원됨\n+            assertNull(ClientInfoContext.getCurrentClientInfo())\n+        }\n+\n+        // 코루틴 종료 후 원래 값 복원\n+        assertEquals(clientInfo, ClientInfoContext.getCurrentClientInfo())\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/HostCodecTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/HostCodecTest.kt\nnew file mode 100644\nindex 000000000..259876b0c\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/HostCodecTest.kt\n@@ -0,0 +1,153 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.params.ParameterizedTest\n+import org.junit.jupiter.params.provider.ValueSource\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNotEquals\n+import kotlin.test.assertTrue\n+\n+/**\n+ * HostCodec 테스트.\n+ * XOR + Base62 인코딩/디코딩의 정합성 검증.\n+ *\n+ * 주의: HostCodec의 XOR_KEY는 환경변수 MCP_SESSION_XOR_KEY에 의존합니다.\n+ * 테스트 환경에서 설정되지 않으면 기본값 \"duplo-mcp-default-key\"가 사용됩니다.\n+ */\n+class HostCodecTest {\n+\n+    @ParameterizedTest(name = \"encode-decode roundtrip: {0}\")\n+    @ValueSource(strings = [\n+        \"10.0.1.5\",\n+        \"192.168.0.1\",\n+        \"my-server.local\",\n+        \"10-0-1-5.default.pod.cluster.local\",\n+        \"localhost\",\n+        \"a\",\n+        \"255.255.255.255\",\n+    ])\n+    fun `encode then decode returns original host`(host: String) {\n+        val encoded = HostCodec.encode(host)\n+        val decoded = HostCodec.decode(encoded)\n+\n+        assertEquals(host, decoded)\n+    }\n+\n+    @Test\n+    fun `encode produces URL-safe output`() {\n+        val encoded = HostCodec.encode(\"10.0.1.5\")\n+\n+        // Base62는 [0-9a-zA-Z]만 사용\n+        assertTrue(encoded.all { it.isLetterOrDigit() }, \"Encoded output should be URL-safe (alphanumeric only): $encoded\")\n+    }\n+\n+    @Test\n+    fun `encode produces non-empty output`() {\n+        val encoded = HostCodec.encode(\"localhost\")\n+\n+        assertTrue(encoded.isNotEmpty())\n+    }\n+\n+    @Test\n+    fun `different hosts produce different encoded values`() {\n+        val encoded1 = HostCodec.encode(\"10.0.1.5\")\n+        val encoded2 = HostCodec.encode(\"10.0.1.6\")\n+\n+        assertNotEquals(encoded1, encoded2)\n+    }\n+\n+    @Test\n+    fun `encode is deterministic - same input produces same output`() {\n+        val host = \"10.0.1.5\"\n+\n+        val encoded1 = HostCodec.encode(host)\n+        val encoded2 = HostCodec.encode(host)\n+\n+        assertEquals(encoded1, encoded2)\n+    }\n+\n+    @Test\n+    fun `encoding uses cache - second call returns same instance`() {\n+        val host = \"cached-host.example.com\"\n+\n+        val encoded1 = HostCodec.encode(host)\n+        val encoded2 = HostCodec.encode(host)\n+\n+        // String interning이 아닌 캐시 동작 확인 - 참조가 동일\n+        assertTrue(encoded1 === encoded2, \"Cache should return the same String instance\")\n+    }\n+\n+    @Test\n+    fun `decoding uses cache - second call returns same instance`() {\n+        val host = \"cached-decode.example.com\"\n+        val encoded = HostCodec.encode(host)\n+\n+        val decoded1 = HostCodec.decode(encoded)\n+        val decoded2 = HostCodec.decode(encoded)\n+\n+        assertTrue(decoded1 === decoded2, \"Decode cache should return the same String instance\")\n+    }\n+\n+    // ================================================================\n+    // Go 호환성 테스트 벡터\n+    //\n+    // 아래 테스트는 기본 XOR_KEY(\"duplo-mcp-default-key\") 사용 시의\n+    // 고정된 입력-출력 쌍을 기록합니다.\n+    // Go에서 HostCodec을 재구현할 때 이 벡터와 동일한 결과가 나와야 합니다.\n+    //\n+    // 환경변수 MCP_SESSION_XOR_KEY가 설정된 경우 이 테스트는 SKIP됩니다.\n+    // ================================================================\n+\n+    @Test\n+    fun `compatibility vector - encode produces consistent output with default key`() {\n+        val xorKeyEnv = System.getenv(\"MCP_SESSION_XOR_KEY\")\n+        if (xorKeyEnv != null) {\n+            // 커스텀 키 사용 시 스킵\n+            return\n+        }\n+\n+        // 기본 XOR_KEY로 인코딩한 고정 벡터\n+        // Go 재구현 시 이 값들과 동일해야 함\n+        val vectors = mapOf(\n+            \"10.0.1.5\" to HostCodec.encode(\"10.0.1.5\"),\n+            \"192.168.0.1\" to HostCodec.encode(\"192.168.0.1\"),\n+            \"localhost\" to HostCodec.encode(\"localhost\"),\n+        )\n+\n+        // 벡터 출력 (Go 구현 참조용 - 테스트 실행 시 stdout에 기록)\n+        println(\"=== HostCodec Go Compatibility Vectors (XOR_KEY=duplo-mcp-default-key) ===\")\n+        vectors.forEach { (input, output) ->\n+            println(\"  input=\\\"$input\\\" -> encoded=\\\"$output\\\"\")\n+        }\n+        println(\"=== End Vectors ===\")\n+\n+        // 값이 URL-safe하고 비어있지 않은지 확인\n+        vectors.values.forEach { encoded ->\n+            assertTrue(encoded.isNotEmpty())\n+            assertTrue(encoded.all { it.isLetterOrDigit() })\n+        }\n+\n+        // Roundtrip 확인\n+        vectors.forEach { (input, encoded) ->\n+            assertEquals(input, HostCodec.decode(encoded))\n+        }\n+    }\n+\n+    @Test\n+    fun `XOR symmetry - xor applied twice returns original`() {\n+        // HostCodec의 XOR은 대칭적이어야 함\n+        // encode → decode가 왕복하는 것으로 간접 검증\n+        val hosts = listOf(\n+            \"10.0.1.5\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"0123456789\",\n+            \"special.chars-in_host.name\",\n+        )\n+\n+        hosts.forEach { host ->\n+            val encoded = HostCodec.encode(host)\n+            val decoded = HostCodec.decode(encoded)\n+            assertEquals(host, decoded, \"XOR symmetry failed for host: $host\")\n+        }\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpMessageBroadcastServiceTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpMessageBroadcastServiceTest.kt\nnew file mode 100644\nindex 000000000..988efe63b\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpMessageBroadcastServiceTest.kt\n@@ -0,0 +1,135 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\n+import io.modelcontextprotocol.spec.McpSchema\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.mockito.kotlin.*\n+import org.springframework.data.redis.core.ReactiveStringRedisTemplate\n+import reactor.core.publisher.Mono\n+import kotlin.test.assertEquals\n+\n+class McpMessageBroadcastServiceTest {\n+\n+    private lateinit var redisTemplate: ReactiveStringRedisTemplate\n+    private lateinit var objectMapper: ObjectMapper\n+    private lateinit var service: McpMessageBroadcastService\n+\n+    @BeforeEach\n+    fun setup() {\n+        redisTemplate = mock {\n+            on { convertAndSend(any(), any<String>()) } doReturn Mono.just(1L)\n+        }\n+        objectMapper = jacksonObjectMapper()\n+        service = McpMessageBroadcastService(redisTemplate, objectMapper)\n+    }\n+\n+    @Test\n+    fun `publish SESSION_EVENT sends envelope to Redis`() {\n+        // JSONRPCNotification (id 없음 → SESSION_EVENT)\n+        val notification = McpSchema.JSONRPCNotification(\"2.0\", \"notifications/tools/list_changed\", null)\n+\n+        service.publish(\"session-1\", notification)\n+\n+        verify(redisTemplate).convertAndSend(\n+            eq(\"mcp-broadcast-message\"),\n+            argThat<String> { json ->\n+                json.contains(\"SESSION_EVENT\") && json.contains(\"session-1\")\n+            },\n+        )\n+    }\n+\n+    @Test\n+    fun `publish STREAMING_RESPONSE sends envelope with requestId`() {\n+        // JSONRPCResponse (id 있음 → STREAMING_RESPONSE)\n+        val response = McpSchema.JSONRPCResponse(\n+            /* jsonrpc = */ \"2.0\",\n+            /* id = */ \"req-42\",\n+            /* result = */ null,\n+            /* error = */ null,\n+        )\n+\n+        service.publish(\"session-2\", response)\n+\n+        verify(redisTemplate).convertAndSend(\n+            eq(\"mcp-broadcast-message\"),\n+            argThat<String> { json ->\n+                json.contains(\"STREAMING_RESPONSE\") &&\n+                    json.contains(\"session-2\") &&\n+                    json.contains(\"req-42\")\n+            },\n+        )\n+    }\n+\n+    @Test\n+    fun `dispatchMessage calls onSessionEvent for SESSION_EVENT`() {\n+        var receivedSessionId: String? = null\n+        var receivedPayload: String? = null\n+\n+        service.onSessionEvent { sessionId, payload ->\n+            receivedSessionId = sessionId\n+            receivedPayload = payload\n+        }\n+        service.onStreamingResponse { _, _, _ -> }\n+\n+        val envelope = mapOf(\n+            \"type\" to \"SESSION_EVENT\",\n+            \"sessionId\" to \"s1\",\n+            \"requestId\" to null,\n+            \"payload\" to \"\"\"{\"test\":\"data\"}\"\"\",\n+        )\n+        val json = objectMapper.writeValueAsString(envelope)\n+\n+        // dispatchMessage는 private이지만, subscribeToMessages 통해 호출됨\n+        // 리플렉션으로 직접 호출\n+        val method = McpMessageBroadcastService::class.java.getDeclaredMethod(\"dispatchMessage\", String::class.java)\n+        method.isAccessible = true\n+        method.invoke(service, json)\n+\n+        assertEquals(\"s1\", receivedSessionId)\n+        assertEquals(\"\"\"{\"test\":\"data\"}\"\"\", receivedPayload)\n+    }\n+\n+    @Test\n+    fun `dispatchMessage calls onStreamingResponse for STREAMING_RESPONSE`() {\n+        var receivedSessionId: String? = null\n+        var receivedRequestId: Any? = null\n+        var receivedPayload: String? = null\n+\n+        service.onSessionEvent { _, _ -> }\n+        service.onStreamingResponse { sessionId, requestId, payload ->\n+            receivedSessionId = sessionId\n+            receivedRequestId = requestId\n+            receivedPayload = payload\n+        }\n+\n+        val envelope = mapOf(\n+            \"type\" to \"STREAMING_RESPONSE\",\n+            \"sessionId\" to \"s2\",\n+            \"requestId\" to \"req-99\",\n+            \"payload\" to \"\"\"{\"result\":\"ok\"}\"\"\",\n+        )\n+        val json = objectMapper.writeValueAsString(envelope)\n+\n+        val method = McpMessageBroadcastService::class.java.getDeclaredMethod(\"dispatchMessage\", String::class.java)\n+        method.isAccessible = true\n+        method.invoke(service, json)\n+\n+        assertEquals(\"s2\", receivedSessionId)\n+        assertEquals(\"req-99\", receivedRequestId)\n+        assertEquals(\"\"\"{\"result\":\"ok\"}\"\"\", receivedPayload)\n+    }\n+\n+    @Test\n+    fun `dispatchMessage with invalid JSON does not throw`() {\n+        service.onSessionEvent { _, _ -> }\n+        service.onStreamingResponse { _, _, _ -> }\n+\n+        val method = McpMessageBroadcastService::class.java.getDeclaredMethod(\"dispatchMessage\", String::class.java)\n+        method.isAccessible = true\n+\n+        // 예외 없이 완료되어야 함\n+        method.invoke(service, \"invalid-json{{{\")\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionIdTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionIdTest.kt\nnew file mode 100644\nindex 000000000..72b81a532\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionIdTest.kt\n@@ -0,0 +1,165 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.api.assertThrows\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertTrue\n+\n+class McpSessionIdTest {\n+\n+    @Test\n+    fun `generate creates a valid session ID`() {\n+        val sessionId = McpSessionId.generate()\n+\n+        assertNotNull(sessionId.host)\n+        assertTrue(sessionId.host.isNotEmpty())\n+        assertNotNull(sessionId.sessionId)\n+        assertTrue(sessionId.sessionId.isNotEmpty())\n+    }\n+\n+    @Test\n+    fun `generate produces format encoded_host colon session_id`() {\n+        val sessionId = McpSessionId.generate()\n+        val str = sessionId.toString()\n+\n+        assertTrue(str.contains(\":\"), \"toString should contain colon separator\")\n+        val parts = str.split(\":\")\n+        assertTrue(parts.size >= 2, \"Should have at least 2 parts separated by colon\")\n+    }\n+\n+    @Test\n+    fun `parse roundtrip - generate then parse returns equivalent object`() {\n+        val original = McpSessionId.generate()\n+        val str = original.toString()\n+        val parsed = McpSessionId.parse(str)\n+\n+        assertEquals(original.host, parsed.host)\n+        assertEquals(original.sessionId, parsed.sessionId)\n+        assertEquals(original, parsed)\n+    }\n+\n+    @Test\n+    fun `parse with known format`() {\n+        val host = \"10.0.1.5\"\n+        val innerSessionId = \"Abc12XyZ\"\n+        val sessionId = McpSessionId(host, innerSessionId)\n+        val str = sessionId.toString()\n+\n+        val parsed = McpSessionId.parse(str)\n+\n+        assertEquals(host, parsed.host)\n+        assertEquals(innerSessionId, parsed.sessionId)\n+    }\n+\n+    @Test\n+    fun `parse throws on empty string`() {\n+        assertThrows<IllegalArgumentException> {\n+            McpSessionId.parse(\"\")\n+        }\n+    }\n+\n+    @Test\n+    fun `parse throws on string without colon`() {\n+        assertThrows<IllegalArgumentException> {\n+            McpSessionId.parse(\"nocolonhere\")\n+        }\n+    }\n+\n+    @Test\n+    fun `parse throws when colon is at start`() {\n+        assertThrows<IllegalArgumentException> {\n+            McpSessionId.parse(\":sessionId\")\n+        }\n+    }\n+\n+    @Test\n+    fun `parse throws when colon is at end`() {\n+        assertThrows<IllegalArgumentException> {\n+            McpSessionId.parse(\"encodedHost:\")\n+        }\n+    }\n+\n+    @Test\n+    fun `extractHost returns correct host`() {\n+        val host = \"10.0.1.5\"\n+        val sessionId = McpSessionId(host, \"testSession\")\n+        val str = sessionId.toString()\n+\n+        val extractedHost = McpSessionId.extractHost(str)\n+\n+        assertEquals(host, extractedHost)\n+    }\n+\n+    @Test\n+    fun `extractHost throws on invalid format`() {\n+        assertThrows<IllegalArgumentException> {\n+            McpSessionId.extractHost(\"nocolon\")\n+        }\n+    }\n+\n+    @Test\n+    fun `isLocalSession returns true for locally generated session`() {\n+        val sessionId = McpSessionId.generate()\n+        val str = sessionId.toString()\n+\n+        assertTrue(McpSessionId.isLocalSession(str))\n+    }\n+\n+    @Test\n+    fun `isLocalSession returns false for foreign host`() {\n+        // 임의의 호스트로 세션 ID를 만들어 로컬이 아닌 것을 확인\n+        val foreignSessionId = McpSessionId(\"definitely-not-local-host-12345\", \"session1\")\n+        val str = foreignSessionId.toString()\n+\n+        assertFalse(McpSessionId.isLocalSession(str))\n+    }\n+\n+    @Test\n+    fun `toString and parse are inverse operations`() {\n+        val hosts = listOf(\"10.0.1.5\", \"192.168.0.1\", \"my-server.local\")\n+        val sessions = listOf(\"abc\", \"XyZ123\", \"short\")\n+\n+        hosts.forEach { host ->\n+            sessions.forEach { session ->\n+                val original = McpSessionId(host, session)\n+                val str = original.toString()\n+                val parsed = McpSessionId.parse(str)\n+\n+                assertEquals(original, parsed, \"Roundtrip failed for host=$host, session=$session\")\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun `parse uses lastIndexOf for colon - handles session IDs containing colons`() {\n+        // Session ID 자체에 콜론이 없는 것이 일반적이지만,\n+        // parse는 lastIndexOf를 사용하므로 encoded host에 콜론이 있어도 안전\n+        val host = \"10.0.1.5\"\n+        val sessionId = McpSessionId(host, \"session123\")\n+        val str = sessionId.toString()\n+\n+        // 정상 파싱 확인\n+        val parsed = McpSessionId.parse(str)\n+        assertEquals(host, parsed.host)\n+        assertEquals(\"session123\", parsed.sessionId)\n+    }\n+\n+    @Test\n+    fun `generate produces unique session IDs`() {\n+        val ids = (1..10).map { McpSessionId.generate().toString() }.toSet()\n+\n+        assertEquals(10, ids.size, \"Generated session IDs should be unique\")\n+    }\n+\n+    @Test\n+    fun `data class equality works correctly`() {\n+        val id1 = McpSessionId(\"host1\", \"session1\")\n+        val id2 = McpSessionId(\"host1\", \"session1\")\n+        val id3 = McpSessionId(\"host1\", \"session2\")\n+\n+        assertEquals(id1, id2)\n+        assertFalse(id1 == id3)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServiceTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServiceTest.kt\nnew file mode 100644\nindex 000000000..de2c87ff3\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServiceTest.kt\n@@ -0,0 +1,207 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\n+import com.querypie.duplo.common.redis.TracedMessage\n+import io.modelcontextprotocol.spec.McpServerSession\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.mockito.kotlin.*\n+import org.springframework.data.redis.connection.DefaultMessage\n+import org.springframework.data.redis.core.RedisTemplate\n+import org.springframework.data.redis.listener.ChannelTopic\n+import org.springframework.data.redis.listener.RedisMessageListenerContainer\n+import kotlin.test.assertEquals\n+import kotlin.test.assertTrue\n+\n+class McpSessionManagementServiceTest {\n+\n+    private lateinit var sessionManager: McpSessionManager\n+    private lateinit var objectMapper: ObjectMapper\n+    private lateinit var deleteRedisTemplate: RedisTemplate<String, TracedMessage<McpSessionManagementService.SessionDeleteRequest>>\n+    private lateinit var queryRedisTemplate: RedisTemplate<String, TracedMessage<McpSessionManagementService.SessionQueryMessage>>\n+    private lateinit var listenerContainer: RedisMessageListenerContainer\n+    private lateinit var service: McpSessionManagementService\n+\n+    @BeforeEach\n+    fun setup() {\n+        sessionManager = mock()\n+        objectMapper = jacksonObjectMapper()\n+        deleteRedisTemplate = mock()\n+        queryRedisTemplate = mock()\n+        listenerContainer = mock()\n+        service = McpSessionManagementService(\n+            sessionManager = sessionManager,\n+            objectMapper = objectMapper,\n+            deleteRedisTemplate = deleteRedisTemplate,\n+            queryRedisTemplate = queryRedisTemplate,\n+            listenerContainer = listenerContainer,\n+        )\n+    }\n+\n+    @Test\n+    fun `broadcastSessionDelete sends message to delete topic`() {\n+        val request = McpSessionManagementService.SessionDeleteRequest.SessionId(\"session-1\")\n+\n+        service.broadcastSessionDelete(request)\n+\n+        verify(deleteRedisTemplate).convertAndSend(\n+            eq(\"duplo:proxy:mcp-session-management:delete\"),\n+            any<TracedMessage<McpSessionManagementService.SessionDeleteRequest>>(),\n+        )\n+    }\n+\n+    @Test\n+    fun `broadcastSessionDelete with AgentInstallationId sends message`() {\n+        val request = McpSessionManagementService.SessionDeleteRequest.AgentInstallationId(\"agent-123\")\n+\n+        service.broadcastSessionDelete(request)\n+\n+        verify(deleteRedisTemplate).convertAndSend(\n+            eq(\"duplo:proxy:mcp-session-management:delete\"),\n+            any<TracedMessage<McpSessionManagementService.SessionDeleteRequest>>(),\n+        )\n+    }\n+\n+    @Test\n+    fun `onSessionDeleted registers handler`() {\n+        var deletedSessionId: String? = null\n+        service.onSessionDeleted { deletedSessionId = it }\n+\n+        // processDeleteRequest를 직접 호출할 수 없으므로 onMessage를 시뮬레이션\n+        // SessionId 삭제 요청 메시지 생성\n+        val request = McpSessionManagementService.SessionDeleteRequest.SessionId(\"session-xyz\")\n+        val traced = TracedMessage.of(request)\n+        val messageBody = objectMapper.writeValueAsBytes(traced)\n+        val channel = \"duplo:proxy:mcp-session-management:delete\".toByteArray()\n+        val message = DefaultMessage(channel, messageBody)\n+\n+        whenever(sessionManager.remove(\"session-xyz\")).thenReturn(\n+            SessionContext(\n+                sessionFactory = mock(),\n+                session = mock<McpServerSession>(),\n+                clientInfo = null,\n+                baseUrl = \"/test\",\n+                sessionId = \"session-xyz\",\n+                requiresKeepAlivePing = true,\n+            )\n+        )\n+\n+        service.onMessage(message, null)\n+\n+        assertEquals(\"session-xyz\", deletedSessionId)\n+    }\n+\n+    @Test\n+    fun `onMessage DELETE_TOPIC with SessionId removes session and calls handlers`() {\n+        val mockSession = mock<McpServerSession>()\n+        val context = SessionContext(\n+            sessionFactory = mock(),\n+            session = mockSession,\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = \"s1\",\n+            requiresKeepAlivePing = true,\n+        )\n+        whenever(sessionManager.remove(\"s1\")).thenReturn(context)\n+\n+        val request = McpSessionManagementService.SessionDeleteRequest.SessionId(\"s1\")\n+        val traced = TracedMessage.of(request)\n+        val messageBody = objectMapper.writeValueAsBytes(traced)\n+        val channel = \"duplo:proxy:mcp-session-management:delete\".toByteArray()\n+        val message = DefaultMessage(channel, messageBody)\n+\n+        service.onMessage(message, null)\n+\n+        verify(sessionManager).remove(\"s1\")\n+        verify(mockSession).close()\n+    }\n+\n+    @Test\n+    fun `onMessage DELETE_TOPIC with AgentInstallationId removes matching sessions`() {\n+        val mockSession1 = mock<McpServerSession>()\n+        val mockSession2 = mock<McpServerSession>()\n+        val ctx1 = SessionContext(\n+            sessionFactory = mock(),\n+            session = mockSession1,\n+            clientInfo = null,\n+            baseUrl = \"/agents/agent-456/connector\",\n+            sessionId = \"s1\",\n+            requiresKeepAlivePing = true,\n+        )\n+        val ctx2 = SessionContext(\n+            sessionFactory = mock(),\n+            session = mockSession2,\n+            clientInfo = null,\n+            baseUrl = \"/other/path\",\n+            sessionId = \"s2\",\n+            requiresKeepAlivePing = true,\n+        )\n+\n+        whenever(sessionManager.values).thenReturn(mutableListOf(ctx1, ctx2))\n+        whenever(sessionManager.remove(\"s1\")).thenReturn(ctx1)\n+\n+        val request = McpSessionManagementService.SessionDeleteRequest.AgentInstallationId(\"agent-456\")\n+        val traced = TracedMessage.of(request)\n+        val messageBody = objectMapper.writeValueAsBytes(traced)\n+        val channel = \"duplo:proxy:mcp-session-management:delete\".toByteArray()\n+        val message = DefaultMessage(channel, messageBody)\n+\n+        service.onMessage(message, null)\n+\n+        verify(sessionManager).remove(\"s1\")\n+        verify(mockSession1).close()\n+        // s2는 매칭되지 않으므로 제거되지 않음\n+        verify(sessionManager, never()).remove(\"s2\")\n+    }\n+\n+    @Test\n+    fun `start registers message listeners`() {\n+        service.start()\n+\n+        assertTrue(service.isRunning)\n+        verify(listenerContainer, times(2)).addMessageListener(eq(service), any<ChannelTopic>())\n+    }\n+\n+    @Test\n+    fun `stop removes message listeners`() {\n+        service.start()\n+        service.stop()\n+\n+        kotlin.test.assertFalse(service.isRunning)\n+        verify(listenerContainer, times(2)).removeMessageListener(eq(service), any<ChannelTopic>())\n+    }\n+\n+    @Test\n+    fun `start is idempotent`() {\n+        service.start()\n+        service.start()\n+\n+        verify(listenerContainer, times(2)).addMessageListener(eq(service), any<ChannelTopic>())\n+    }\n+\n+    @Test\n+    fun `stop is idempotent`() {\n+        service.start()\n+        service.stop()\n+        service.stop()\n+\n+        verify(listenerContainer, times(2)).removeMessageListener(eq(service), any<ChannelTopic>())\n+    }\n+\n+    @Test\n+    fun `SessionQueryResult isExists returns correct values`() {\n+        assertTrue(McpSessionManagementService.SessionQueryResult.EXISTS.isExists())\n+        kotlin.test.assertFalse(McpSessionManagementService.SessionQueryResult.NOT_EXISTS.isExists())\n+        kotlin.test.assertFalse(McpSessionManagementService.SessionQueryResult.TIMEOUT.isExists())\n+    }\n+\n+    @Test\n+    fun `SessionDeleteRequest types are correct`() {\n+        val sessionId = McpSessionManagementService.SessionDeleteRequest.SessionId(\"s1\")\n+        val agentId = McpSessionManagementService.SessionDeleteRequest.AgentInstallationId(\"a1\")\n+\n+        assertEquals(\"s1\", sessionId.value)\n+        assertEquals(\"a1\", agentId.value)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServletTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServletTest.kt\nnew file mode 100644\nindex 000000000..ca8c188bc\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServletTest.kt\n@@ -0,0 +1,203 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\n+import com.fasterxml.jackson.module.kotlin.readValue\n+import io.modelcontextprotocol.spec.McpServerSession\n+import jakarta.servlet.http.HttpServletRequest\n+import jakarta.servlet.http.HttpServletResponse\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.mockito.kotlin.*\n+import java.io.PrintWriter\n+import java.io.StringWriter\n+import kotlin.test.assertEquals\n+import kotlin.test.assertTrue\n+\n+class McpSessionManagementServletTest {\n+\n+    private lateinit var mcpSessionService: McpSessionService\n+    private lateinit var mcpSessionManager: McpSessionManager\n+    private lateinit var objectMapper: ObjectMapper\n+    private lateinit var servlet: McpSessionManagementServlet\n+\n+    @BeforeEach\n+    fun setup() {\n+        mcpSessionService = mock()\n+        mcpSessionManager = mock()\n+        objectMapper = jacksonObjectMapper()\n+        servlet = McpSessionManagementServlet(mcpSessionService, mcpSessionManager, objectMapper)\n+    }\n+\n+    private fun mockRequest(method: String, uri: String): HttpServletRequest {\n+        return mock {\n+            on { this.requestURI } doReturn uri\n+            on { this.method } doReturn method\n+            on { getProtocol() } doReturn \"HTTP/1.1\"\n+        }\n+    }\n+\n+    private fun createMockResponse(): Pair<HttpServletResponse, StringWriter> {\n+        val stringWriter = StringWriter()\n+        val printWriter = PrintWriter(stringWriter)\n+        val response = mock<HttpServletResponse> {\n+            on { writer } doReturn printWriter\n+        }\n+        return response to stringWriter\n+    }\n+\n+    // === GET Tests ===\n+\n+    @Test\n+    fun `GET sessions returns session ID list`() {\n+        val ctx1 = SessionContext(\n+            sessionFactory = mock(),\n+            session = mock<McpServerSession>(),\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = \"session-1\",\n+            requiresKeepAlivePing = true,\n+        )\n+        val ctx2 = SessionContext(\n+            sessionFactory = mock(),\n+            session = mock<McpServerSession>(),\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = \"session-2\",\n+            requiresKeepAlivePing = true,\n+        )\n+        whenever(mcpSessionManager.values).thenReturn(mutableListOf(ctx1, ctx2))\n+\n+        val req = mockRequest(\"GET\", \"/internal/sessions\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_OK\n+        verify(res).contentType = \"application/json; charset=UTF-8\"\n+\n+        val body = stringWriter.toString()\n+        val sessionIds: List<String> = objectMapper.readValue(body)\n+        assertEquals(2, sessionIds.size)\n+        assertTrue(sessionIds.contains(\"session-1\"))\n+        assertTrue(sessionIds.contains(\"session-2\"))\n+    }\n+\n+    @Test\n+    fun `GET sessions with trailing slash returns session list`() {\n+        whenever(mcpSessionManager.values).thenReturn(mutableListOf())\n+\n+        val req = mockRequest(\"GET\", \"/internal/sessions/\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_OK\n+        val body = stringWriter.toString()\n+        val sessionIds: List<String> = objectMapper.readValue(body)\n+        assertTrue(sessionIds.isEmpty())\n+    }\n+\n+    @Test\n+    fun `GET unknown path returns 404`() {\n+        val req = mockRequest(\"GET\", \"/internal/unknown\")\n+        val (res, _) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_NOT_FOUND\n+    }\n+\n+    // === DELETE Tests ===\n+\n+    @Test\n+    fun `DELETE by sessionId removes session and returns 200`() {\n+        val mockSession = mock<McpServerSession>()\n+        val context = SessionContext(\n+            sessionFactory = mock(),\n+            session = mockSession,\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = \"session-123\",\n+            requiresKeepAlivePing = true,\n+        )\n+        whenever(mcpSessionService.removeSession(\"session-123\")).thenReturn(context)\n+        whenever(mcpSessionManager.size).thenReturn(0)\n+\n+        val req = mockRequest(\"DELETE\", \"/internal/sessions/session-123\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_OK\n+        verify(mcpSessionService).removeSession(\"session-123\")\n+        verify(mcpSessionService).broadcastRemoveSessionBySessionId(\"session-123\")\n+\n+        val body = stringWriter.toString()\n+        assertTrue(body.contains(\"Session terminated\"))\n+    }\n+\n+    @Test\n+    fun `DELETE by sessionId when not found still returns 200`() {\n+        whenever(mcpSessionService.removeSession(\"missing\")).thenReturn(null)\n+\n+        val req = mockRequest(\"DELETE\", \"/internal/sessions/missing\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_OK\n+        verify(mcpSessionService).broadcastRemoveSessionBySessionId(\"missing\")\n+\n+        val body = stringWriter.toString()\n+        assertTrue(body.contains(\"already cleaned up\"))\n+    }\n+\n+    @Test\n+    fun `DELETE by agentId returns 202 Accepted`() {\n+        val req = mockRequest(\"DELETE\", \"/internal/sessions/agent/agent-xyz\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_ACCEPTED\n+        verify(mcpSessionService).broadcastRemoveSessionByAgentInstallationId(\"agent-xyz\")\n+\n+        val body = stringWriter.toString()\n+        assertTrue(body.contains(\"Session removal initiated\"))\n+    }\n+\n+    @Test\n+    fun `DELETE by blank agentId returns 400`() {\n+        val req = mockRequest(\"DELETE\", \"/internal/sessions/agent/\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_BAD_REQUEST\n+        val body = stringWriter.toString()\n+        assertTrue(body.contains(\"Agent ID is missing\"))\n+    }\n+\n+    @Test\n+    fun `DELETE with blank sessionId returns 400`() {\n+        val req = mockRequest(\"DELETE\", \"/internal/sessions/\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_BAD_REQUEST\n+    }\n+\n+    @Test\n+    fun `DELETE unsupported path returns 400`() {\n+        val req = mockRequest(\"DELETE\", \"/internal/unknown-path\")\n+        val (res, stringWriter) = createMockResponse()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_BAD_REQUEST\n+        val body = stringWriter.toString()\n+        assertTrue(body.contains(\"Unsupported path\"))\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagerTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagerTest.kt\nnew file mode 100644\nindex 000000000..a92c8001a\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagerTest.kt\n@@ -0,0 +1,260 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import com.querypie.duplo.mcp.proxy.config.ProxyConfig\n+import com.querypie.duplo.mcp.proxy.infra.metric.McpMetricService\n+import io.modelcontextprotocol.spec.McpServerSession\n+import org.junit.jupiter.api.AfterEach\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.mockito.kotlin.mock\n+import org.mockito.kotlin.times\n+import org.mockito.kotlin.verify\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFalse\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertNull\n+import kotlin.test.assertTrue\n+\n+class McpSessionManagerTest {\n+\n+    private lateinit var mcpMetricService: McpMetricService\n+    private lateinit var sessionManager: McpSessionManager\n+\n+    @BeforeEach\n+    fun setup() {\n+        mcpMetricService = mock()\n+    }\n+\n+    @AfterEach\n+    fun teardown() {\n+        if (::sessionManager.isInitialized) {\n+            sessionManager.close()\n+        }\n+    }\n+\n+    private fun createManager(connPerPath: Int = 0): McpSessionManager {\n+        val limitProperties = ProxyConfig.LimitProperties(connPerPath = connPerPath)\n+        sessionManager = McpSessionManager(limitProperties, mcpMetricService)\n+        return sessionManager\n+    }\n+\n+    private fun createSessionContext(\n+        baseUrl: String = \"/test/path\",\n+        sessionId: String = \"test-session\",\n+    ): SessionContext {\n+        return SessionContext(\n+            sessionFactory = mock(),\n+            session = mock<McpServerSession>(),\n+            clientInfo = ClientInfo(ip = \"1.1.1.1\", userAgent = \"TestAgent\", conversationId = \"conv-1\"),\n+            baseUrl = baseUrl,\n+            sessionId = sessionId,\n+            requiresKeepAlivePing = true,\n+        )\n+    }\n+\n+    @Test\n+    fun `set stores session and get retrieves it`() {\n+        val manager = createManager()\n+        val context = createSessionContext(sessionId = \"session-1\")\n+\n+        manager[\"session-1\"] = context\n+\n+        val retrieved = manager[\"session-1\"]\n+        assertNotNull(retrieved)\n+        assertEquals(\"session-1\", retrieved.sessionId)\n+    }\n+\n+    @Test\n+    fun `get returns null for non-existent session`() {\n+        val manager = createManager()\n+\n+        assertNull(manager[\"non-existent\"])\n+    }\n+\n+    @Test\n+    fun `set increments countByPath`() {\n+        val manager = createManager()\n+        val ctx1 = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+        val ctx2 = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s2\")\n+        val ctx3 = createSessionContext(baseUrl = \"/path/b\", sessionId = \"s3\")\n+\n+        manager[\"s1\"] = ctx1\n+        manager[\"s2\"] = ctx2\n+        manager[\"s3\"] = ctx3\n+\n+        assertEquals(2, manager.countByBaseUrl(\"/path/a\"))\n+        assertEquals(1, manager.countByBaseUrl(\"/path/b\"))\n+    }\n+\n+    @Test\n+    fun `countByBaseUrl returns 0 for unknown path`() {\n+        val manager = createManager()\n+\n+        assertEquals(0, manager.countByBaseUrl(\"/unknown\"))\n+    }\n+\n+    @Test\n+    fun `remove removes session and decrements countByPath`() {\n+        val manager = createManager()\n+        val ctx = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+        manager[\"s1\"] = ctx\n+\n+        assertEquals(1, manager.countByBaseUrl(\"/path/a\"))\n+\n+        val removed = manager.remove(\"s1\")\n+\n+        assertNotNull(removed)\n+        assertEquals(\"s1\", removed.sessionId)\n+        assertNull(manager[\"s1\"])\n+        assertEquals(0, manager.countByBaseUrl(\"/path/a\"))\n+    }\n+\n+    @Test\n+    fun `remove returns null for non-existent session`() {\n+        val manager = createManager()\n+\n+        assertNull(manager.remove(\"non-existent\"))\n+    }\n+\n+    @Test\n+    fun `set calls metric incrementSessionCreated and incrementActiveSessions`() {\n+        val manager = createManager()\n+        val ctx = createSessionContext()\n+\n+        manager[\"s1\"] = ctx\n+\n+        verify(mcpMetricService).incrementSessionCreated()\n+        verify(mcpMetricService).incrementActiveSessions()\n+    }\n+\n+    @Test\n+    fun `remove calls metric incrementSessionClosed and decrementActiveSessions`() {\n+        val manager = createManager()\n+        val ctx = createSessionContext(sessionId = \"s1\")\n+        manager[\"s1\"] = ctx\n+\n+        manager.remove(\"s1\")\n+\n+        verify(mcpMetricService).incrementSessionClosed()\n+        verify(mcpMetricService).decrementActiveSessions()\n+    }\n+\n+    @Test\n+    fun `remove for non-existent session does not call metrics`() {\n+        val manager = createManager()\n+\n+        manager.remove(\"non-existent\")\n+\n+        verify(mcpMetricService, times(0)).incrementSessionClosed()\n+        verify(mcpMetricService, times(0)).decrementActiveSessions()\n+    }\n+\n+    @Test\n+    fun `isLimitExceeded returns false when connPerPath is 0 (unlimited)`() {\n+        val manager = createManager(connPerPath = 0)\n+        val ctx = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+        manager[\"s1\"] = ctx\n+\n+        assertFalse(manager.isLimitExceeded(\"/path/a\"))\n+    }\n+\n+    @Test\n+    fun `isLimitExceeded returns false when under limit`() {\n+        val manager = createManager(connPerPath = 3)\n+        manager[\"s1\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+        manager[\"s2\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s2\")\n+\n+        assertFalse(manager.isLimitExceeded(\"/path/a\"))\n+    }\n+\n+    @Test\n+    fun `isLimitExceeded returns true when at limit`() {\n+        val manager = createManager(connPerPath = 2)\n+        manager[\"s1\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+        manager[\"s2\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s2\")\n+\n+        assertTrue(manager.isLimitExceeded(\"/path/a\"))\n+    }\n+\n+    @Test\n+    fun `isLimitExceeded returns true when over limit`() {\n+        val manager = createManager(connPerPath = 1)\n+        manager[\"s1\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+        manager[\"s2\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s2\")\n+\n+        assertTrue(manager.isLimitExceeded(\"/path/a\"))\n+    }\n+\n+    @Test\n+    fun `isLimitExceeded is path-independent`() {\n+        val manager = createManager(connPerPath = 1)\n+        manager[\"s1\"] = createSessionContext(baseUrl = \"/path/a\", sessionId = \"s1\")\n+\n+        // /path/b는 아직 연결 없으므로 limit 초과하지 않음\n+        assertFalse(manager.isLimitExceeded(\"/path/b\"))\n+    }\n+\n+    @Test\n+    fun `size reflects session count`() {\n+        val manager = createManager()\n+\n+        assertEquals(0, manager.size)\n+\n+        manager[\"s1\"] = createSessionContext(sessionId = \"s1\")\n+        assertEquals(1, manager.size)\n+\n+        manager[\"s2\"] = createSessionContext(sessionId = \"s2\")\n+        assertEquals(2, manager.size)\n+\n+        manager.remove(\"s1\")\n+        assertEquals(1, manager.size)\n+    }\n+\n+    @Test\n+    fun `values returns all session contexts`() {\n+        val manager = createManager()\n+        manager[\"s1\"] = createSessionContext(sessionId = \"s1\")\n+        manager[\"s2\"] = createSessionContext(sessionId = \"s2\")\n+\n+        val values = manager.values\n+        assertEquals(2, values.size)\n+    }\n+\n+    @Test\n+    fun `close cancels coroutine scope without affecting stored sessions`() {\n+        val manager = createManager()\n+        manager[\"s1\"] = createSessionContext(sessionId = \"s1\")\n+\n+        // close만 호출 - 예외 없이 완료되어야 함\n+        manager.close()\n+\n+        // close 후에도 세션 데이터는 남아있음 (coroutineScope만 취소)\n+        assertNotNull(manager[\"s1\"])\n+    }\n+\n+    @Test\n+    fun `multiple set and remove operations maintain consistency`() {\n+        val manager = createManager()\n+\n+        // 10개 세션 추가\n+        repeat(10) { i ->\n+            manager[\"s$i\"] = createSessionContext(baseUrl = \"/path\", sessionId = \"s$i\")\n+        }\n+        assertEquals(10, manager.size)\n+        assertEquals(10, manager.countByBaseUrl(\"/path\"))\n+\n+        // 5개 제거\n+        repeat(5) { i ->\n+            manager.remove(\"s$i\")\n+        }\n+        assertEquals(5, manager.size)\n+        assertEquals(5, manager.countByBaseUrl(\"/path\"))\n+\n+        // 3개 추가\n+        repeat(3) { i ->\n+            manager[\"new$i\"] = createSessionContext(baseUrl = \"/path\", sessionId = \"new$i\")\n+        }\n+        assertEquals(8, manager.size)\n+        assertEquals(8, manager.countByBaseUrl(\"/path\"))\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionServiceTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionServiceTest.kt\nnew file mode 100644\nindex 000000000..f8b3187e6\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionServiceTest.kt\n@@ -0,0 +1,184 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import io.modelcontextprotocol.spec.McpServerSession\n+import io.modelcontextprotocol.spec.McpServerTransport\n+import org.junit.jupiter.api.AfterEach\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.api.assertThrows\n+import org.mockito.kotlin.*\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertNull\n+\n+class McpSessionServiceTest {\n+\n+    private lateinit var mcpSessionManager: McpSessionManager\n+    private lateinit var mcpSessionManagementService: McpSessionManagementService\n+    private lateinit var sessionService: McpSessionService\n+\n+    @BeforeEach\n+    fun setup() {\n+        mcpSessionManager = mock()\n+        mcpSessionManagementService = mock()\n+        sessionService = McpSessionService(mcpSessionManager, mcpSessionManagementService)\n+    }\n+\n+    @AfterEach\n+    fun cleanup() {\n+        ClientInfoContext.clearCurrentClientInfo()\n+    }\n+\n+    @Test\n+    fun `createSession stores session in manager`() {\n+        val clientInfo = ClientInfo(ip = \"1.1.1.1\", userAgent = \"Agent\", conversationId = \"conv-1\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        val mockSession = mock<McpServerSession>()\n+        val sessionFactory = mock<McpServerSessionFactory> {\n+            on { create(any(), eq(clientInfo)) } doReturn mockSession\n+        }\n+        val sessionTransport = mock<McpServerTransport>()\n+\n+        sessionService.createSession(\n+            sessionId = \"test-session\",\n+            sessionFactory = sessionFactory,\n+            sessionTransport = sessionTransport,\n+            baseUrl = \"/test/path\",\n+        )\n+\n+        verify(mcpSessionManager)[eq(\"test-session\")] = argThat<SessionContext> {\n+            this.sessionId == \"test-session\" &&\n+                this.baseUrl == \"/test/path\" &&\n+                this.clientInfo == clientInfo &&\n+                this.session == mockSession &&\n+                this.requiresKeepAlivePing // 일반 transport는 ping 필요\n+        }\n+    }\n+\n+    @Test\n+    fun `createSession with SelfManagedKeepAliveTransport sets requiresKeepAlivePing to false`() {\n+        val clientInfo = ClientInfo(ip = \"1.1.1.1\", userAgent = \"Agent\", conversationId = \"conv-1\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        val mockSession = mock<McpServerSession>()\n+        val sessionFactory = mock<McpServerSessionFactory> {\n+            on { create(any(), eq(clientInfo)) } doReturn mockSession\n+        }\n+        // SelfManagedKeepAliveTransport를 구현한 mock\n+        val selfManagedTransport = mock<McpServerTransport>(\n+            extraInterfaces = arrayOf(SelfManagedKeepAliveTransport::class),\n+        )\n+\n+        sessionService.createSession(\n+            sessionId = \"self-managed\",\n+            sessionFactory = sessionFactory,\n+            sessionTransport = selfManagedTransport,\n+            baseUrl = \"/test/path\",\n+        )\n+\n+        verify(mcpSessionManager)[eq(\"self-managed\")] = argThat<SessionContext> {\n+            !this.requiresKeepAlivePing\n+        }\n+    }\n+\n+    @Test\n+    fun `createSession throws when ClientInfo is not set`() {\n+        val sessionFactory = mock<McpServerSessionFactory>()\n+        val sessionTransport = mock<McpServerTransport>()\n+\n+        assertThrows<IllegalStateException> {\n+            sessionService.createSession(\n+                sessionId = \"no-client\",\n+                sessionFactory = sessionFactory,\n+                sessionTransport = sessionTransport,\n+                baseUrl = \"/test/path\",\n+            )\n+        }\n+    }\n+\n+    @Test\n+    fun `removeSession removes from manager and closes session`() {\n+        val mockSession = mock<McpServerSession>()\n+        val context = SessionContext(\n+            sessionFactory = mock(),\n+            session = mockSession,\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = \"s1\",\n+            requiresKeepAlivePing = true,\n+        )\n+        whenever(mcpSessionManager.remove(\"s1\")).thenReturn(context)\n+\n+        val result = sessionService.removeSession(\"s1\")\n+\n+        assertNotNull(result)\n+        assertEquals(\"s1\", result.sessionId)\n+        verify(mockSession).close()\n+        verify(mcpSessionManager).remove(\"s1\")\n+    }\n+\n+    @Test\n+    fun `removeSession returns null for non-existent session`() {\n+        whenever(mcpSessionManager.remove(\"missing\")).thenReturn(null)\n+\n+        val result = sessionService.removeSession(\"missing\")\n+\n+        assertNull(result)\n+    }\n+\n+    @Test\n+    fun `getSession delegates to manager`() {\n+        val context = SessionContext(\n+            sessionFactory = mock(),\n+            session = mock<McpServerSession>(),\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = \"s1\",\n+            requiresKeepAlivePing = true,\n+        )\n+        whenever(mcpSessionManager[\"s1\"]).thenReturn(context)\n+\n+        val result = sessionService.getSession(\"s1\")\n+\n+        assertNotNull(result)\n+        assertEquals(\"s1\", result.sessionId)\n+    }\n+\n+    @Test\n+    fun `broadcastRemoveSessionBySessionId delegates to management service`() {\n+        sessionService.broadcastRemoveSessionBySessionId(\"session-123\")\n+\n+        verify(mcpSessionManagementService).broadcastSessionDelete(\n+            McpSessionManagementService.SessionDeleteRequest.SessionId(\"session-123\")\n+        )\n+    }\n+\n+    @Test\n+    fun `broadcastRemoveSessionByAgentInstallationId delegates to management service`() {\n+        sessionService.broadcastRemoveSessionByAgentInstallationId(\"agent-456\")\n+\n+        verify(mcpSessionManagementService).broadcastSessionDelete(\n+            McpSessionManagementService.SessionDeleteRequest.AgentInstallationId(\"agent-456\")\n+        )\n+    }\n+\n+    @Test\n+    fun `onSessionDeleted delegates to management service`() {\n+        val handler: (String) -> Unit = {}\n+\n+        sessionService.onSessionDeleted(handler)\n+\n+        verify(mcpSessionManagementService).onSessionDeleted(handler)\n+    }\n+\n+    @Test\n+    fun `querySession delegates to management service`() {\n+        whenever(mcpSessionManagementService.querySession(\"s1\"))\n+            .thenReturn(McpSessionManagementService.SessionQueryResult.EXISTS)\n+\n+        val result = sessionService.querySession(\"s1\")\n+\n+        assertEquals(McpSessionManagementService.SessionQueryResult.EXISTS, result)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpToolManagerTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpToolManagerTest.kt\nnew file mode 100644\nindex 000000000..bea205463\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpToolManagerTest.kt\n@@ -0,0 +1,305 @@\n+package com.querypie.duplo.mcp.proxy.mcp\n+\n+import com.querypie.duplo.mcp.connector.api.Mcp\n+import org.junit.jupiter.api.AfterEach\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.api.assertThrows\n+import org.mockito.kotlin.*\n+import java.time.Instant\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertNull\n+import kotlin.test.assertTrue\n+\n+class McpToolManagerTest {\n+\n+    private var toolManager: McpToolManager? = null\n+\n+    @AfterEach\n+    fun teardown() {\n+        toolManager?.close()\n+    }\n+\n+    private fun createTool(name: String): Mcp.Tool {\n+        return Mcp.Tool(name = name, description = \"Test tool: $name\")\n+    }\n+\n+    private fun createToolSpec(tool: Mcp.Tool): Mcp.ToolSpecification {\n+        val handler = object : Mcp.ToolHandler {\n+            override fun handle(params: Map<String, Any?>) = Mcp.CallToolResult.ofText(\"result\")\n+            override fun close() {}\n+        }\n+        return Mcp.ToolSpecification(tool = tool, handler = handler)\n+    }\n+\n+    @Test\n+    fun `getTools loads tools on first call`() {\n+        val tools = listOf(createTool(\"tool1\"), createTool(\"tool2\"))\n+        var lastModified = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { tools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { lastModified },\n+        )\n+\n+        val result = toolManager!!.getTools()\n+\n+        assertEquals(2, result.size)\n+        assertEquals(\"tool1\", result[0].name)\n+        assertEquals(\"tool2\", result[1].name)\n+    }\n+\n+    @Test\n+    fun `getTools returns cached tools when lastModified has not changed`() {\n+        var callCount = 0\n+        val tools = listOf(createTool(\"tool1\"))\n+        val fixedTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { callCount++; tools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { fixedTime },\n+        )\n+\n+        toolManager!!.getTools()\n+        toolManager!!.getTools()\n+        toolManager!!.getTools()\n+\n+        // 최초 1번만 loader 호출됨\n+        assertEquals(1, callCount)\n+    }\n+\n+    @Test\n+    fun `getTools reloads when lastModified changes`() {\n+        var callCount = 0\n+        var currentTime = Instant.now()\n+        val tools = listOf(createTool(\"tool1\"))\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { callCount++; tools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        toolManager!!.getTools()\n+        assertEquals(1, callCount)\n+\n+        // 시간 변경\n+        currentTime = currentTime.plusSeconds(10)\n+        toolManager!!.getTools()\n+        assertEquals(2, callCount)\n+    }\n+\n+    @Test\n+    fun `getTools detects added tools`() {\n+        var currentTools = listOf(createTool(\"tool1\"))\n+        var currentTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { currentTools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        val initial = toolManager!!.getTools()\n+        assertEquals(1, initial.size)\n+\n+        // 도구 추가\n+        currentTools = listOf(createTool(\"tool1\"), createTool(\"tool2\"))\n+        currentTime = currentTime.plusSeconds(10)\n+\n+        val updated = toolManager!!.getTools()\n+        assertEquals(2, updated.size)\n+    }\n+\n+    @Test\n+    fun `getTools detects removed tools and cleans up handlers`() {\n+        val tool1 = createTool(\"tool1\")\n+        val tool2 = createTool(\"tool2\")\n+        var currentTools = listOf(tool1, tool2)\n+        var currentTime = Instant.now()\n+\n+        val closedHandlers = mutableListOf<String>()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { currentTools },\n+            toolSpecLoader = { tool ->\n+                val handler = object : Mcp.ToolHandler {\n+                    override fun handle(params: Map<String, Any?>) = Mcp.CallToolResult.ofText(\"result\")\n+                    override fun close() { closedHandlers.add(tool.name) }\n+                }\n+                Mcp.ToolSpecification(tool = tool, handler = handler)\n+            },\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        toolManager!!.getTools()\n+        // handler를 로드시킴\n+        toolManager!!.getToolHandler(tool1)\n+        toolManager!!.getToolHandler(tool2)\n+\n+        // tool2 제거\n+        currentTools = listOf(tool1)\n+        currentTime = currentTime.plusSeconds(10)\n+        toolManager!!.getTools()\n+\n+        assertTrue(closedHandlers.contains(\"tool2\"))\n+    }\n+\n+    @Test\n+    fun `findToolByName returns tool when exists`() {\n+        val tools = listOf(createTool(\"tool1\"), createTool(\"tool2\"))\n+        var currentTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { tools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        val found = toolManager!!.findToolByName(\"tool2\")\n+        assertNotNull(found)\n+        assertEquals(\"tool2\", found.name)\n+    }\n+\n+    @Test\n+    fun `findToolByName returns null when not exists`() {\n+        val tools = listOf(createTool(\"tool1\"))\n+        var currentTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { tools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        assertNull(toolManager!!.findToolByName(\"nonexistent\"))\n+    }\n+\n+    @Test\n+    fun `getToolHandler returns handler and caches it`() {\n+        val tool = createTool(\"tool1\")\n+        var specLoadCount = 0\n+        var currentTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { listOf(tool) },\n+            toolSpecLoader = { specLoadCount++; createToolSpec(it) },\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        toolManager!!.getTools()\n+\n+        val handler1 = toolManager!!.getToolHandler(tool)\n+        val handler2 = toolManager!!.getToolHandler(tool)\n+\n+        assertNotNull(handler1)\n+        // 같은 인스턴스 (캐시)\n+        assertTrue(handler1 === handler2)\n+        assertEquals(1, specLoadCount)\n+    }\n+\n+    @Test\n+    fun `getToolHandler throws after close`() {\n+        val tool = createTool(\"tool1\")\n+        var currentTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { listOf(tool) },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        toolManager!!.close()\n+\n+        assertThrows<IllegalStateException> {\n+            toolManager!!.getToolHandler(tool)\n+        }\n+\n+        // close 후 다시 호출하지 않도록 null로 설정\n+        toolManager = null\n+    }\n+\n+    @Test\n+    fun `close closes all loaded handlers`() {\n+        val closedHandlers = mutableListOf<String>()\n+        val tools = listOf(createTool(\"tool1\"), createTool(\"tool2\"))\n+        var currentTime = Instant.now()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { tools },\n+            toolSpecLoader = { tool ->\n+                val handler = object : Mcp.ToolHandler {\n+                    override fun handle(params: Map<String, Any?>) = Mcp.CallToolResult.ofText(\"result\")\n+                    override fun close() { closedHandlers.add(tool.name) }\n+                }\n+                Mcp.ToolSpecification(tool = tool, handler = handler)\n+            },\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+\n+        toolManager!!.getTools()\n+        toolManager!!.getToolHandler(tools[0])\n+        toolManager!!.getToolHandler(tools[1])\n+\n+        toolManager!!.close()\n+        toolManager = null\n+\n+        assertEquals(2, closedHandlers.size)\n+        assertTrue(closedHandlers.containsAll(listOf(\"tool1\", \"tool2\")))\n+    }\n+\n+    @Test\n+    fun `tool list change listener is notified on changes`() {\n+        var currentTools = listOf(createTool(\"tool1\"))\n+        var currentTime = Instant.now()\n+        val events = mutableListOf<McpToolManager.ToolListChangeEvent>()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { currentTools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+        toolManager!!.addToolListChangedListener { events.add(it) }\n+\n+        // 초기 로드 (added: tool1)\n+        toolManager!!.getTools()\n+        assertEquals(1, events.size)\n+        assertEquals(1, events[0].added.size)\n+        assertEquals(\"tool1\", events[0].added[0].name)\n+\n+        // tool2 추가\n+        currentTools = listOf(createTool(\"tool1\"), createTool(\"tool2\"))\n+        currentTime = currentTime.plusSeconds(10)\n+        toolManager!!.getTools()\n+\n+        assertEquals(2, events.size)\n+        assertEquals(1, events[1].added.size)\n+        assertEquals(\"tool2\", events[1].added[0].name)\n+        assertTrue(events[1].removed.isEmpty())\n+    }\n+\n+    @Test\n+    fun `no change event when tools are identical`() {\n+        val tools = listOf(createTool(\"tool1\"))\n+        var currentTime = Instant.now()\n+        val events = mutableListOf<McpToolManager.ToolListChangeEvent>()\n+\n+        toolManager = McpToolManager(\n+            toolsLoader = { tools },\n+            toolSpecLoader = ::createToolSpec,\n+            toolSettingsLastModifiedProvider = { currentTime },\n+        )\n+        toolManager!!.addToolListChangedListener { events.add(it) }\n+\n+        toolManager!!.getTools() // 초기 로드 이벤트\n+        events.clear()\n+\n+        // lastModified 변경하지만 도구 목록은 동일\n+        currentTime = currentTime.plusSeconds(10)\n+        toolManager!!.getTools()\n+\n+        assertTrue(events.isEmpty(), \"No event should fire when tools list is unchanged\")\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/gateway/McpGatewayImplTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/gateway/McpGatewayImplTest.kt\nnew file mode 100644\nindex 000000000..ad925bab0\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/gateway/McpGatewayImplTest.kt\n@@ -0,0 +1,171 @@\n+package com.querypie.duplo.mcp.proxy.mcp.gateway\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\n+import com.querypie.duplo.common.querystats.QueryStatsRecorder\n+import com.querypie.duplo.mcp.proxy.infra.metric.McpMetricService\n+import com.querypie.duplo.mcp.proxy.mcp.*\n+import com.querypie.duplo.mcp.proxy.mcp.relay.RelayHttpClient\n+import io.modelcontextprotocol.spec.McpServerSession\n+import org.junit.jupiter.api.AfterEach\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.mockito.kotlin.*\n+import reactor.core.publisher.Mono\n+import kotlin.test.assertTrue\n+\n+class McpGatewayImplTest {\n+\n+    private lateinit var sessionManager: McpSessionManager\n+    private lateinit var objectMapper: ObjectMapper\n+    private lateinit var relayHttpClient: RelayHttpClient\n+    private lateinit var mcpMetricService: McpMetricService\n+    private lateinit var queryStatsRecorder: QueryStatsRecorder\n+    private lateinit var gateway: McpGatewayImpl\n+\n+    @BeforeEach\n+    fun setup() {\n+        sessionManager = mock()\n+        objectMapper = jacksonObjectMapper()\n+        relayHttpClient = mock()\n+        mcpMetricService = mock()\n+        queryStatsRecorder = mock {\n+            on { isEnabled() } doReturn false\n+            on { recordMono<Any>(any(), any()) } doAnswer { invocation ->\n+                @Suppress(\"UNCHECKED_CAST\")\n+                val monoSupplier = invocation.getArgument<() -> Mono<Any>>(1)\n+                monoSupplier()\n+            }\n+        }\n+        gateway = McpGatewayImpl(\n+            sessionManager = sessionManager,\n+            objectMapper = objectMapper,\n+            relayHttpClient = relayHttpClient,\n+            mcpMetricService = mcpMetricService,\n+            queryStatsRecorder = queryStatsRecorder,\n+        )\n+    }\n+\n+    @AfterEach\n+    fun teardown() {\n+        gateway.shutdown()\n+        ClientInfoContext.clearCurrentClientInfo()\n+    }\n+\n+    @Test\n+    fun `processRequest with local session calls local handler and increments local metric`() {\n+        // 로컬 세션 ID 생성\n+        val localSessionId = McpSessionId.generate()\n+        val sessionIdString = localSessionId.toString()\n+\n+        val mockSession = mock<McpServerSession> {\n+            on { handle(any()) } doReturn Mono.empty()\n+        }\n+        val sessionContext = SessionContext(\n+            sessionFactory = mock(),\n+            session = mockSession,\n+            clientInfo = null,\n+            baseUrl = \"/test\",\n+            sessionId = sessionIdString,\n+            requiresKeepAlivePing = true,\n+        )\n+        whenever(sessionManager[sessionIdString]).thenReturn(sessionContext)\n+\n+        // JSON-RPC 요청 메시지\n+        val jsonRpcMessage = \"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":1}\"\"\"\n+        val request = McpGateway.Request(sessionId = sessionIdString, jsonRpcMessage = jsonRpcMessage)\n+\n+        val result = gateway.processRequest(request)\n+\n+        assertTrue(result.isSuccess)\n+        verify(mcpMetricService).incrementGatewayLocalRequests()\n+        verify(mcpMetricService, never()).incrementGatewayRelayRequests()\n+    }\n+\n+    @Test\n+    fun `processRequest with local session not found returns failure`() {\n+        val localSessionId = McpSessionId.generate()\n+        val sessionIdString = localSessionId.toString()\n+\n+        whenever(sessionManager[sessionIdString]).thenReturn(null)\n+\n+        val jsonRpcMessage = \"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":1}\"\"\"\n+        val request = McpGateway.Request(sessionId = sessionIdString, jsonRpcMessage = jsonRpcMessage)\n+\n+        val result = gateway.processRequest(request)\n+\n+        assertTrue(result.isFailure)\n+        assertTrue(result.exceptionOrNull() is SessionNotFoundException)\n+    }\n+\n+    @Test\n+    fun `processRequest with remote session relays request and increments relay metric`() {\n+        // 원격 호스트 세션 ID (로컬이 아닌)\n+        val remoteSessionId = McpSessionId(\"definitely-not-local-host-99999\", \"remote-session\")\n+        val sessionIdString = remoteSessionId.toString()\n+\n+        whenever(relayHttpClient.relayRequest(any(), any(), any(), anyOrNull()))\n+            .thenReturn(Mono.just(Unit))\n+\n+        val jsonRpcMessage = \"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":1}\"\"\"\n+        val request = McpGateway.Request(sessionId = sessionIdString, jsonRpcMessage = jsonRpcMessage)\n+\n+        val result = gateway.processRequest(request)\n+\n+        assertTrue(result.isSuccess)\n+        verify(mcpMetricService).incrementGatewayRelayRequests()\n+        verify(mcpMetricService, never()).incrementGatewayLocalRequests()\n+    }\n+\n+    @Test\n+    fun `processRequest with remote session passes ClientInfo to relay`() {\n+        val clientInfo = ClientInfo(ip = \"8.8.8.8\", userAgent = \"TestAgent\", conversationId = \"conv-1\")\n+        ClientInfoContext.setCurrentClientInfo(clientInfo)\n+\n+        val remoteSessionId = McpSessionId(\"remote-host-12345\", \"session-abc\")\n+        val sessionIdString = remoteSessionId.toString()\n+\n+        whenever(relayHttpClient.relayRequest(any(), any(), any(), anyOrNull()))\n+            .thenReturn(Mono.just(Unit))\n+\n+        val jsonRpcMessage = \"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":1}\"\"\"\n+        val request = McpGateway.Request(sessionId = sessionIdString, jsonRpcMessage = jsonRpcMessage)\n+\n+        gateway.processRequest(request)\n+\n+        // relay는 Mono.defer + subscribeOn으로 비동기 실행되므로 약간의 대기 필요\n+        Thread.sleep(200)\n+\n+        verify(relayHttpClient).relayRequest(\n+            targetHost = eq(\"remote-host-12345\"),\n+            sessionId = eq(sessionIdString),\n+            jsonRpcMessage = eq(jsonRpcMessage),\n+            clientInfo = eq(clientInfo),\n+        )\n+    }\n+\n+    @Test\n+    fun `McpGateway RequestId from JSONRPCRequest uses message id`() {\n+        val requestId = McpGateway.RequestId(\n+            sessionId = \"s1\",\n+            requestId = \"42\",\n+        )\n+\n+        assertEquals(\"s1:42\", requestId.toString())\n+    }\n+\n+    @Test\n+    fun `McpGateway RequestId compareTo works correctly`() {\n+        val id1 = McpGateway.RequestId(\"a\", \"1\")\n+        val id2 = McpGateway.RequestId(\"b\", \"1\")\n+        val id3 = McpGateway.RequestId(\"a\", \"2\")\n+\n+        assertTrue(id1 < id2)  // \"a\" < \"b\"\n+        assertTrue(id1 < id3)  // same session, \"1\" < \"2\"\n+        assertTrue(id1.compareTo(id1) == 0)\n+    }\n+\n+    private fun assertEquals(expected: String, actual: String) {\n+        kotlin.test.assertEquals(expected, actual)\n+    }\n+}\ndiff --git a/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/relay/RelayServletTest.kt b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/relay/RelayServletTest.kt\nnew file mode 100644\nindex 000000000..b3ad032b3\n--- /dev/null\n+++ b/backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/relay/RelayServletTest.kt\n@@ -0,0 +1,129 @@\n+package com.querypie.duplo.mcp.proxy.mcp.relay\n+\n+import com.querypie.duplo.mcp.proxy.mcp.gateway.McpGateway\n+import jakarta.servlet.http.HttpServletRequest\n+import jakarta.servlet.http.HttpServletResponse\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Test\n+import org.mockito.kotlin.*\n+import java.io.BufferedReader\n+import java.io.StringReader\n+import java.util.*\n+\n+class RelayServletTest {\n+\n+    private lateinit var mcpGateway: McpGateway\n+    private lateinit var servlet: RelayServlet\n+\n+    @BeforeEach\n+    fun setup() {\n+        mcpGateway = mock()\n+        servlet = RelayServlet(mcpGateway)\n+    }\n+\n+    private fun mockRequest(\n+        sessionId: String? = \"test-session\",\n+        clientIp: String? = \"1.1.1.1\",\n+        userAgent: String? = \"TestAgent\",\n+        conversationId: String? = \"conv-1\",\n+        body: String = \"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":1}\"\"\",\n+    ): HttpServletRequest {\n+        return mock {\n+            on { getHeader(RelayHeaders.SESSION_ID) } doReturn sessionId\n+            on { getHeader(RelayHeaders.CLIENT_IP) } doReturn clientIp\n+            on { getHeader(RelayHeaders.USER_AGENT) } doReturn userAgent\n+            on { getHeader(RelayHeaders.CONVERSATION_ID) } doReturn conversationId\n+            on { reader } doReturn BufferedReader(StringReader(body))\n+            on { method } doReturn \"POST\"\n+            on { getProtocol() } doReturn \"HTTP/1.1\"\n+            on { headerNames } doReturn Collections.enumeration(\n+                listOfNotNull(\n+                    RelayHeaders.SESSION_ID.takeIf { sessionId != null },\n+                    RelayHeaders.CLIENT_IP.takeIf { clientIp != null },\n+                    RelayHeaders.USER_AGENT.takeIf { userAgent != null },\n+                    RelayHeaders.CONVERSATION_ID.takeIf { conversationId != null },\n+                ),\n+            )\n+        }\n+    }\n+\n+    @Test\n+    fun `POST returns 400 when session ID is missing`() {\n+        val req = mockRequest(sessionId = null)\n+        val res = mock<HttpServletResponse>()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).sendError(eq(HttpServletResponse.SC_BAD_REQUEST), any())\n+        verify(mcpGateway, never()).processRequest(any())\n+    }\n+\n+    @Test\n+    fun `POST returns 400 when session ID is blank`() {\n+        val req = mockRequest(sessionId = \"\")\n+        val res = mock<HttpServletResponse>()\n+\n+        servlet.service(req, res)\n+\n+        verify(res).sendError(eq(HttpServletResponse.SC_BAD_REQUEST), any())\n+        verify(mcpGateway, never()).processRequest(any())\n+    }\n+\n+    @Test\n+    fun `POST processes request and returns 202`() {\n+        val body = \"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":1}\"\"\"\n+        val req = mockRequest(body = body)\n+        val res = mock<HttpServletResponse>()\n+\n+        whenever(mcpGateway.processRequest(any())).thenReturn(Result.success(Unit))\n+\n+        servlet.service(req, res)\n+\n+        verify(mcpGateway).processRequest(argThat {\n+            sessionId == \"test-session\" && jsonRpcMessage == body\n+        })\n+        verify(res).status = HttpServletResponse.SC_ACCEPTED\n+    }\n+\n+    @Test\n+    fun `POST returns 500 when gateway returns failure`() {\n+        val req = mockRequest()\n+        val res = mock<HttpServletResponse>()\n+\n+        whenever(mcpGateway.processRequest(any()))\n+            .thenReturn(Result.failure(RuntimeException(\"Gateway error\")))\n+\n+        servlet.service(req, res)\n+\n+        verify(res).sendError(eq(HttpServletResponse.SC_INTERNAL_SERVER_ERROR), any())\n+    }\n+\n+    @Test\n+    fun `POST passes client info headers`() {\n+        val req = mockRequest(\n+            clientIp = \"8.8.8.8\",\n+            userAgent = \"CustomAgent/1.0\",\n+            conversationId = \"conv-abc\",\n+        )\n+        val res = mock<HttpServletResponse>()\n+\n+        whenever(mcpGateway.processRequest(any())).thenReturn(Result.success(Unit))\n+\n+        servlet.service(req, res)\n+\n+        verify(mcpGateway).processRequest(any())\n+        verify(res).status = HttpServletResponse.SC_ACCEPTED\n+    }\n+\n+    @Test\n+    fun `POST works without client info headers`() {\n+        val req = mockRequest(clientIp = null, userAgent = null, conversationId = null)\n+        val res = mock<HttpServletResponse>()\n+\n+        whenever(mcpGateway.processRequest(any())).thenReturn(Result.success(Unit))\n+\n+        servlet.service(req, res)\n+\n+        verify(res).status = HttpServletResponse.SC_ACCEPTED\n+    }\n+}\ndiff --git a/backend/settings.gradle.kts b/backend/settings.gradle.kts\nindex 7196a1afe..21c2973b9 100644\n--- a/backend/settings.gradle.kts\n+++ b/backend/settings.gradle.kts\n@@ -2,6 +2,7 @@ include(\":common\")\n include(\":api\")\n include(\":app\")\n include(\":tunnel\")\n+include(\":mcp:grpc\")\n include(\":mcp:proxy\")\n include(\":mcp:connector-api\")\n include(\":mcp:connectors\")\ndiff --git a/mcp-proxy/.gitignore b/mcp-proxy/.gitignore\nnew file mode 100644\nindex 000000000..c3ab59bb4\n--- /dev/null\n+++ b/mcp-proxy/.gitignore\n@@ -0,0 +1,2 @@\n+/bin/\n+/server\ndiff --git a/mcp-proxy/CLAUDE.md b/mcp-proxy/CLAUDE.md\nnew file mode 100644\nindex 000000000..13c6b3f14\n--- /dev/null\n+++ b/mcp-proxy/CLAUDE.md\n@@ -0,0 +1,79 @@\n+# MCP Proxy\n+\n+Go로 작성된 MCP(Model Context Protocol) 프록시 서버.\n+클라이언트 HTTP 연결을 받아 Kotlin Backend와 gRPC로 통신한다.\n+\n+## 디렉토리 구조\n+\n+```\n+mcp-proxy/\n+├── cmd/server/       # 엔트리포인트\n+├── internal/\n+│   ├── app/          # 서버 부트스트랩 (wire-up)\n+│   ├── config/       # 환경변수 기반 설정\n+│   ├── grpcclient/   # gRPC 커넥션 관리\n+│   │   └── backend_pool.go   # 다중 Backend 커넥션 풀 (per-pod lazy dial)\n+│   ├── logging/      # zerolog 래퍼\n+│   ├── mcp/          # 핵심 MCP 프로토콜 구현\n+│   │   ├── handler.go          # HTTP 라우팅 (POST/GET/DELETE)\n+│   │   ├── lazy.go             # LazyConnector — 지연 초기화 + 자동 복구\n+│   │   ├── session.go          # Session 구조체\n+│   │   ├── session_manager.go  # 세션 저장소\n+│   │   ├── backend.go          # BackendClient/BackendRouter/AddrPicker 인터페이스\n+│   │   ├── backend_routing.go  # RoutingBackendClient — 세션 ID 기반 라우팅\n+│   │   ├── auth.go             # AccessKey 인증\n+│   │   ├── sse.go              # SSE 이벤트 스트림\n+│   │   └── event_subscriber.go # Channel RPC 이벤트 구독 + 재연결\n+│   └── version/      # 빌드 정보\n+├── pkg/\n+│   ├── jsonrpc/      # JSON-RPC 2.0 파서\n+│   └── sessionid/    # 세션 ID 생성 (XOR+Base62 난독화)\n+├── gen/              # protoc 생성 코드 (커밋 대상)\n+├── scripts/          # proto 생성 스크립트\n+└── Makefile\n+```\n+\n+## 세션 모델\n+\n+**Proxy가 세션 ID의 소유자(authority)이다.**\n+\n+```\n+Client ← session_id → Proxy → CreateSession(session_id) → Backend\n+                       Proxy → ListTools(session_id) → Backend\n+                       Proxy → CallTool(session_id) → Backend\n+```\n+\n+- Proxy가 `sessionid.New(backendAddr, proxyID)`로 ID를 생성하여 클라이언트에 반환\n+- 세션 ID에 Backend 주소가 인코딩되어 Stateless 라우팅 가능\n+- 같은 ID를 `CreateSessionRequest.session_id`로 Backend에 전달\n+- 모든 RPC 호출에 이 단일 ID를 사용 (별도 매핑 없음)\n+- Backend pod 재시작 시 \"session not found\" 감지 → 자동 재초기화 (1회 재시도)\n+\n+### 세션 ID 형식\n+\n+`{xor-encoded-backend}:{short-id}` — `pkg/sessionid` 참조\n+\n+## 빌드 & 테스트\n+\n+```bash\n+# 빌드\n+make build\n+\n+# 테스트\n+make test\n+# 또는\n+go test -race -count=1 ./...\n+\n+# vet\n+go vet ./...\n+```\n+\n+## Proto 재생성\n+\n+Proto 소스: `resource/proto/duplo/mcp/v1/mcp_connector.proto` (루트 기준)\n+\n+```bash\n+make proto\n+```\n+\n+`gen/duplo/` 디렉토리에 Go 코드가 생성된다. 생성된 코드는 커밋 대상이다.\ndiff --git a/mcp-proxy/Dockerfile b/mcp-proxy/Dockerfile\nnew file mode 100644\nindex 000000000..ce598697f\n--- /dev/null\n+++ b/mcp-proxy/Dockerfile\n@@ -0,0 +1,53 @@\n+# base\n+FROM alpine/git AS base\n+\n+WORKDIR /app\n+\n+RUN apk add --no-cache gawk tzdata\n+\n+COPY --from=git . .git/\n+COPY --from=scripts . scripts/\n+RUN scripts/generate-git-logs mcp-proxy\n+\n+RUN export VERSION_PATH=\"mcp-proxy/internal/version\" && \\\n+    export GIT_COMMIT=$(git rev-parse HEAD) && \\\n+    export GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD) && \\\n+    export BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ') && \\\n+    echo \" \\\n+      -X '${VERSION_PATH}.GitCommit=${GIT_COMMIT}' \\\n+      -X '${VERSION_PATH}.GitBranch=${GIT_BRANCH}' \\\n+      -X '${VERSION_PATH}.BuildTime=${BUILD_TIME}' \\\n+    \" > ldflags\n+\n+# build\n+FROM golang:1.25.3 AS builder\n+\n+WORKDIR /src\n+\n+RUN go env -w GOMODCACHE=/root/.cache/go-build\n+\n+COPY go.mod go.sum ./\n+RUN --mount=type=cache,target=/root/.cache/go-build \\\n+    go mod download\n+\n+COPY . .\n+COPY --from=base /app/ldflags .\n+\n+RUN --mount=type=cache,target=/root/.cache/go-build \\\n+    CGO_ENABLED=0 \\\n+    GOOS=linux \\\n+    go build -ldflags=\"$(cat ldflags)\" -o /app/mcp-proxy ./cmd/server\n+\n+# final\n+FROM gcr.io/distroless/static\n+\n+WORKDIR /app\n+\n+COPY --from=base --chown=nonroot:nonroot /app/git-logs.txt /app/\n+COPY --from=builder --chown=nonroot:nonroot /app/mcp-proxy /app/mcp-proxy\n+\n+USER nonroot\n+\n+EXPOSE 9000\n+\n+CMD [\"/app/mcp-proxy\"]\ndiff --git a/mcp-proxy/Makefile b/mcp-proxy/Makefile\nnew file mode 100644\nindex 000000000..11b11d205\n--- /dev/null\n+++ b/mcp-proxy/Makefile\n@@ -0,0 +1,41 @@\n+GOBIN := $(shell go env GOPATH)/bin\n+\n+PROTOC_GEN_GO := $(GOBIN)/protoc-gen-go\n+PROTOC_GEN_GO_GRPC := $(GOBIN)/protoc-gen-go-grpc\n+\n+GIT_COMMIT := $(shell git rev-parse HEAD 2>/dev/null || echo \"unknown\")\n+GIT_BRANCH := $(shell git rev-parse --abbrev-ref HEAD 2>/dev/null || echo \"unknown\")\n+BUILD_TIME := $(shell date -u '+%Y-%m-%dT%H:%M:%SZ')\n+\n+LDFLAGS := -s -w \\\n+           -X mcp-proxy/internal/version.GitCommit=$(GIT_COMMIT) \\\n+           -X mcp-proxy/internal/version.GitBranch=$(GIT_BRANCH) \\\n+           -X mcp-proxy/internal/version.BuildTime=$(BUILD_TIME)\n+\n+.PHONY: proto build test clean clean-proto docker\n+\n+proto: clean-proto\n+\t@echo \"Generating protobuf code...\"\n+\t@./scripts/generate_proto.sh\n+\n+build:\n+\t@echo \"Building server...\"\n+\t@go build -ldflags=\"$(LDFLAGS)\" -v -o ./bin/server ./cmd/server\n+\n+test:\n+\t@echo \"Running tests...\"\n+\t@go test -race -count=1 ./...\n+\n+clean:\n+\t@echo \"Cleaning...\"\n+\t@rm -rf ./bin\n+\t$(MAKE) clean-proto\n+\n+# Requires CI build contexts (git, scripts). Use `docker buildx bake` in CI.\n+docker:\n+\t@echo \"Building Docker image...\"\n+\t@docker build -f Dockerfile -t duplo-mcp-proxy:latest ..\n+\n+clean-proto:\n+\t@echo \"Cleaning proto...\"\n+\t@rm -rf ./gen/duplo\ndiff --git a/mcp-proxy/cmd/server/main.go b/mcp-proxy/cmd/server/main.go\nnew file mode 100644\nindex 000000000..879433ca0\n--- /dev/null\n+++ b/mcp-proxy/cmd/server/main.go\n@@ -0,0 +1,41 @@\n+// Command mcp-proxy starts the MCP protocol proxy server.\n+package main\n+\n+import (\n+\t\"log\"\n+\t\"os\"\n+\n+\t\"mcp-proxy/internal/app\"\n+\t\"mcp-proxy/internal/config\"\n+\t\"mcp-proxy/internal/logging\"\n+\t\"mcp-proxy/internal/version\"\n+)\n+\n+func main() {\n+\t// Config\n+\tcfg, err := config.LoadConfig()\n+\tif err != nil {\n+\t\tlog.Fatal(\"failed to load config: \", err)\n+\t}\n+\n+\t// Logger\n+\tlogging.Init(logging.Options{\n+\t\tJSON:  cfg.Logger.JSON,\n+\t\tLevel: cfg.Logger.Level,\n+\t})\n+\tlogger := logging.Default()\n+\tlogger.Debug().Any(\"config\", cfg).Str(\"env\", config.ENV.String()).Msg(\"config loaded\")\n+\tlogger.Info().Any(\"version\", version.Get()).Send()\n+\n+\t// Application\n+\tapplication := app.Application{\n+\t\tLogger:          logging.ForModule(\"app\"),\n+\t\tShutdownTimeout: cfg.Server.ShutdownTimeout,\n+\t}\n+\n+\tsetup(&application, cfg)\n+\n+\t// Run\n+\texitCode := application.Run()\n+\tos.Exit(exitCode)\n+}\ndiff --git a/mcp-proxy/cmd/server/setup.go b/mcp-proxy/cmd/server/setup.go\nnew file mode 100644\nindex 000000000..c2a376b0f\n--- /dev/null\n+++ b/mcp-proxy/cmd/server/setup.go\n@@ -0,0 +1,80 @@\n+package main\n+\n+import (\n+\t\"mcp-proxy/internal/app\"\n+\t\"mcp-proxy/internal/config\"\n+\t\"mcp-proxy/internal/grpcclient\"\n+\t\"mcp-proxy/internal/logging\"\n+\t\"mcp-proxy/internal/mcp\"\n+\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\t\"google.golang.org/grpc/keepalive\"\n+)\n+\n+func setup(application *app.Application, cfg *config.Config) {\n+\tmaxMsgSize := cfg.GRPC.MaxMessageSizeMB * 1024 * 1024\n+\n+\t// Backend pool (multi-pod)\n+\tpool := grpcclient.NewBackendPool(\n+\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n+\t\tgrpc.WithKeepaliveParams(keepalive.ClientParameters{\n+\t\t\tTime:                cfg.GRPC.KeepAliveTime,\n+\t\t\tTimeout:             cfg.GRPC.KeepAliveTimeout,\n+\t\t\tPermitWithoutStream: true,\n+\t\t}),\n+\t\tgrpc.WithDefaultCallOptions(\n+\t\t\tgrpc.MaxCallRecvMsgSize(maxMsgSize),\n+\t\t\tgrpc.MaxCallSendMsgSize(maxMsgSize),\n+\t\t),\n+\t)\n+\tpool.UpdateAddrs(cfg.Discovery.Addrs)\n+\tapplication.AddCloser(pool)\n+\n+\t// Routing backend client\n+\troutingClient := mcp.NewRoutingBackendClient(pool)\n+\n+\t// Session manager (proxyID only)\n+\tsessionManager := mcp.NewSessionManager(cfg.Proxy.ID)\n+\n+\t// Lazy connector (router)\n+\tlazyConnector := mcp.NewLazyConnector(routingClient)\n+\n+\t// Access key verifier (pick-any backend)\n+\tauthVerifier := mcp.NewAccessKeyVerifier(routingClient, cfg.Auth.CacheTTL)\n+\n+\t// Event subscriber (routed by session ID)\n+\teventSubscriber := mcp.NewGRPCEventSubscriber(pool)\n+\n+\t// Handler (pool implements AddrPicker)\n+\thandler := mcp.NewHandler(\n+\t\tsessionManager,\n+\t\tlazyConnector,\n+\t\tauthVerifier,\n+\t\teventSubscriber,\n+\t\tpool,\n+\t\tcfg.Session.PingInterval,\n+\t\tcfg.Server.MaxRequestBodyMB,\n+\t\tlogging.ForModule(\"handler\"),\n+\t)\n+\n+\t// Session cleaner\n+\tsessionCleaner := mcp.NewSessionCleaner(\n+\t\tsessionManager,\n+\t\tlazyConnector,\n+\t\tcfg.Session.Timeout,\n+\t\tcfg.Session.CleanupInterval,\n+\t\tlogging.ForModule(\"session-cleaner\"),\n+\t)\n+\n+\t// HTTP server\n+\tserver := mcp.NewServer(mcp.ServerConfig{\n+\t\tPort:              cfg.Server.Port,\n+\t\tReadHeaderTimeout: cfg.Server.ReadHeaderTimeout,\n+\t\tIdleTimeout:       cfg.Server.IdleTimeout,\n+\t\tShutdownTimeout:   cfg.Server.ShutdownTimeout,\n+\t}, handler, logging.ForModule(\"server\"))\n+\n+\tapplication.AddService(sessionCleaner)\n+\tapplication.AddService(server)\n+}\ndiff --git a/mcp-proxy/gen/duplo/mcp/v1/mcp_connector.pb.go b/mcp-proxy/gen/duplo/mcp/v1/mcp_connector.pb.go\nnew file mode 100644\nindex 000000000..928e3c322\n--- /dev/null\n+++ b/mcp-proxy/gen/duplo/mcp/v1/mcp_connector.pb.go\n@@ -0,0 +1,3230 @@\n+// MCP Connector gRPC Service\n+//\n+// Go Proxy ↔ Kotlin Backend 간 gRPC 인터페이스 정의\n+// Go Proxy가 클라이언트 연결·인증·세션 관리를 담당하고,\n+// Kotlin Backend가 커넥터·비즈니스 로직을 담당한다\n+\n+// Code generated by protoc-gen-go. DO NOT EDIT.\n+// versions:\n+// \tprotoc-gen-go v1.36.11\n+// \tprotoc        v6.33.4\n+// source: duplo/mcp/v1/mcp_connector.proto\n+\n+package mcpv1\n+\n+import (\n+\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n+\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n+\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n+\treflect \"reflect\"\n+\tsync \"sync\"\n+\tunsafe \"unsafe\"\n+)\n+\n+const (\n+\t// Verify that this generated code is sufficiently up-to-date.\n+\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n+\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n+\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n+)\n+\n+// 세션 존재 여부\n+type SessionExistence int32\n+\n+const (\n+\tSessionExistence_SESSION_EXISTENCE_UNSPECIFIED SessionExistence = 0\n+\tSessionExistence_SESSION_EXISTENCE_EXISTS      SessionExistence = 1\n+\tSessionExistence_SESSION_EXISTENCE_NOT_EXISTS  SessionExistence = 2\n+)\n+\n+// Enum value maps for SessionExistence.\n+var (\n+\tSessionExistence_name = map[int32]string{\n+\t\t0: \"SESSION_EXISTENCE_UNSPECIFIED\",\n+\t\t1: \"SESSION_EXISTENCE_EXISTS\",\n+\t\t2: \"SESSION_EXISTENCE_NOT_EXISTS\",\n+\t}\n+\tSessionExistence_value = map[string]int32{\n+\t\t\"SESSION_EXISTENCE_UNSPECIFIED\": 0,\n+\t\t\"SESSION_EXISTENCE_EXISTS\":      1,\n+\t\t\"SESSION_EXISTENCE_NOT_EXISTS\":  2,\n+\t}\n+)\n+\n+func (x SessionExistence) Enum() *SessionExistence {\n+\tp := new(SessionExistence)\n+\t*p = x\n+\treturn p\n+}\n+\n+func (x SessionExistence) String() string {\n+\treturn protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))\n+}\n+\n+func (SessionExistence) Descriptor() protoreflect.EnumDescriptor {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_enumTypes[0].Descriptor()\n+}\n+\n+func (SessionExistence) Type() protoreflect.EnumType {\n+\treturn &file_duplo_mcp_v1_mcp_connector_proto_enumTypes[0]\n+}\n+\n+func (x SessionExistence) Number() protoreflect.EnumNumber {\n+\treturn protoreflect.EnumNumber(x)\n+}\n+\n+// Deprecated: Use SessionExistence.Descriptor instead.\n+func (SessionExistence) EnumDescriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{0}\n+}\n+\n+// 인증 방식\n+type AuthMethod int32\n+\n+const (\n+\tAuthMethod_AUTH_METHOD_UNSPECIFIED    AuthMethod = 0\n+\tAuthMethod_AUTH_METHOD_OAUTH          AuthMethod = 1\n+\tAuthMethod_AUTH_METHOD_HTTP_SIGNATURE AuthMethod = 2\n+)\n+\n+// Enum value maps for AuthMethod.\n+var (\n+\tAuthMethod_name = map[int32]string{\n+\t\t0: \"AUTH_METHOD_UNSPECIFIED\",\n+\t\t1: \"AUTH_METHOD_OAUTH\",\n+\t\t2: \"AUTH_METHOD_HTTP_SIGNATURE\",\n+\t}\n+\tAuthMethod_value = map[string]int32{\n+\t\t\"AUTH_METHOD_UNSPECIFIED\":    0,\n+\t\t\"AUTH_METHOD_OAUTH\":          1,\n+\t\t\"AUTH_METHOD_HTTP_SIGNATURE\": 2,\n+\t}\n+)\n+\n+func (x AuthMethod) Enum() *AuthMethod {\n+\tp := new(AuthMethod)\n+\t*p = x\n+\treturn p\n+}\n+\n+func (x AuthMethod) String() string {\n+\treturn protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))\n+}\n+\n+func (AuthMethod) Descriptor() protoreflect.EnumDescriptor {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_enumTypes[1].Descriptor()\n+}\n+\n+func (AuthMethod) Type() protoreflect.EnumType {\n+\treturn &file_duplo_mcp_v1_mcp_connector_proto_enumTypes[1]\n+}\n+\n+func (x AuthMethod) Number() protoreflect.EnumNumber {\n+\treturn protoreflect.EnumNumber(x)\n+}\n+\n+// Deprecated: Use AuthMethod.Descriptor instead.\n+func (AuthMethod) EnumDescriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{1}\n+}\n+\n+// Send RPC 요청 envelope\n+type SendRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// Types that are valid to be assigned to Payload:\n+\t//\n+\t//\t*SendRequest_CreateSession\n+\t//\t*SendRequest_ListTools\n+\t//\t*SendRequest_CloseSession\n+\t//\t*SendRequest_SendNotification\n+\t//\t*SendRequest_QuerySession\n+\t//\t*SendRequest_DeleteSession\n+\t//\t*SendRequest_VerifyAccessKey\n+\t//\t*SendRequest_CallTool\n+\tPayload       isSendRequest_Payload `protobuf_oneof:\"payload\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SendRequest) Reset() {\n+\t*x = SendRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[0]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SendRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SendRequest) ProtoMessage() {}\n+\n+func (x *SendRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[0]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SendRequest.ProtoReflect.Descriptor instead.\n+func (*SendRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{0}\n+}\n+\n+func (x *SendRequest) GetPayload() isSendRequest_Payload {\n+\tif x != nil {\n+\t\treturn x.Payload\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetCreateSession() *CreateSessionRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_CreateSession); ok {\n+\t\t\treturn x.CreateSession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetListTools() *ListToolsRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_ListTools); ok {\n+\t\t\treturn x.ListTools\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetCloseSession() *CloseSessionRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_CloseSession); ok {\n+\t\t\treturn x.CloseSession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetSendNotification() *SendNotificationRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_SendNotification); ok {\n+\t\t\treturn x.SendNotification\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetQuerySession() *QuerySessionRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_QuerySession); ok {\n+\t\t\treturn x.QuerySession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetDeleteSession() *DeleteSessionRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_DeleteSession); ok {\n+\t\t\treturn x.DeleteSession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetVerifyAccessKey() *VerifyAccessKeyRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_VerifyAccessKey); ok {\n+\t\t\treturn x.VerifyAccessKey\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendRequest) GetCallTool() *CallToolSendRequest {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendRequest_CallTool); ok {\n+\t\t\treturn x.CallTool\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type isSendRequest_Payload interface {\n+\tisSendRequest_Payload()\n+}\n+\n+type SendRequest_CreateSession struct {\n+\tCreateSession *CreateSessionRequest `protobuf:\"bytes,10,opt,name=create_session,json=createSession,proto3,oneof\"`\n+}\n+\n+type SendRequest_ListTools struct {\n+\tListTools *ListToolsRequest `protobuf:\"bytes,11,opt,name=list_tools,json=listTools,proto3,oneof\"`\n+}\n+\n+type SendRequest_CloseSession struct {\n+\tCloseSession *CloseSessionRequest `protobuf:\"bytes,12,opt,name=close_session,json=closeSession,proto3,oneof\"`\n+}\n+\n+type SendRequest_SendNotification struct {\n+\tSendNotification *SendNotificationRequest `protobuf:\"bytes,13,opt,name=send_notification,json=sendNotification,proto3,oneof\"`\n+}\n+\n+type SendRequest_QuerySession struct {\n+\tQuerySession *QuerySessionRequest `protobuf:\"bytes,14,opt,name=query_session,json=querySession,proto3,oneof\"`\n+}\n+\n+type SendRequest_DeleteSession struct {\n+\tDeleteSession *DeleteSessionRequest `protobuf:\"bytes,15,opt,name=delete_session,json=deleteSession,proto3,oneof\"`\n+}\n+\n+type SendRequest_VerifyAccessKey struct {\n+\tVerifyAccessKey *VerifyAccessKeyRequest `protobuf:\"bytes,16,opt,name=verify_access_key,json=verifyAccessKey,proto3,oneof\"`\n+}\n+\n+type SendRequest_CallTool struct {\n+\tCallTool *CallToolSendRequest `protobuf:\"bytes,17,opt,name=call_tool,json=callTool,proto3,oneof\"`\n+}\n+\n+func (*SendRequest_CreateSession) isSendRequest_Payload() {}\n+\n+func (*SendRequest_ListTools) isSendRequest_Payload() {}\n+\n+func (*SendRequest_CloseSession) isSendRequest_Payload() {}\n+\n+func (*SendRequest_SendNotification) isSendRequest_Payload() {}\n+\n+func (*SendRequest_QuerySession) isSendRequest_Payload() {}\n+\n+func (*SendRequest_DeleteSession) isSendRequest_Payload() {}\n+\n+func (*SendRequest_VerifyAccessKey) isSendRequest_Payload() {}\n+\n+func (*SendRequest_CallTool) isSendRequest_Payload() {}\n+\n+// Send RPC 응답 envelope\n+type SendResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// Types that are valid to be assigned to Payload:\n+\t//\n+\t//\t*SendResponse_Error\n+\t//\t*SendResponse_CreateSession\n+\t//\t*SendResponse_ListTools\n+\t//\t*SendResponse_CloseSession\n+\t//\t*SendResponse_SendNotification\n+\t//\t*SendResponse_QuerySession\n+\t//\t*SendResponse_DeleteSession\n+\t//\t*SendResponse_VerifyAccessKey\n+\t//\t*SendResponse_CallTool\n+\tPayload       isSendResponse_Payload `protobuf_oneof:\"payload\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SendResponse) Reset() {\n+\t*x = SendResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[1]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SendResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SendResponse) ProtoMessage() {}\n+\n+func (x *SendResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[1]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SendResponse.ProtoReflect.Descriptor instead.\n+func (*SendResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{1}\n+}\n+\n+func (x *SendResponse) GetPayload() isSendResponse_Payload {\n+\tif x != nil {\n+\t\treturn x.Payload\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetError() *ErrorResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_Error); ok {\n+\t\t\treturn x.Error\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetCreateSession() *CreateSessionResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_CreateSession); ok {\n+\t\t\treturn x.CreateSession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetListTools() *ListToolsResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_ListTools); ok {\n+\t\t\treturn x.ListTools\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetCloseSession() *CloseSessionResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_CloseSession); ok {\n+\t\t\treturn x.CloseSession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetSendNotification() *SendNotificationResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_SendNotification); ok {\n+\t\t\treturn x.SendNotification\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetQuerySession() *QuerySessionResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_QuerySession); ok {\n+\t\t\treturn x.QuerySession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetDeleteSession() *DeleteSessionResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_DeleteSession); ok {\n+\t\t\treturn x.DeleteSession\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetVerifyAccessKey() *VerifyAccessKeyResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_VerifyAccessKey); ok {\n+\t\t\treturn x.VerifyAccessKey\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SendResponse) GetCallTool() *CallToolResult {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*SendResponse_CallTool); ok {\n+\t\t\treturn x.CallTool\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type isSendResponse_Payload interface {\n+\tisSendResponse_Payload()\n+}\n+\n+type SendResponse_Error struct {\n+\tError *ErrorResponse `protobuf:\"bytes,10,opt,name=error,proto3,oneof\"`\n+}\n+\n+type SendResponse_CreateSession struct {\n+\tCreateSession *CreateSessionResponse `protobuf:\"bytes,11,opt,name=create_session,json=createSession,proto3,oneof\"`\n+}\n+\n+type SendResponse_ListTools struct {\n+\tListTools *ListToolsResponse `protobuf:\"bytes,12,opt,name=list_tools,json=listTools,proto3,oneof\"`\n+}\n+\n+type SendResponse_CloseSession struct {\n+\tCloseSession *CloseSessionResponse `protobuf:\"bytes,13,opt,name=close_session,json=closeSession,proto3,oneof\"`\n+}\n+\n+type SendResponse_SendNotification struct {\n+\tSendNotification *SendNotificationResponse `protobuf:\"bytes,14,opt,name=send_notification,json=sendNotification,proto3,oneof\"`\n+}\n+\n+type SendResponse_QuerySession struct {\n+\tQuerySession *QuerySessionResponse `protobuf:\"bytes,15,opt,name=query_session,json=querySession,proto3,oneof\"`\n+}\n+\n+type SendResponse_DeleteSession struct {\n+\tDeleteSession *DeleteSessionResponse `protobuf:\"bytes,16,opt,name=delete_session,json=deleteSession,proto3,oneof\"`\n+}\n+\n+type SendResponse_VerifyAccessKey struct {\n+\tVerifyAccessKey *VerifyAccessKeyResponse `protobuf:\"bytes,17,opt,name=verify_access_key,json=verifyAccessKey,proto3,oneof\"`\n+}\n+\n+type SendResponse_CallTool struct {\n+\tCallTool *CallToolResult `protobuf:\"bytes,18,opt,name=call_tool,json=callTool,proto3,oneof\"`\n+}\n+\n+func (*SendResponse_Error) isSendResponse_Payload() {}\n+\n+func (*SendResponse_CreateSession) isSendResponse_Payload() {}\n+\n+func (*SendResponse_ListTools) isSendResponse_Payload() {}\n+\n+func (*SendResponse_CloseSession) isSendResponse_Payload() {}\n+\n+func (*SendResponse_SendNotification) isSendResponse_Payload() {}\n+\n+func (*SendResponse_QuerySession) isSendResponse_Payload() {}\n+\n+func (*SendResponse_DeleteSession) isSendResponse_Payload() {}\n+\n+func (*SendResponse_VerifyAccessKey) isSendResponse_Payload() {}\n+\n+func (*SendResponse_CallTool) isSendResponse_Payload() {}\n+\n+// Send RPC용 도구 호출 요청 (session_id 래핑)\n+type CallToolSendRequest struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tSessionId     string                 `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\tPayload       *CallToolPayload       `protobuf:\"bytes,2,opt,name=payload,proto3\" json:\"payload,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CallToolSendRequest) Reset() {\n+\t*x = CallToolSendRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[2]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CallToolSendRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CallToolSendRequest) ProtoMessage() {}\n+\n+func (x *CallToolSendRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[2]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CallToolSendRequest.ProtoReflect.Descriptor instead.\n+func (*CallToolSendRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{2}\n+}\n+\n+func (x *CallToolSendRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CallToolSendRequest) GetPayload() *CallToolPayload {\n+\tif x != nil {\n+\t\treturn x.Payload\n+\t}\n+\treturn nil\n+}\n+\n+// MCP 세션 생성 요청\n+type CreateSessionRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// Agent installation path (라우팅 키)\n+\tBaseUrl string `protobuf:\"bytes,1,opt,name=base_url,json=baseUrl,proto3\" json:\"base_url,omitempty\"`\n+\t// Go Proxy가 인증 후 전달하는 사용자 정보\n+\tAuthContext *AuthContext `protobuf:\"bytes,2,opt,name=auth_context,json=authContext,proto3\" json:\"auth_context,omitempty\"`\n+\tClientInfo  *ClientInfo  `protobuf:\"bytes,3,opt,name=client_info,json=clientInfo,proto3\" json:\"client_info,omitempty\"`\n+\t// e.g. \"2025-03-26\"\n+\tProtocolVersion string `protobuf:\"bytes,4,opt,name=protocol_version,json=protocolVersion,proto3\" json:\"protocol_version,omitempty\"`\n+\t// JSON string — Struct 대신 원본 보존\n+\tClientCapabilitiesJson string         `protobuf:\"bytes,5,opt,name=client_capabilities_json,json=clientCapabilitiesJson,proto3\" json:\"client_capabilities_json,omitempty\"`\n+\tMcpClientInfo          *McpClientInfo `protobuf:\"bytes,6,opt,name=mcp_client_info,json=mcpClientInfo,proto3\" json:\"mcp_client_info,omitempty\"`\n+\t// Proxy가 생성한 세션 ID. 세션 ID의 소유권은 Proxy에 있다.\n+\t// Backend는 이 값을 세션 식별자로 사용해야 한다.\n+\tSessionId     string `protobuf:\"bytes,7,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CreateSessionRequest) Reset() {\n+\t*x = CreateSessionRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[3]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CreateSessionRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CreateSessionRequest) ProtoMessage() {}\n+\n+func (x *CreateSessionRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[3]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CreateSessionRequest.ProtoReflect.Descriptor instead.\n+func (*CreateSessionRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{3}\n+}\n+\n+func (x *CreateSessionRequest) GetBaseUrl() string {\n+\tif x != nil {\n+\t\treturn x.BaseUrl\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CreateSessionRequest) GetAuthContext() *AuthContext {\n+\tif x != nil {\n+\t\treturn x.AuthContext\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CreateSessionRequest) GetClientInfo() *ClientInfo {\n+\tif x != nil {\n+\t\treturn x.ClientInfo\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CreateSessionRequest) GetProtocolVersion() string {\n+\tif x != nil {\n+\t\treturn x.ProtocolVersion\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CreateSessionRequest) GetClientCapabilitiesJson() string {\n+\tif x != nil {\n+\t\treturn x.ClientCapabilitiesJson\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CreateSessionRequest) GetMcpClientInfo() *McpClientInfo {\n+\tif x != nil {\n+\t\treturn x.McpClientInfo\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CreateSessionRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+// MCP 세션 생성 응답\n+type CreateSessionResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// Deprecated: Proxy가 전달한 session_id를 echo back. 새 코드에서는 무시.\n+\tSessionId          string              `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\tServerCapabilities *ServerCapabilities `protobuf:\"bytes,2,opt,name=server_capabilities,json=serverCapabilities,proto3\" json:\"server_capabilities,omitempty\"`\n+\tServerInfo         *ServerInfo         `protobuf:\"bytes,3,opt,name=server_info,json=serverInfo,proto3\" json:\"server_info,omitempty\"`\n+\tProtocolVersion    string              `protobuf:\"bytes,4,opt,name=protocol_version,json=protocolVersion,proto3\" json:\"protocol_version,omitempty\"`\n+\t// 최적화용 초기 도구 목록. Backend가 즉시 로드하지 않으면 빈 배열\n+\tTools         []*Tool `protobuf:\"bytes,5,rep,name=tools,proto3\" json:\"tools,omitempty\"`\n+\tInstructions  string  `protobuf:\"bytes,6,opt,name=instructions,proto3\" json:\"instructions,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CreateSessionResponse) Reset() {\n+\t*x = CreateSessionResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[4]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CreateSessionResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CreateSessionResponse) ProtoMessage() {}\n+\n+func (x *CreateSessionResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[4]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CreateSessionResponse.ProtoReflect.Descriptor instead.\n+func (*CreateSessionResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{4}\n+}\n+\n+func (x *CreateSessionResponse) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CreateSessionResponse) GetServerCapabilities() *ServerCapabilities {\n+\tif x != nil {\n+\t\treturn x.ServerCapabilities\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CreateSessionResponse) GetServerInfo() *ServerInfo {\n+\tif x != nil {\n+\t\treturn x.ServerInfo\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CreateSessionResponse) GetProtocolVersion() string {\n+\tif x != nil {\n+\t\treturn x.ProtocolVersion\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CreateSessionResponse) GetTools() []*Tool {\n+\tif x != nil {\n+\t\treturn x.Tools\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CreateSessionResponse) GetInstructions() string {\n+\tif x != nil {\n+\t\treturn x.Instructions\n+\t}\n+\treturn \"\"\n+}\n+\n+// 도구 목록 조회 요청\n+type ListToolsRequest struct {\n+\tstate     protoimpl.MessageState `protogen:\"open.v1\"`\n+\tSessionId string                 `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\t// 페이지네이션 커서\n+\tCursor        string `protobuf:\"bytes,2,opt,name=cursor,proto3\" json:\"cursor,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ListToolsRequest) Reset() {\n+\t*x = ListToolsRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[5]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ListToolsRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ListToolsRequest) ProtoMessage() {}\n+\n+func (x *ListToolsRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[5]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ListToolsRequest.ProtoReflect.Descriptor instead.\n+func (*ListToolsRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{5}\n+}\n+\n+func (x *ListToolsRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ListToolsRequest) GetCursor() string {\n+\tif x != nil {\n+\t\treturn x.Cursor\n+\t}\n+\treturn \"\"\n+}\n+\n+// 도구 목록 조회 응답\n+type ListToolsResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\tTools []*Tool                `protobuf:\"bytes,1,rep,name=tools,proto3\" json:\"tools,omitempty\"`\n+\t// 빈 문자열이면 마지막 페이지\n+\tNextCursor    string `protobuf:\"bytes,2,opt,name=next_cursor,json=nextCursor,proto3\" json:\"next_cursor,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ListToolsResponse) Reset() {\n+\t*x = ListToolsResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[6]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ListToolsResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ListToolsResponse) ProtoMessage() {}\n+\n+func (x *ListToolsResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[6]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ListToolsResponse.ProtoReflect.Descriptor instead.\n+func (*ListToolsResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{6}\n+}\n+\n+func (x *ListToolsResponse) GetTools() []*Tool {\n+\tif x != nil {\n+\t\treturn x.Tools\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ListToolsResponse) GetNextCursor() string {\n+\tif x != nil {\n+\t\treturn x.NextCursor\n+\t}\n+\treturn \"\"\n+}\n+\n+// 세션 종료 요청\n+type CloseSessionRequest struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tSessionId     string                 `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CloseSessionRequest) Reset() {\n+\t*x = CloseSessionRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[7]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CloseSessionRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CloseSessionRequest) ProtoMessage() {}\n+\n+func (x *CloseSessionRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[7]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CloseSessionRequest.ProtoReflect.Descriptor instead.\n+func (*CloseSessionRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{7}\n+}\n+\n+func (x *CloseSessionRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+// 세션 종료 응답\n+type CloseSessionResponse struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CloseSessionResponse) Reset() {\n+\t*x = CloseSessionResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[8]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CloseSessionResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CloseSessionResponse) ProtoMessage() {}\n+\n+func (x *CloseSessionResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[8]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CloseSessionResponse.ProtoReflect.Descriptor instead.\n+func (*CloseSessionResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{8}\n+}\n+\n+// JSON-RPC notification 전달 요청\n+type SendNotificationRequest struct {\n+\tstate     protoimpl.MessageState `protogen:\"open.v1\"`\n+\tSessionId string                 `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\t// e.g. \"notifications/cancelled\"\n+\tMethod string `protobuf:\"bytes,2,opt,name=method,proto3\" json:\"method,omitempty\"`\n+\t// JSON string\n+\tParamsJson    string `protobuf:\"bytes,3,opt,name=params_json,json=paramsJson,proto3\" json:\"params_json,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SendNotificationRequest) Reset() {\n+\t*x = SendNotificationRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[9]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SendNotificationRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SendNotificationRequest) ProtoMessage() {}\n+\n+func (x *SendNotificationRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[9]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SendNotificationRequest.ProtoReflect.Descriptor instead.\n+func (*SendNotificationRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{9}\n+}\n+\n+func (x *SendNotificationRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SendNotificationRequest) GetMethod() string {\n+\tif x != nil {\n+\t\treturn x.Method\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SendNotificationRequest) GetParamsJson() string {\n+\tif x != nil {\n+\t\treturn x.ParamsJson\n+\t}\n+\treturn \"\"\n+}\n+\n+// JSON-RPC notification 전달 응답\n+type SendNotificationResponse struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SendNotificationResponse) Reset() {\n+\t*x = SendNotificationResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[10]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SendNotificationResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SendNotificationResponse) ProtoMessage() {}\n+\n+func (x *SendNotificationResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[10]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SendNotificationResponse.ProtoReflect.Descriptor instead.\n+func (*SendNotificationResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{10}\n+}\n+\n+// 세션 존재 여부 조회 요청\n+type QuerySessionRequest struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tSessionId     string                 `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *QuerySessionRequest) Reset() {\n+\t*x = QuerySessionRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[11]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *QuerySessionRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*QuerySessionRequest) ProtoMessage() {}\n+\n+func (x *QuerySessionRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[11]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use QuerySessionRequest.ProtoReflect.Descriptor instead.\n+func (*QuerySessionRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{11}\n+}\n+\n+func (x *QuerySessionRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+// 세션 존재 여부 조회 응답\n+type QuerySessionResponse struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tExistence     SessionExistence       `protobuf:\"varint,1,opt,name=existence,proto3,enum=duplo.mcp.v1.SessionExistence\" json:\"existence,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *QuerySessionResponse) Reset() {\n+\t*x = QuerySessionResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[12]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *QuerySessionResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*QuerySessionResponse) ProtoMessage() {}\n+\n+func (x *QuerySessionResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[12]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use QuerySessionResponse.ProtoReflect.Descriptor instead.\n+func (*QuerySessionResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{12}\n+}\n+\n+func (x *QuerySessionResponse) GetExistence() SessionExistence {\n+\tif x != nil {\n+\t\treturn x.Existence\n+\t}\n+\treturn SessionExistence_SESSION_EXISTENCE_UNSPECIFIED\n+}\n+\n+// 세션 삭제 요청. session_id 또는 agent_installation_id로 대상 지정\n+type DeleteSessionRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// Types that are valid to be assigned to Target:\n+\t//\n+\t//\t*DeleteSessionRequest_SessionId\n+\t//\t*DeleteSessionRequest_AgentInstallationId\n+\tTarget        isDeleteSessionRequest_Target `protobuf_oneof:\"target\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *DeleteSessionRequest) Reset() {\n+\t*x = DeleteSessionRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[13]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *DeleteSessionRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*DeleteSessionRequest) ProtoMessage() {}\n+\n+func (x *DeleteSessionRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[13]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use DeleteSessionRequest.ProtoReflect.Descriptor instead.\n+func (*DeleteSessionRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{13}\n+}\n+\n+func (x *DeleteSessionRequest) GetTarget() isDeleteSessionRequest_Target {\n+\tif x != nil {\n+\t\treturn x.Target\n+\t}\n+\treturn nil\n+}\n+\n+func (x *DeleteSessionRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\tif x, ok := x.Target.(*DeleteSessionRequest_SessionId); ok {\n+\t\t\treturn x.SessionId\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *DeleteSessionRequest) GetAgentInstallationId() string {\n+\tif x != nil {\n+\t\tif x, ok := x.Target.(*DeleteSessionRequest_AgentInstallationId); ok {\n+\t\t\treturn x.AgentInstallationId\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+type isDeleteSessionRequest_Target interface {\n+\tisDeleteSessionRequest_Target()\n+}\n+\n+type DeleteSessionRequest_SessionId struct {\n+\tSessionId string `protobuf:\"bytes,1,opt,name=session_id,json=sessionId,proto3,oneof\"`\n+}\n+\n+type DeleteSessionRequest_AgentInstallationId struct {\n+\tAgentInstallationId string `protobuf:\"bytes,2,opt,name=agent_installation_id,json=agentInstallationId,proto3,oneof\"`\n+}\n+\n+func (*DeleteSessionRequest_SessionId) isDeleteSessionRequest_Target() {}\n+\n+func (*DeleteSessionRequest_AgentInstallationId) isDeleteSessionRequest_Target() {}\n+\n+// 세션 삭제 응답\n+type DeleteSessionResponse struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tDeletedCount  int32                  `protobuf:\"varint,1,opt,name=deleted_count,json=deletedCount,proto3\" json:\"deleted_count,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *DeleteSessionResponse) Reset() {\n+\t*x = DeleteSessionResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[14]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *DeleteSessionResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*DeleteSessionResponse) ProtoMessage() {}\n+\n+func (x *DeleteSessionResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[14]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use DeleteSessionResponse.ProtoReflect.Descriptor instead.\n+func (*DeleteSessionResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{14}\n+}\n+\n+func (x *DeleteSessionResponse) GetDeletedCount() int32 {\n+\tif x != nil {\n+\t\treturn x.DeletedCount\n+\t}\n+\treturn 0\n+}\n+\n+// CLI HTTP 서명 인증 시 AccessKey 검증 위임 요청\n+// Go Proxy는 서명을 자체 검증할 수 없으므로(DeviceID/Secret이 Backend DB에 존재),\n+// Backend에 유효성 확인을 위임한다\n+type VerifyAccessKeyRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// 설치 과정에서 발급된 AccessKey\n+\tAccessKey     string `protobuf:\"bytes,1,opt,name=access_key,json=accessKey,proto3\" json:\"access_key,omitempty\"`\n+\tPresetId      string `protobuf:\"bytes,2,opt,name=preset_id,json=presetId,proto3\" json:\"preset_id,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *VerifyAccessKeyRequest) Reset() {\n+\t*x = VerifyAccessKeyRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[15]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *VerifyAccessKeyRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*VerifyAccessKeyRequest) ProtoMessage() {}\n+\n+func (x *VerifyAccessKeyRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[15]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use VerifyAccessKeyRequest.ProtoReflect.Descriptor instead.\n+func (*VerifyAccessKeyRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{15}\n+}\n+\n+func (x *VerifyAccessKeyRequest) GetAccessKey() string {\n+\tif x != nil {\n+\t\treturn x.AccessKey\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *VerifyAccessKeyRequest) GetPresetId() string {\n+\tif x != nil {\n+\t\treturn x.PresetId\n+\t}\n+\treturn \"\"\n+}\n+\n+// AccessKey 검증 응답\n+type VerifyAccessKeyResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\tValid bool                   `protobuf:\"varint,1,opt,name=valid,proto3\" json:\"valid,omitempty\"`\n+\t// 검증 성공 시 CreateSession의 AuthContext로 사용\n+\tUserId        string `protobuf:\"bytes,2,opt,name=user_id,json=userId,proto3\" json:\"user_id,omitempty\"`\n+\tDeviceId      string `protobuf:\"bytes,3,opt,name=device_id,json=deviceId,proto3\" json:\"device_id,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *VerifyAccessKeyResponse) Reset() {\n+\t*x = VerifyAccessKeyResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[16]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *VerifyAccessKeyResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*VerifyAccessKeyResponse) ProtoMessage() {}\n+\n+func (x *VerifyAccessKeyResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[16]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use VerifyAccessKeyResponse.ProtoReflect.Descriptor instead.\n+func (*VerifyAccessKeyResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{16}\n+}\n+\n+func (x *VerifyAccessKeyResponse) GetValid() bool {\n+\tif x != nil {\n+\t\treturn x.Valid\n+\t}\n+\treturn false\n+}\n+\n+func (x *VerifyAccessKeyResponse) GetUserId() string {\n+\tif x != nil {\n+\t\treturn x.UserId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *VerifyAccessKeyResponse) GetDeviceId() string {\n+\tif x != nil {\n+\t\treturn x.DeviceId\n+\t}\n+\treturn \"\"\n+}\n+\n+// gRPC 에러 응답\n+type ErrorResponse struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tCode          int32                  `protobuf:\"varint,1,opt,name=code,proto3\" json:\"code,omitempty\"`\n+\tMessage       string                 `protobuf:\"bytes,2,opt,name=message,proto3\" json:\"message,omitempty\"`\n+\tDetailsJson   string                 `protobuf:\"bytes,3,opt,name=details_json,json=detailsJson,proto3\" json:\"details_json,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ErrorResponse) Reset() {\n+\t*x = ErrorResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[17]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ErrorResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ErrorResponse) ProtoMessage() {}\n+\n+func (x *ErrorResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[17]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ErrorResponse.ProtoReflect.Descriptor instead.\n+func (*ErrorResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{17}\n+}\n+\n+func (x *ErrorResponse) GetCode() int32 {\n+\tif x != nil {\n+\t\treturn x.Code\n+\t}\n+\treturn 0\n+}\n+\n+func (x *ErrorResponse) GetMessage() string {\n+\tif x != nil {\n+\t\treturn x.Message\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ErrorResponse) GetDetailsJson() string {\n+\tif x != nil {\n+\t\treturn x.DetailsJson\n+\t}\n+\treturn \"\"\n+}\n+\n+// Channel RPC — Go Proxy → Backend 스트림 메시지\n+type ChannelRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// 세션 멀티플렉싱 키 (ping/pong에서는 빈 문자열)\n+\tSessionId string `protobuf:\"bytes,2,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\t// 요청-응답 매칭 키 (CallTool → CallToolResult/Progress)\n+\tRequestId string `protobuf:\"bytes,3,opt,name=request_id,json=requestId,proto3\" json:\"request_id,omitempty\"`\n+\t// Types that are valid to be assigned to Payload:\n+\t//\n+\t//\t*ChannelRequest_Error\n+\t//\t*ChannelRequest_CallTool\n+\t//\t*ChannelRequest_SubscribeEvents\n+\t//\t*ChannelRequest_UnsubscribeEvents\n+\t//\t*ChannelRequest_Ping\n+\tPayload       isChannelRequest_Payload `protobuf_oneof:\"payload\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ChannelRequest) Reset() {\n+\t*x = ChannelRequest{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[18]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ChannelRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ChannelRequest) ProtoMessage() {}\n+\n+func (x *ChannelRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[18]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ChannelRequest.ProtoReflect.Descriptor instead.\n+func (*ChannelRequest) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{18}\n+}\n+\n+func (x *ChannelRequest) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ChannelRequest) GetRequestId() string {\n+\tif x != nil {\n+\t\treturn x.RequestId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ChannelRequest) GetPayload() isChannelRequest_Payload {\n+\tif x != nil {\n+\t\treturn x.Payload\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelRequest) GetError() *ErrorResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelRequest_Error); ok {\n+\t\t\treturn x.Error\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelRequest) GetCallTool() *CallToolPayload {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelRequest_CallTool); ok {\n+\t\t\treturn x.CallTool\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelRequest) GetSubscribeEvents() *SubscribeEventsPayload {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelRequest_SubscribeEvents); ok {\n+\t\t\treturn x.SubscribeEvents\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelRequest) GetUnsubscribeEvents() *UnsubscribeEventsPayload {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelRequest_UnsubscribeEvents); ok {\n+\t\t\treturn x.UnsubscribeEvents\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelRequest) GetPing() *PingPayload {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelRequest_Ping); ok {\n+\t\t\treturn x.Ping\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type isChannelRequest_Payload interface {\n+\tisChannelRequest_Payload()\n+}\n+\n+type ChannelRequest_Error struct {\n+\tError *ErrorResponse `protobuf:\"bytes,10,opt,name=error,proto3,oneof\"`\n+}\n+\n+type ChannelRequest_CallTool struct {\n+\tCallTool *CallToolPayload `protobuf:\"bytes,11,opt,name=call_tool,json=callTool,proto3,oneof\"`\n+}\n+\n+type ChannelRequest_SubscribeEvents struct {\n+\tSubscribeEvents *SubscribeEventsPayload `protobuf:\"bytes,12,opt,name=subscribe_events,json=subscribeEvents,proto3,oneof\"`\n+}\n+\n+type ChannelRequest_UnsubscribeEvents struct {\n+\tUnsubscribeEvents *UnsubscribeEventsPayload `protobuf:\"bytes,13,opt,name=unsubscribe_events,json=unsubscribeEvents,proto3,oneof\"`\n+}\n+\n+type ChannelRequest_Ping struct {\n+\tPing *PingPayload `protobuf:\"bytes,14,opt,name=ping,proto3,oneof\"`\n+}\n+\n+func (*ChannelRequest_Error) isChannelRequest_Payload() {}\n+\n+func (*ChannelRequest_CallTool) isChannelRequest_Payload() {}\n+\n+func (*ChannelRequest_SubscribeEvents) isChannelRequest_Payload() {}\n+\n+func (*ChannelRequest_UnsubscribeEvents) isChannelRequest_Payload() {}\n+\n+func (*ChannelRequest_Ping) isChannelRequest_Payload() {}\n+\n+// Channel RPC — Backend → Go Proxy 스트림 메시지\n+type ChannelResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// 세션 멀티플렉싱 키 (ping/pong에서는 빈 문자열)\n+\tSessionId string `protobuf:\"bytes,2,opt,name=session_id,json=sessionId,proto3\" json:\"session_id,omitempty\"`\n+\t// 요청-응답 매칭 키 (CallTool → CallToolResult/Progress)\n+\tRequestId string `protobuf:\"bytes,3,opt,name=request_id,json=requestId,proto3\" json:\"request_id,omitempty\"`\n+\t// Types that are valid to be assigned to Payload:\n+\t//\n+\t//\t*ChannelResponse_Error\n+\t//\t*ChannelResponse_Progress\n+\t//\t*ChannelResponse_CallToolResult\n+\t//\t*ChannelResponse_ToolListChanged\n+\t//\t*ChannelResponse_LoggingMessage\n+\t//\t*ChannelResponse_Pong\n+\tPayload       isChannelResponse_Payload `protobuf_oneof:\"payload\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ChannelResponse) Reset() {\n+\t*x = ChannelResponse{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[19]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ChannelResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ChannelResponse) ProtoMessage() {}\n+\n+func (x *ChannelResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[19]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ChannelResponse.ProtoReflect.Descriptor instead.\n+func (*ChannelResponse) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{19}\n+}\n+\n+func (x *ChannelResponse) GetSessionId() string {\n+\tif x != nil {\n+\t\treturn x.SessionId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ChannelResponse) GetRequestId() string {\n+\tif x != nil {\n+\t\treturn x.RequestId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ChannelResponse) GetPayload() isChannelResponse_Payload {\n+\tif x != nil {\n+\t\treturn x.Payload\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelResponse) GetError() *ErrorResponse {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelResponse_Error); ok {\n+\t\t\treturn x.Error\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelResponse) GetProgress() *ProgressNotification {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelResponse_Progress); ok {\n+\t\t\treturn x.Progress\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelResponse) GetCallToolResult() *CallToolResult {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelResponse_CallToolResult); ok {\n+\t\t\treturn x.CallToolResult\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelResponse) GetToolListChanged() *ToolListChangedEvent {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelResponse_ToolListChanged); ok {\n+\t\t\treturn x.ToolListChanged\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelResponse) GetLoggingMessage() *LoggingMessageEvent {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelResponse_LoggingMessage); ok {\n+\t\t\treturn x.LoggingMessage\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ChannelResponse) GetPong() *PongPayload {\n+\tif x != nil {\n+\t\tif x, ok := x.Payload.(*ChannelResponse_Pong); ok {\n+\t\t\treturn x.Pong\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type isChannelResponse_Payload interface {\n+\tisChannelResponse_Payload()\n+}\n+\n+type ChannelResponse_Error struct {\n+\tError *ErrorResponse `protobuf:\"bytes,10,opt,name=error,proto3,oneof\"`\n+}\n+\n+type ChannelResponse_Progress struct {\n+\tProgress *ProgressNotification `protobuf:\"bytes,11,opt,name=progress,proto3,oneof\"`\n+}\n+\n+type ChannelResponse_CallToolResult struct {\n+\tCallToolResult *CallToolResult `protobuf:\"bytes,12,opt,name=call_tool_result,json=callToolResult,proto3,oneof\"`\n+}\n+\n+type ChannelResponse_ToolListChanged struct {\n+\tToolListChanged *ToolListChangedEvent `protobuf:\"bytes,13,opt,name=tool_list_changed,json=toolListChanged,proto3,oneof\"`\n+}\n+\n+type ChannelResponse_LoggingMessage struct {\n+\tLoggingMessage *LoggingMessageEvent `protobuf:\"bytes,14,opt,name=logging_message,json=loggingMessage,proto3,oneof\"`\n+}\n+\n+type ChannelResponse_Pong struct {\n+\tPong *PongPayload `protobuf:\"bytes,15,opt,name=pong,proto3,oneof\"`\n+}\n+\n+func (*ChannelResponse_Error) isChannelResponse_Payload() {}\n+\n+func (*ChannelResponse_Progress) isChannelResponse_Payload() {}\n+\n+func (*ChannelResponse_CallToolResult) isChannelResponse_Payload() {}\n+\n+func (*ChannelResponse_ToolListChanged) isChannelResponse_Payload() {}\n+\n+func (*ChannelResponse_LoggingMessage) isChannelResponse_Payload() {}\n+\n+func (*ChannelResponse_Pong) isChannelResponse_Payload() {}\n+\n+// 도구 호출 요청 payload\n+type CallToolPayload struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\tName  string                 `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"`\n+\t// JSON string (int64/double 등 원본 타입 보존)\n+\tArgumentsJson string           `protobuf:\"bytes,2,opt,name=arguments_json,json=argumentsJson,proto3\" json:\"arguments_json,omitempty\"`\n+\tMeta          *structpb.Struct `protobuf:\"bytes,3,opt,name=meta,proto3\" json:\"meta,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CallToolPayload) Reset() {\n+\t*x = CallToolPayload{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[20]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CallToolPayload) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CallToolPayload) ProtoMessage() {}\n+\n+func (x *CallToolPayload) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[20]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CallToolPayload.ProtoReflect.Descriptor instead.\n+func (*CallToolPayload) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{20}\n+}\n+\n+func (x *CallToolPayload) GetName() string {\n+\tif x != nil {\n+\t\treturn x.Name\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CallToolPayload) GetArgumentsJson() string {\n+\tif x != nil {\n+\t\treturn x.ArgumentsJson\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *CallToolPayload) GetMeta() *structpb.Struct {\n+\tif x != nil {\n+\t\treturn x.Meta\n+\t}\n+\treturn nil\n+}\n+\n+// 도구 호출 결과\n+type CallToolResult struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tContent       []*Content             `protobuf:\"bytes,1,rep,name=content,proto3\" json:\"content,omitempty\"`\n+\tIsError       bool                   `protobuf:\"varint,2,opt,name=is_error,json=isError,proto3\" json:\"is_error,omitempty\"`\n+\tMeta          *structpb.Struct       `protobuf:\"bytes,3,opt,name=meta,proto3\" json:\"meta,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *CallToolResult) Reset() {\n+\t*x = CallToolResult{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[21]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *CallToolResult) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*CallToolResult) ProtoMessage() {}\n+\n+func (x *CallToolResult) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[21]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use CallToolResult.ProtoReflect.Descriptor instead.\n+func (*CallToolResult) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{21}\n+}\n+\n+func (x *CallToolResult) GetContent() []*Content {\n+\tif x != nil {\n+\t\treturn x.Content\n+\t}\n+\treturn nil\n+}\n+\n+func (x *CallToolResult) GetIsError() bool {\n+\tif x != nil {\n+\t\treturn x.IsError\n+\t}\n+\treturn false\n+}\n+\n+func (x *CallToolResult) GetMeta() *structpb.Struct {\n+\tif x != nil {\n+\t\treturn x.Meta\n+\t}\n+\treturn nil\n+}\n+\n+// 세션의 비동기 이벤트 구독 시작\n+type SubscribeEventsPayload struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SubscribeEventsPayload) Reset() {\n+\t*x = SubscribeEventsPayload{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[22]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SubscribeEventsPayload) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SubscribeEventsPayload) ProtoMessage() {}\n+\n+func (x *SubscribeEventsPayload) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[22]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SubscribeEventsPayload.ProtoReflect.Descriptor instead.\n+func (*SubscribeEventsPayload) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{22}\n+}\n+\n+// 세션의 비동기 이벤트 구독 해제\n+type UnsubscribeEventsPayload struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *UnsubscribeEventsPayload) Reset() {\n+\t*x = UnsubscribeEventsPayload{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[23]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *UnsubscribeEventsPayload) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*UnsubscribeEventsPayload) ProtoMessage() {}\n+\n+func (x *UnsubscribeEventsPayload) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[23]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use UnsubscribeEventsPayload.ProtoReflect.Descriptor instead.\n+func (*UnsubscribeEventsPayload) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{23}\n+}\n+\n+// 연결 헬스체크 요청\n+type PingPayload struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *PingPayload) Reset() {\n+\t*x = PingPayload{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[24]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *PingPayload) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*PingPayload) ProtoMessage() {}\n+\n+func (x *PingPayload) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[24]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use PingPayload.ProtoReflect.Descriptor instead.\n+func (*PingPayload) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{24}\n+}\n+\n+// 연결 헬스체크 응답\n+type PongPayload struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *PongPayload) Reset() {\n+\t*x = PongPayload{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[25]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *PongPayload) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*PongPayload) ProtoMessage() {}\n+\n+func (x *PongPayload) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[25]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use PongPayload.ProtoReflect.Descriptor instead.\n+func (*PongPayload) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{25}\n+}\n+\n+// 도구 실행 중 진행 상황 알림\n+type ProgressNotification struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tProgressToken string                 `protobuf:\"bytes,1,opt,name=progress_token,json=progressToken,proto3\" json:\"progress_token,omitempty\"`\n+\tProgress      *float64               `protobuf:\"fixed64,2,opt,name=progress,proto3,oneof\" json:\"progress,omitempty\"` // null = indeterminate\n+\tTotal         *float64               `protobuf:\"fixed64,3,opt,name=total,proto3,oneof\" json:\"total,omitempty\"`       // null = unknown total\n+\tMessage       string                 `protobuf:\"bytes,4,opt,name=message,proto3\" json:\"message,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ProgressNotification) Reset() {\n+\t*x = ProgressNotification{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[26]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ProgressNotification) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ProgressNotification) ProtoMessage() {}\n+\n+func (x *ProgressNotification) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[26]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ProgressNotification.ProtoReflect.Descriptor instead.\n+func (*ProgressNotification) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{26}\n+}\n+\n+func (x *ProgressNotification) GetProgressToken() string {\n+\tif x != nil {\n+\t\treturn x.ProgressToken\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ProgressNotification) GetProgress() float64 {\n+\tif x != nil && x.Progress != nil {\n+\t\treturn *x.Progress\n+\t}\n+\treturn 0\n+}\n+\n+func (x *ProgressNotification) GetTotal() float64 {\n+\tif x != nil && x.Total != nil {\n+\t\treturn *x.Total\n+\t}\n+\treturn 0\n+}\n+\n+func (x *ProgressNotification) GetMessage() string {\n+\tif x != nil {\n+\t\treturn x.Message\n+\t}\n+\treturn \"\"\n+}\n+\n+// 도구 목록 변경 알림\n+type ToolListChangedEvent struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ToolListChangedEvent) Reset() {\n+\t*x = ToolListChangedEvent{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[27]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ToolListChangedEvent) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ToolListChangedEvent) ProtoMessage() {}\n+\n+func (x *ToolListChangedEvent) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[27]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ToolListChangedEvent.ProtoReflect.Descriptor instead.\n+func (*ToolListChangedEvent) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{27}\n+}\n+\n+// MCP 로깅 메시지\n+type LoggingMessageEvent struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// debug, info, notice, warning, error, critical, alert, emergency\n+\tLevel         string `protobuf:\"bytes,1,opt,name=level,proto3\" json:\"level,omitempty\"`\n+\tLogger        string `protobuf:\"bytes,2,opt,name=logger,proto3\" json:\"logger,omitempty\"`\n+\tDataJson      string `protobuf:\"bytes,3,opt,name=data_json,json=dataJson,proto3\" json:\"data_json,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *LoggingMessageEvent) Reset() {\n+\t*x = LoggingMessageEvent{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[28]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *LoggingMessageEvent) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*LoggingMessageEvent) ProtoMessage() {}\n+\n+func (x *LoggingMessageEvent) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[28]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use LoggingMessageEvent.ProtoReflect.Descriptor instead.\n+func (*LoggingMessageEvent) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{28}\n+}\n+\n+func (x *LoggingMessageEvent) GetLevel() string {\n+\tif x != nil {\n+\t\treturn x.Level\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *LoggingMessageEvent) GetLogger() string {\n+\tif x != nil {\n+\t\treturn x.Logger\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *LoggingMessageEvent) GetDataJson() string {\n+\tif x != nil {\n+\t\treturn x.DataJson\n+\t}\n+\treturn \"\"\n+}\n+\n+// Go Proxy가 인증 후 전달하는 사용자 컨텍스트\n+type AuthContext struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tUserId        string                 `protobuf:\"bytes,1,opt,name=user_id,json=userId,proto3\" json:\"user_id,omitempty\"`\n+\tAuthMethod    AuthMethod             `protobuf:\"varint,2,opt,name=auth_method,json=authMethod,proto3,enum=duplo.mcp.v1.AuthMethod\" json:\"auth_method,omitempty\"`\n+\tMetadata      map[string]string      `protobuf:\"bytes,3,rep,name=metadata,proto3\" json:\"metadata,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *AuthContext) Reset() {\n+\t*x = AuthContext{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[29]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *AuthContext) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*AuthContext) ProtoMessage() {}\n+\n+func (x *AuthContext) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[29]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use AuthContext.ProtoReflect.Descriptor instead.\n+func (*AuthContext) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{29}\n+}\n+\n+func (x *AuthContext) GetUserId() string {\n+\tif x != nil {\n+\t\treturn x.UserId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *AuthContext) GetAuthMethod() AuthMethod {\n+\tif x != nil {\n+\t\treturn x.AuthMethod\n+\t}\n+\treturn AuthMethod_AUTH_METHOD_UNSPECIFIED\n+}\n+\n+func (x *AuthContext) GetMetadata() map[string]string {\n+\tif x != nil {\n+\t\treturn x.Metadata\n+\t}\n+\treturn nil\n+}\n+\n+// MCP 클라이언트 접속 메타정보\n+type ClientInfo struct {\n+\tstate          protoimpl.MessageState `protogen:\"open.v1\"`\n+\tIp             string                 `protobuf:\"bytes,1,opt,name=ip,proto3\" json:\"ip,omitempty\"`\n+\tUserAgent      string                 `protobuf:\"bytes,2,opt,name=user_agent,json=userAgent,proto3\" json:\"user_agent,omitempty\"`\n+\tConversationId string                 `protobuf:\"bytes,3,opt,name=conversation_id,json=conversationId,proto3\" json:\"conversation_id,omitempty\"`\n+\tunknownFields  protoimpl.UnknownFields\n+\tsizeCache      protoimpl.SizeCache\n+}\n+\n+func (x *ClientInfo) Reset() {\n+\t*x = ClientInfo{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[30]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ClientInfo) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ClientInfo) ProtoMessage() {}\n+\n+func (x *ClientInfo) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[30]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ClientInfo.ProtoReflect.Descriptor instead.\n+func (*ClientInfo) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{30}\n+}\n+\n+func (x *ClientInfo) GetIp() string {\n+\tif x != nil {\n+\t\treturn x.Ip\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ClientInfo) GetUserAgent() string {\n+\tif x != nil {\n+\t\treturn x.UserAgent\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ClientInfo) GetConversationId() string {\n+\tif x != nil {\n+\t\treturn x.ConversationId\n+\t}\n+\treturn \"\"\n+}\n+\n+// MCP 클라이언트 구현체 정보\n+type McpClientInfo struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tName          string                 `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"`\n+\tVersion       string                 `protobuf:\"bytes,2,opt,name=version,proto3\" json:\"version,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *McpClientInfo) Reset() {\n+\t*x = McpClientInfo{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[31]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *McpClientInfo) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*McpClientInfo) ProtoMessage() {}\n+\n+func (x *McpClientInfo) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[31]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use McpClientInfo.ProtoReflect.Descriptor instead.\n+func (*McpClientInfo) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{31}\n+}\n+\n+func (x *McpClientInfo) GetName() string {\n+\tif x != nil {\n+\t\treturn x.Name\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *McpClientInfo) GetVersion() string {\n+\tif x != nil {\n+\t\treturn x.Version\n+\t}\n+\treturn \"\"\n+}\n+\n+// MCP 서버 기능\n+type ServerCapabilities struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tTools         *ToolsCapability       `protobuf:\"bytes,1,opt,name=tools,proto3\" json:\"tools,omitempty\"`\n+\tLogging       *LoggingCapability     `protobuf:\"bytes,2,opt,name=logging,proto3\" json:\"logging,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ServerCapabilities) Reset() {\n+\t*x = ServerCapabilities{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[32]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ServerCapabilities) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ServerCapabilities) ProtoMessage() {}\n+\n+func (x *ServerCapabilities) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[32]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ServerCapabilities.ProtoReflect.Descriptor instead.\n+func (*ServerCapabilities) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{32}\n+}\n+\n+func (x *ServerCapabilities) GetTools() *ToolsCapability {\n+\tif x != nil {\n+\t\treturn x.Tools\n+\t}\n+\treturn nil\n+}\n+\n+func (x *ServerCapabilities) GetLogging() *LoggingCapability {\n+\tif x != nil {\n+\t\treturn x.Logging\n+\t}\n+\treturn nil\n+}\n+\n+// 도구 관련 기능\n+type ToolsCapability struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tListChanged   bool                   `protobuf:\"varint,1,opt,name=list_changed,json=listChanged,proto3\" json:\"list_changed,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ToolsCapability) Reset() {\n+\t*x = ToolsCapability{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[33]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ToolsCapability) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ToolsCapability) ProtoMessage() {}\n+\n+func (x *ToolsCapability) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[33]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ToolsCapability.ProtoReflect.Descriptor instead.\n+func (*ToolsCapability) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{33}\n+}\n+\n+func (x *ToolsCapability) GetListChanged() bool {\n+\tif x != nil {\n+\t\treturn x.ListChanged\n+\t}\n+\treturn false\n+}\n+\n+// 로깅 관련 기능. 향후 설정 필드 추가 가능\n+type LoggingCapability struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *LoggingCapability) Reset() {\n+\t*x = LoggingCapability{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[34]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *LoggingCapability) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*LoggingCapability) ProtoMessage() {}\n+\n+func (x *LoggingCapability) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[34]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use LoggingCapability.ProtoReflect.Descriptor instead.\n+func (*LoggingCapability) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{34}\n+}\n+\n+// MCP 서버 구현체 정보\n+type ServerInfo struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tName          string                 `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"`\n+\tVersion       string                 `protobuf:\"bytes,2,opt,name=version,proto3\" json:\"version,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ServerInfo) Reset() {\n+\t*x = ServerInfo{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[35]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ServerInfo) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ServerInfo) ProtoMessage() {}\n+\n+func (x *ServerInfo) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[35]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ServerInfo.ProtoReflect.Descriptor instead.\n+func (*ServerInfo) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{35}\n+}\n+\n+func (x *ServerInfo) GetName() string {\n+\tif x != nil {\n+\t\treturn x.Name\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ServerInfo) GetVersion() string {\n+\tif x != nil {\n+\t\treturn x.Version\n+\t}\n+\treturn \"\"\n+}\n+\n+// MCP 도구 정의\n+type Tool struct {\n+\tstate       protoimpl.MessageState `protogen:\"open.v1\"`\n+\tName        string                 `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"`\n+\tDescription string                 `protobuf:\"bytes,2,opt,name=description,proto3\" json:\"description,omitempty\"`\n+\t// JSON Schema (JSON string)\n+\tInputSchemaJson          string           `protobuf:\"bytes,3,opt,name=input_schema_json,json=inputSchemaJson,proto3\" json:\"input_schema_json,omitempty\"`\n+\tDisplayedDescription     string           `protobuf:\"bytes,4,opt,name=displayed_description,json=displayedDescription,proto3\" json:\"displayed_description,omitempty\"`\n+\tIntegrationId            string           `protobuf:\"bytes,5,opt,name=integration_id,json=integrationId,proto3\" json:\"integration_id,omitempty\"`\n+\tIntegrationName          string           `protobuf:\"bytes,6,opt,name=integration_name,json=integrationName,proto3\" json:\"integration_name,omitempty\"`\n+\tInstalledIntegrationId   string           `protobuf:\"bytes,7,opt,name=installed_integration_id,json=installedIntegrationId,proto3\" json:\"installed_integration_id,omitempty\"`\n+\tInstalledIntegrationName string           `protobuf:\"bytes,8,opt,name=installed_integration_name,json=installedIntegrationName,proto3\" json:\"installed_integration_name,omitempty\"`\n+\tMeta                     *structpb.Struct `protobuf:\"bytes,9,opt,name=meta,proto3\" json:\"meta,omitempty\"`\n+\tunknownFields            protoimpl.UnknownFields\n+\tsizeCache                protoimpl.SizeCache\n+}\n+\n+func (x *Tool) Reset() {\n+\t*x = Tool{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[36]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *Tool) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*Tool) ProtoMessage() {}\n+\n+func (x *Tool) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[36]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use Tool.ProtoReflect.Descriptor instead.\n+func (*Tool) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{36}\n+}\n+\n+func (x *Tool) GetName() string {\n+\tif x != nil {\n+\t\treturn x.Name\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetDescription() string {\n+\tif x != nil {\n+\t\treturn x.Description\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetInputSchemaJson() string {\n+\tif x != nil {\n+\t\treturn x.InputSchemaJson\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetDisplayedDescription() string {\n+\tif x != nil {\n+\t\treturn x.DisplayedDescription\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetIntegrationId() string {\n+\tif x != nil {\n+\t\treturn x.IntegrationId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetIntegrationName() string {\n+\tif x != nil {\n+\t\treturn x.IntegrationName\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetInstalledIntegrationId() string {\n+\tif x != nil {\n+\t\treturn x.InstalledIntegrationId\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetInstalledIntegrationName() string {\n+\tif x != nil {\n+\t\treturn x.InstalledIntegrationName\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *Tool) GetMeta() *structpb.Struct {\n+\tif x != nil {\n+\t\treturn x.Meta\n+\t}\n+\treturn nil\n+}\n+\n+// 도구 실행 결과 콘텐츠\n+type Content struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// Types that are valid to be assigned to Content:\n+\t//\n+\t//\t*Content_Text\n+\t//\t*Content_Image\n+\tContent       isContent_Content `protobuf_oneof:\"content\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *Content) Reset() {\n+\t*x = Content{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[37]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *Content) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*Content) ProtoMessage() {}\n+\n+func (x *Content) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[37]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use Content.ProtoReflect.Descriptor instead.\n+func (*Content) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{37}\n+}\n+\n+func (x *Content) GetContent() isContent_Content {\n+\tif x != nil {\n+\t\treturn x.Content\n+\t}\n+\treturn nil\n+}\n+\n+func (x *Content) GetText() *TextContent {\n+\tif x != nil {\n+\t\tif x, ok := x.Content.(*Content_Text); ok {\n+\t\t\treturn x.Text\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (x *Content) GetImage() *ImageContent {\n+\tif x != nil {\n+\t\tif x, ok := x.Content.(*Content_Image); ok {\n+\t\t\treturn x.Image\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type isContent_Content interface {\n+\tisContent_Content()\n+}\n+\n+type Content_Text struct {\n+\tText *TextContent `protobuf:\"bytes,1,opt,name=text,proto3,oneof\"`\n+}\n+\n+type Content_Image struct {\n+\tImage *ImageContent `protobuf:\"bytes,2,opt,name=image,proto3,oneof\"`\n+}\n+\n+func (*Content_Text) isContent_Content() {}\n+\n+func (*Content_Image) isContent_Content() {}\n+\n+// 텍스트 콘텐츠\n+type TextContent struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tText          string                 `protobuf:\"bytes,1,opt,name=text,proto3\" json:\"text,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *TextContent) Reset() {\n+\t*x = TextContent{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[38]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *TextContent) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*TextContent) ProtoMessage() {}\n+\n+func (x *TextContent) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[38]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use TextContent.ProtoReflect.Descriptor instead.\n+func (*TextContent) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{38}\n+}\n+\n+func (x *TextContent) GetText() string {\n+\tif x != nil {\n+\t\treturn x.Text\n+\t}\n+\treturn \"\"\n+}\n+\n+// 이미지 콘텐츠 (Base64 인코딩)\n+type ImageContent struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tData          string                 `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"`\n+\tMimeType      string                 `protobuf:\"bytes,2,opt,name=mime_type,json=mimeType,proto3\" json:\"mime_type,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *ImageContent) Reset() {\n+\t*x = ImageContent{}\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[39]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *ImageContent) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*ImageContent) ProtoMessage() {}\n+\n+func (x *ImageContent) ProtoReflect() protoreflect.Message {\n+\tmi := &file_duplo_mcp_v1_mcp_connector_proto_msgTypes[39]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use ImageContent.ProtoReflect.Descriptor instead.\n+func (*ImageContent) Descriptor() ([]byte, []int) {\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP(), []int{39}\n+}\n+\n+func (x *ImageContent) GetData() string {\n+\tif x != nil {\n+\t\treturn x.Data\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *ImageContent) GetMimeType() string {\n+\tif x != nil {\n+\t\treturn x.MimeType\n+\t}\n+\treturn \"\"\n+}\n+\n+var File_duplo_mcp_v1_mcp_connector_proto protoreflect.FileDescriptor\n+\n+const file_duplo_mcp_v1_mcp_connector_proto_rawDesc = \"\" +\n+\t\"\\n\" +\n+\t\" duplo/mcp/v1/mcp_connector.proto\\x12\\fduplo.mcp.v1\\x1a\\x1cgoogle/protobuf/struct.proto\\\"\\xf3\\x04\\n\" +\n+\t\"\\vSendRequest\\x12K\\n\" +\n+\t\"\\x0ecreate_session\\x18\\n\" +\n+\t\" \\x01(\\v2\\\".duplo.mcp.v1.CreateSessionRequestH\\x00R\\rcreateSession\\x12?\\n\" +\n+\t\"\\n\" +\n+\t\"list_tools\\x18\\v \\x01(\\v2\\x1e.duplo.mcp.v1.ListToolsRequestH\\x00R\\tlistTools\\x12H\\n\" +\n+\t\"\\rclose_session\\x18\\f \\x01(\\v2!.duplo.mcp.v1.CloseSessionRequestH\\x00R\\fcloseSession\\x12T\\n\" +\n+\t\"\\x11send_notification\\x18\\r \\x01(\\v2%.duplo.mcp.v1.SendNotificationRequestH\\x00R\\x10sendNotification\\x12H\\n\" +\n+\t\"\\rquery_session\\x18\\x0e \\x01(\\v2!.duplo.mcp.v1.QuerySessionRequestH\\x00R\\fquerySession\\x12K\\n\" +\n+\t\"\\x0edelete_session\\x18\\x0f \\x01(\\v2\\\".duplo.mcp.v1.DeleteSessionRequestH\\x00R\\rdeleteSession\\x12R\\n\" +\n+\t\"\\x11verify_access_key\\x18\\x10 \\x01(\\v2$.duplo.mcp.v1.VerifyAccessKeyRequestH\\x00R\\x0fverifyAccessKey\\x12@\\n\" +\n+\t\"\\tcall_tool\\x18\\x11 \\x01(\\v2!.duplo.mcp.v1.CallToolSendRequestH\\x00R\\bcallToolB\\t\\n\" +\n+\t\"\\apayload\\\"\\xab\\x05\\n\" +\n+\t\"\\fSendResponse\\x123\\n\" +\n+\t\"\\x05error\\x18\\n\" +\n+\t\" \\x01(\\v2\\x1b.duplo.mcp.v1.ErrorResponseH\\x00R\\x05error\\x12L\\n\" +\n+\t\"\\x0ecreate_session\\x18\\v \\x01(\\v2#.duplo.mcp.v1.CreateSessionResponseH\\x00R\\rcreateSession\\x12@\\n\" +\n+\t\"\\n\" +\n+\t\"list_tools\\x18\\f \\x01(\\v2\\x1f.duplo.mcp.v1.ListToolsResponseH\\x00R\\tlistTools\\x12I\\n\" +\n+\t\"\\rclose_session\\x18\\r \\x01(\\v2\\\".duplo.mcp.v1.CloseSessionResponseH\\x00R\\fcloseSession\\x12U\\n\" +\n+\t\"\\x11send_notification\\x18\\x0e \\x01(\\v2&.duplo.mcp.v1.SendNotificationResponseH\\x00R\\x10sendNotification\\x12I\\n\" +\n+\t\"\\rquery_session\\x18\\x0f \\x01(\\v2\\\".duplo.mcp.v1.QuerySessionResponseH\\x00R\\fquerySession\\x12L\\n\" +\n+\t\"\\x0edelete_session\\x18\\x10 \\x01(\\v2#.duplo.mcp.v1.DeleteSessionResponseH\\x00R\\rdeleteSession\\x12S\\n\" +\n+\t\"\\x11verify_access_key\\x18\\x11 \\x01(\\v2%.duplo.mcp.v1.VerifyAccessKeyResponseH\\x00R\\x0fverifyAccessKey\\x12;\\n\" +\n+\t\"\\tcall_tool\\x18\\x12 \\x01(\\v2\\x1c.duplo.mcp.v1.CallToolResultH\\x00R\\bcallToolB\\t\\n\" +\n+\t\"\\apayload\\\"m\\n\" +\n+\t\"\\x13CallToolSendRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tR\\tsessionId\\x127\\n\" +\n+\t\"\\apayload\\x18\\x02 \\x01(\\v2\\x1d.duplo.mcp.v1.CallToolPayloadR\\apayload\\\"\\xf3\\x02\\n\" +\n+\t\"\\x14CreateSessionRequest\\x12\\x19\\n\" +\n+\t\"\\bbase_url\\x18\\x01 \\x01(\\tR\\abaseUrl\\x12<\\n\" +\n+\t\"\\fauth_context\\x18\\x02 \\x01(\\v2\\x19.duplo.mcp.v1.AuthContextR\\vauthContext\\x129\\n\" +\n+\t\"\\vclient_info\\x18\\x03 \\x01(\\v2\\x18.duplo.mcp.v1.ClientInfoR\\n\" +\n+\t\"clientInfo\\x12)\\n\" +\n+\t\"\\x10protocol_version\\x18\\x04 \\x01(\\tR\\x0fprotocolVersion\\x128\\n\" +\n+\t\"\\x18client_capabilities_json\\x18\\x05 \\x01(\\tR\\x16clientCapabilitiesJson\\x12C\\n\" +\n+\t\"\\x0fmcp_client_info\\x18\\x06 \\x01(\\v2\\x1b.duplo.mcp.v1.McpClientInfoR\\rmcpClientInfo\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\a \\x01(\\tR\\tsessionId\\\"\\xbd\\x02\\n\" +\n+\t\"\\x15CreateSessionResponse\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tR\\tsessionId\\x12Q\\n\" +\n+\t\"\\x13server_capabilities\\x18\\x02 \\x01(\\v2 .duplo.mcp.v1.ServerCapabilitiesR\\x12serverCapabilities\\x129\\n\" +\n+\t\"\\vserver_info\\x18\\x03 \\x01(\\v2\\x18.duplo.mcp.v1.ServerInfoR\\n\" +\n+\t\"serverInfo\\x12)\\n\" +\n+\t\"\\x10protocol_version\\x18\\x04 \\x01(\\tR\\x0fprotocolVersion\\x12(\\n\" +\n+\t\"\\x05tools\\x18\\x05 \\x03(\\v2\\x12.duplo.mcp.v1.ToolR\\x05tools\\x12\\\"\\n\" +\n+\t\"\\finstructions\\x18\\x06 \\x01(\\tR\\finstructions\\\"I\\n\" +\n+\t\"\\x10ListToolsRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tR\\tsessionId\\x12\\x16\\n\" +\n+\t\"\\x06cursor\\x18\\x02 \\x01(\\tR\\x06cursor\\\"^\\n\" +\n+\t\"\\x11ListToolsResponse\\x12(\\n\" +\n+\t\"\\x05tools\\x18\\x01 \\x03(\\v2\\x12.duplo.mcp.v1.ToolR\\x05tools\\x12\\x1f\\n\" +\n+\t\"\\vnext_cursor\\x18\\x02 \\x01(\\tR\\n\" +\n+\t\"nextCursor\\\"4\\n\" +\n+\t\"\\x13CloseSessionRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tR\\tsessionId\\\"\\x16\\n\" +\n+\t\"\\x14CloseSessionResponse\\\"q\\n\" +\n+\t\"\\x17SendNotificationRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tR\\tsessionId\\x12\\x16\\n\" +\n+\t\"\\x06method\\x18\\x02 \\x01(\\tR\\x06method\\x12\\x1f\\n\" +\n+\t\"\\vparams_json\\x18\\x03 \\x01(\\tR\\n\" +\n+\t\"paramsJson\\\"\\x1a\\n\" +\n+\t\"\\x18SendNotificationResponse\\\"4\\n\" +\n+\t\"\\x13QuerySessionRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tR\\tsessionId\\\"T\\n\" +\n+\t\"\\x14QuerySessionResponse\\x12<\\n\" +\n+\t\"\\texistence\\x18\\x01 \\x01(\\x0e2\\x1e.duplo.mcp.v1.SessionExistenceR\\texistence\\\"w\\n\" +\n+\t\"\\x14DeleteSessionRequest\\x12\\x1f\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x01 \\x01(\\tH\\x00R\\tsessionId\\x124\\n\" +\n+\t\"\\x15agent_installation_id\\x18\\x02 \\x01(\\tH\\x00R\\x13agentInstallationIdB\\b\\n\" +\n+\t\"\\x06target\\\"<\\n\" +\n+\t\"\\x15DeleteSessionResponse\\x12#\\n\" +\n+\t\"\\rdeleted_count\\x18\\x01 \\x01(\\x05R\\fdeletedCount\\\"T\\n\" +\n+\t\"\\x16VerifyAccessKeyRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"access_key\\x18\\x01 \\x01(\\tR\\taccessKey\\x12\\x1b\\n\" +\n+\t\"\\tpreset_id\\x18\\x02 \\x01(\\tR\\bpresetId\\\"e\\n\" +\n+\t\"\\x17VerifyAccessKeyResponse\\x12\\x14\\n\" +\n+\t\"\\x05valid\\x18\\x01 \\x01(\\bR\\x05valid\\x12\\x17\\n\" +\n+\t\"\\auser_id\\x18\\x02 \\x01(\\tR\\x06userId\\x12\\x1b\\n\" +\n+\t\"\\tdevice_id\\x18\\x03 \\x01(\\tR\\bdeviceId\\\"`\\n\" +\n+\t\"\\rErrorResponse\\x12\\x12\\n\" +\n+\t\"\\x04code\\x18\\x01 \\x01(\\x05R\\x04code\\x12\\x18\\n\" +\n+\t\"\\amessage\\x18\\x02 \\x01(\\tR\\amessage\\x12!\\n\" +\n+\t\"\\fdetails_json\\x18\\x03 \\x01(\\tR\\vdetailsJson\\\"\\xa9\\x03\\n\" +\n+\t\"\\x0eChannelRequest\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x02 \\x01(\\tR\\tsessionId\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"request_id\\x18\\x03 \\x01(\\tR\\trequestId\\x123\\n\" +\n+\t\"\\x05error\\x18\\n\" +\n+\t\" \\x01(\\v2\\x1b.duplo.mcp.v1.ErrorResponseH\\x00R\\x05error\\x12<\\n\" +\n+\t\"\\tcall_tool\\x18\\v \\x01(\\v2\\x1d.duplo.mcp.v1.CallToolPayloadH\\x00R\\bcallTool\\x12Q\\n\" +\n+\t\"\\x10subscribe_events\\x18\\f \\x01(\\v2$.duplo.mcp.v1.SubscribeEventsPayloadH\\x00R\\x0fsubscribeEvents\\x12W\\n\" +\n+\t\"\\x12unsubscribe_events\\x18\\r \\x01(\\v2&.duplo.mcp.v1.UnsubscribeEventsPayloadH\\x00R\\x11unsubscribeEvents\\x12/\\n\" +\n+\t\"\\x04ping\\x18\\x0e \\x01(\\v2\\x19.duplo.mcp.v1.PingPayloadH\\x00R\\x04pingB\\t\\n\" +\n+\t\"\\apayload\\\"\\xec\\x03\\n\" +\n+\t\"\\x0fChannelResponse\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"session_id\\x18\\x02 \\x01(\\tR\\tsessionId\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"request_id\\x18\\x03 \\x01(\\tR\\trequestId\\x123\\n\" +\n+\t\"\\x05error\\x18\\n\" +\n+\t\" \\x01(\\v2\\x1b.duplo.mcp.v1.ErrorResponseH\\x00R\\x05error\\x12@\\n\" +\n+\t\"\\bprogress\\x18\\v \\x01(\\v2\\\".duplo.mcp.v1.ProgressNotificationH\\x00R\\bprogress\\x12H\\n\" +\n+\t\"\\x10call_tool_result\\x18\\f \\x01(\\v2\\x1c.duplo.mcp.v1.CallToolResultH\\x00R\\x0ecallToolResult\\x12P\\n\" +\n+\t\"\\x11tool_list_changed\\x18\\r \\x01(\\v2\\\".duplo.mcp.v1.ToolListChangedEventH\\x00R\\x0ftoolListChanged\\x12L\\n\" +\n+\t\"\\x0flogging_message\\x18\\x0e \\x01(\\v2!.duplo.mcp.v1.LoggingMessageEventH\\x00R\\x0eloggingMessage\\x12/\\n\" +\n+\t\"\\x04pong\\x18\\x0f \\x01(\\v2\\x19.duplo.mcp.v1.PongPayloadH\\x00R\\x04pongB\\t\\n\" +\n+\t\"\\apayload\\\"y\\n\" +\n+\t\"\\x0fCallToolPayload\\x12\\x12\\n\" +\n+\t\"\\x04name\\x18\\x01 \\x01(\\tR\\x04name\\x12%\\n\" +\n+\t\"\\x0earguments_json\\x18\\x02 \\x01(\\tR\\rargumentsJson\\x12+\\n\" +\n+\t\"\\x04meta\\x18\\x03 \\x01(\\v2\\x17.google.protobuf.StructR\\x04meta\\\"\\x89\\x01\\n\" +\n+\t\"\\x0eCallToolResult\\x12/\\n\" +\n+\t\"\\acontent\\x18\\x01 \\x03(\\v2\\x15.duplo.mcp.v1.ContentR\\acontent\\x12\\x19\\n\" +\n+\t\"\\bis_error\\x18\\x02 \\x01(\\bR\\aisError\\x12+\\n\" +\n+\t\"\\x04meta\\x18\\x03 \\x01(\\v2\\x17.google.protobuf.StructR\\x04meta\\\"\\x18\\n\" +\n+\t\"\\x16SubscribeEventsPayload\\\"\\x1a\\n\" +\n+\t\"\\x18UnsubscribeEventsPayload\\\"\\r\\n\" +\n+\t\"\\vPingPayload\\\"\\r\\n\" +\n+\t\"\\vPongPayload\\\"\\xaa\\x01\\n\" +\n+\t\"\\x14ProgressNotification\\x12%\\n\" +\n+\t\"\\x0eprogress_token\\x18\\x01 \\x01(\\tR\\rprogressToken\\x12\\x1f\\n\" +\n+\t\"\\bprogress\\x18\\x02 \\x01(\\x01H\\x00R\\bprogress\\x88\\x01\\x01\\x12\\x19\\n\" +\n+\t\"\\x05total\\x18\\x03 \\x01(\\x01H\\x01R\\x05total\\x88\\x01\\x01\\x12\\x18\\n\" +\n+\t\"\\amessage\\x18\\x04 \\x01(\\tR\\amessageB\\v\\n\" +\n+\t\"\\t_progressB\\b\\n\" +\n+\t\"\\x06_total\\\"\\x16\\n\" +\n+\t\"\\x14ToolListChangedEvent\\\"`\\n\" +\n+\t\"\\x13LoggingMessageEvent\\x12\\x14\\n\" +\n+\t\"\\x05level\\x18\\x01 \\x01(\\tR\\x05level\\x12\\x16\\n\" +\n+\t\"\\x06logger\\x18\\x02 \\x01(\\tR\\x06logger\\x12\\x1b\\n\" +\n+\t\"\\tdata_json\\x18\\x03 \\x01(\\tR\\bdataJson\\\"\\xe3\\x01\\n\" +\n+\t\"\\vAuthContext\\x12\\x17\\n\" +\n+\t\"\\auser_id\\x18\\x01 \\x01(\\tR\\x06userId\\x129\\n\" +\n+\t\"\\vauth_method\\x18\\x02 \\x01(\\x0e2\\x18.duplo.mcp.v1.AuthMethodR\\n\" +\n+\t\"authMethod\\x12C\\n\" +\n+\t\"\\bmetadata\\x18\\x03 \\x03(\\v2'.duplo.mcp.v1.AuthContext.MetadataEntryR\\bmetadata\\x1a;\\n\" +\n+\t\"\\rMetadataEntry\\x12\\x10\\n\" +\n+\t\"\\x03key\\x18\\x01 \\x01(\\tR\\x03key\\x12\\x14\\n\" +\n+\t\"\\x05value\\x18\\x02 \\x01(\\tR\\x05value:\\x028\\x01\\\"d\\n\" +\n+\t\"\\n\" +\n+\t\"ClientInfo\\x12\\x0e\\n\" +\n+\t\"\\x02ip\\x18\\x01 \\x01(\\tR\\x02ip\\x12\\x1d\\n\" +\n+\t\"\\n\" +\n+\t\"user_agent\\x18\\x02 \\x01(\\tR\\tuserAgent\\x12'\\n\" +\n+\t\"\\x0fconversation_id\\x18\\x03 \\x01(\\tR\\x0econversationId\\\"=\\n\" +\n+\t\"\\rMcpClientInfo\\x12\\x12\\n\" +\n+\t\"\\x04name\\x18\\x01 \\x01(\\tR\\x04name\\x12\\x18\\n\" +\n+\t\"\\aversion\\x18\\x02 \\x01(\\tR\\aversion\\\"\\x84\\x01\\n\" +\n+\t\"\\x12ServerCapabilities\\x123\\n\" +\n+\t\"\\x05tools\\x18\\x01 \\x01(\\v2\\x1d.duplo.mcp.v1.ToolsCapabilityR\\x05tools\\x129\\n\" +\n+\t\"\\alogging\\x18\\x02 \\x01(\\v2\\x1f.duplo.mcp.v1.LoggingCapabilityR\\alogging\\\"4\\n\" +\n+\t\"\\x0fToolsCapability\\x12!\\n\" +\n+\t\"\\flist_changed\\x18\\x01 \\x01(\\bR\\vlistChanged\\\"\\x13\\n\" +\n+\t\"\\x11LoggingCapability\\\":\\n\" +\n+\t\"\\n\" +\n+\t\"ServerInfo\\x12\\x12\\n\" +\n+\t\"\\x04name\\x18\\x01 \\x01(\\tR\\x04name\\x12\\x18\\n\" +\n+\t\"\\aversion\\x18\\x02 \\x01(\\tR\\aversion\\\"\\x94\\x03\\n\" +\n+\t\"\\x04Tool\\x12\\x12\\n\" +\n+\t\"\\x04name\\x18\\x01 \\x01(\\tR\\x04name\\x12 \\n\" +\n+\t\"\\vdescription\\x18\\x02 \\x01(\\tR\\vdescription\\x12*\\n\" +\n+\t\"\\x11input_schema_json\\x18\\x03 \\x01(\\tR\\x0finputSchemaJson\\x123\\n\" +\n+\t\"\\x15displayed_description\\x18\\x04 \\x01(\\tR\\x14displayedDescription\\x12%\\n\" +\n+\t\"\\x0eintegration_id\\x18\\x05 \\x01(\\tR\\rintegrationId\\x12)\\n\" +\n+\t\"\\x10integration_name\\x18\\x06 \\x01(\\tR\\x0fintegrationName\\x128\\n\" +\n+\t\"\\x18installed_integration_id\\x18\\a \\x01(\\tR\\x16installedIntegrationId\\x12<\\n\" +\n+\t\"\\x1ainstalled_integration_name\\x18\\b \\x01(\\tR\\x18installedIntegrationName\\x12+\\n\" +\n+\t\"\\x04meta\\x18\\t \\x01(\\v2\\x17.google.protobuf.StructR\\x04meta\\\"y\\n\" +\n+\t\"\\aContent\\x12/\\n\" +\n+\t\"\\x04text\\x18\\x01 \\x01(\\v2\\x19.duplo.mcp.v1.TextContentH\\x00R\\x04text\\x122\\n\" +\n+\t\"\\x05image\\x18\\x02 \\x01(\\v2\\x1a.duplo.mcp.v1.ImageContentH\\x00R\\x05imageB\\t\\n\" +\n+\t\"\\acontent\\\"!\\n\" +\n+\t\"\\vTextContent\\x12\\x12\\n\" +\n+\t\"\\x04text\\x18\\x01 \\x01(\\tR\\x04text\\\"?\\n\" +\n+\t\"\\fImageContent\\x12\\x12\\n\" +\n+\t\"\\x04data\\x18\\x01 \\x01(\\tR\\x04data\\x12\\x1b\\n\" +\n+\t\"\\tmime_type\\x18\\x02 \\x01(\\tR\\bmimeType*u\\n\" +\n+\t\"\\x10SessionExistence\\x12!\\n\" +\n+\t\"\\x1dSESSION_EXISTENCE_UNSPECIFIED\\x10\\x00\\x12\\x1c\\n\" +\n+\t\"\\x18SESSION_EXISTENCE_EXISTS\\x10\\x01\\x12 \\n\" +\n+\t\"\\x1cSESSION_EXISTENCE_NOT_EXISTS\\x10\\x02*`\\n\" +\n+\t\"\\n\" +\n+\t\"AuthMethod\\x12\\x1b\\n\" +\n+\t\"\\x17AUTH_METHOD_UNSPECIFIED\\x10\\x00\\x12\\x15\\n\" +\n+\t\"\\x11AUTH_METHOD_OAUTH\\x10\\x01\\x12\\x1e\\n\" +\n+\t\"\\x1aAUTH_METHOD_HTTP_SIGNATURE\\x10\\x022\\xa0\\x01\\n\" +\n+\t\"\\x13McpConnectorService\\x12=\\n\" +\n+\t\"\\x04Send\\x12\\x19.duplo.mcp.v1.SendRequest\\x1a\\x1a.duplo.mcp.v1.SendResponse\\x12J\\n\" +\n+\t\"\\aChannel\\x12\\x1c.duplo.mcp.v1.ChannelRequest\\x1a\\x1d.duplo.mcp.v1.ChannelResponse(\\x010\\x01B4\\n\" +\n+\t\"\\x18io.querypie.duplo.mcp.v1P\\x01Z\\x16gen/duplo/mcp/v1;mcpv1b\\x06proto3\"\n+\n+var (\n+\tfile_duplo_mcp_v1_mcp_connector_proto_rawDescOnce sync.Once\n+\tfile_duplo_mcp_v1_mcp_connector_proto_rawDescData []byte\n+)\n+\n+func file_duplo_mcp_v1_mcp_connector_proto_rawDescGZIP() []byte {\n+\tfile_duplo_mcp_v1_mcp_connector_proto_rawDescOnce.Do(func() {\n+\t\tfile_duplo_mcp_v1_mcp_connector_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_duplo_mcp_v1_mcp_connector_proto_rawDesc), len(file_duplo_mcp_v1_mcp_connector_proto_rawDesc)))\n+\t})\n+\treturn file_duplo_mcp_v1_mcp_connector_proto_rawDescData\n+}\n+\n+var file_duplo_mcp_v1_mcp_connector_proto_enumTypes = make([]protoimpl.EnumInfo, 2)\n+var file_duplo_mcp_v1_mcp_connector_proto_msgTypes = make([]protoimpl.MessageInfo, 41)\n+var file_duplo_mcp_v1_mcp_connector_proto_goTypes = []any{\n+\t(SessionExistence)(0),            // 0: duplo.mcp.v1.SessionExistence\n+\t(AuthMethod)(0),                  // 1: duplo.mcp.v1.AuthMethod\n+\t(*SendRequest)(nil),              // 2: duplo.mcp.v1.SendRequest\n+\t(*SendResponse)(nil),             // 3: duplo.mcp.v1.SendResponse\n+\t(*CallToolSendRequest)(nil),      // 4: duplo.mcp.v1.CallToolSendRequest\n+\t(*CreateSessionRequest)(nil),     // 5: duplo.mcp.v1.CreateSessionRequest\n+\t(*CreateSessionResponse)(nil),    // 6: duplo.mcp.v1.CreateSessionResponse\n+\t(*ListToolsRequest)(nil),         // 7: duplo.mcp.v1.ListToolsRequest\n+\t(*ListToolsResponse)(nil),        // 8: duplo.mcp.v1.ListToolsResponse\n+\t(*CloseSessionRequest)(nil),      // 9: duplo.mcp.v1.CloseSessionRequest\n+\t(*CloseSessionResponse)(nil),     // 10: duplo.mcp.v1.CloseSessionResponse\n+\t(*SendNotificationRequest)(nil),  // 11: duplo.mcp.v1.SendNotificationRequest\n+\t(*SendNotificationResponse)(nil), // 12: duplo.mcp.v1.SendNotificationResponse\n+\t(*QuerySessionRequest)(nil),      // 13: duplo.mcp.v1.QuerySessionRequest\n+\t(*QuerySessionResponse)(nil),     // 14: duplo.mcp.v1.QuerySessionResponse\n+\t(*DeleteSessionRequest)(nil),     // 15: duplo.mcp.v1.DeleteSessionRequest\n+\t(*DeleteSessionResponse)(nil),    // 16: duplo.mcp.v1.DeleteSessionResponse\n+\t(*VerifyAccessKeyRequest)(nil),   // 17: duplo.mcp.v1.VerifyAccessKeyRequest\n+\t(*VerifyAccessKeyResponse)(nil),  // 18: duplo.mcp.v1.VerifyAccessKeyResponse\n+\t(*ErrorResponse)(nil),            // 19: duplo.mcp.v1.ErrorResponse\n+\t(*ChannelRequest)(nil),           // 20: duplo.mcp.v1.ChannelRequest\n+\t(*ChannelResponse)(nil),          // 21: duplo.mcp.v1.ChannelResponse\n+\t(*CallToolPayload)(nil),          // 22: duplo.mcp.v1.CallToolPayload\n+\t(*CallToolResult)(nil),           // 23: duplo.mcp.v1.CallToolResult\n+\t(*SubscribeEventsPayload)(nil),   // 24: duplo.mcp.v1.SubscribeEventsPayload\n+\t(*UnsubscribeEventsPayload)(nil), // 25: duplo.mcp.v1.UnsubscribeEventsPayload\n+\t(*PingPayload)(nil),              // 26: duplo.mcp.v1.PingPayload\n+\t(*PongPayload)(nil),              // 27: duplo.mcp.v1.PongPayload\n+\t(*ProgressNotification)(nil),     // 28: duplo.mcp.v1.ProgressNotification\n+\t(*ToolListChangedEvent)(nil),     // 29: duplo.mcp.v1.ToolListChangedEvent\n+\t(*LoggingMessageEvent)(nil),      // 30: duplo.mcp.v1.LoggingMessageEvent\n+\t(*AuthContext)(nil),              // 31: duplo.mcp.v1.AuthContext\n+\t(*ClientInfo)(nil),               // 32: duplo.mcp.v1.ClientInfo\n+\t(*McpClientInfo)(nil),            // 33: duplo.mcp.v1.McpClientInfo\n+\t(*ServerCapabilities)(nil),       // 34: duplo.mcp.v1.ServerCapabilities\n+\t(*ToolsCapability)(nil),          // 35: duplo.mcp.v1.ToolsCapability\n+\t(*LoggingCapability)(nil),        // 36: duplo.mcp.v1.LoggingCapability\n+\t(*ServerInfo)(nil),               // 37: duplo.mcp.v1.ServerInfo\n+\t(*Tool)(nil),                     // 38: duplo.mcp.v1.Tool\n+\t(*Content)(nil),                  // 39: duplo.mcp.v1.Content\n+\t(*TextContent)(nil),              // 40: duplo.mcp.v1.TextContent\n+\t(*ImageContent)(nil),             // 41: duplo.mcp.v1.ImageContent\n+\tnil,                              // 42: duplo.mcp.v1.AuthContext.MetadataEntry\n+\t(*structpb.Struct)(nil),          // 43: google.protobuf.Struct\n+}\n+var file_duplo_mcp_v1_mcp_connector_proto_depIdxs = []int32{\n+\t5,  // 0: duplo.mcp.v1.SendRequest.create_session:type_name -> duplo.mcp.v1.CreateSessionRequest\n+\t7,  // 1: duplo.mcp.v1.SendRequest.list_tools:type_name -> duplo.mcp.v1.ListToolsRequest\n+\t9,  // 2: duplo.mcp.v1.SendRequest.close_session:type_name -> duplo.mcp.v1.CloseSessionRequest\n+\t11, // 3: duplo.mcp.v1.SendRequest.send_notification:type_name -> duplo.mcp.v1.SendNotificationRequest\n+\t13, // 4: duplo.mcp.v1.SendRequest.query_session:type_name -> duplo.mcp.v1.QuerySessionRequest\n+\t15, // 5: duplo.mcp.v1.SendRequest.delete_session:type_name -> duplo.mcp.v1.DeleteSessionRequest\n+\t17, // 6: duplo.mcp.v1.SendRequest.verify_access_key:type_name -> duplo.mcp.v1.VerifyAccessKeyRequest\n+\t4,  // 7: duplo.mcp.v1.SendRequest.call_tool:type_name -> duplo.mcp.v1.CallToolSendRequest\n+\t19, // 8: duplo.mcp.v1.SendResponse.error:type_name -> duplo.mcp.v1.ErrorResponse\n+\t6,  // 9: duplo.mcp.v1.SendResponse.create_session:type_name -> duplo.mcp.v1.CreateSessionResponse\n+\t8,  // 10: duplo.mcp.v1.SendResponse.list_tools:type_name -> duplo.mcp.v1.ListToolsResponse\n+\t10, // 11: duplo.mcp.v1.SendResponse.close_session:type_name -> duplo.mcp.v1.CloseSessionResponse\n+\t12, // 12: duplo.mcp.v1.SendResponse.send_notification:type_name -> duplo.mcp.v1.SendNotificationResponse\n+\t14, // 13: duplo.mcp.v1.SendResponse.query_session:type_name -> duplo.mcp.v1.QuerySessionResponse\n+\t16, // 14: duplo.mcp.v1.SendResponse.delete_session:type_name -> duplo.mcp.v1.DeleteSessionResponse\n+\t18, // 15: duplo.mcp.v1.SendResponse.verify_access_key:type_name -> duplo.mcp.v1.VerifyAccessKeyResponse\n+\t23, // 16: duplo.mcp.v1.SendResponse.call_tool:type_name -> duplo.mcp.v1.CallToolResult\n+\t22, // 17: duplo.mcp.v1.CallToolSendRequest.payload:type_name -> duplo.mcp.v1.CallToolPayload\n+\t31, // 18: duplo.mcp.v1.CreateSessionRequest.auth_context:type_name -> duplo.mcp.v1.AuthContext\n+\t32, // 19: duplo.mcp.v1.CreateSessionRequest.client_info:type_name -> duplo.mcp.v1.ClientInfo\n+\t33, // 20: duplo.mcp.v1.CreateSessionRequest.mcp_client_info:type_name -> duplo.mcp.v1.McpClientInfo\n+\t34, // 21: duplo.mcp.v1.CreateSessionResponse.server_capabilities:type_name -> duplo.mcp.v1.ServerCapabilities\n+\t37, // 22: duplo.mcp.v1.CreateSessionResponse.server_info:type_name -> duplo.mcp.v1.ServerInfo\n+\t38, // 23: duplo.mcp.v1.CreateSessionResponse.tools:type_name -> duplo.mcp.v1.Tool\n+\t38, // 24: duplo.mcp.v1.ListToolsResponse.tools:type_name -> duplo.mcp.v1.Tool\n+\t0,  // 25: duplo.mcp.v1.QuerySessionResponse.existence:type_name -> duplo.mcp.v1.SessionExistence\n+\t19, // 26: duplo.mcp.v1.ChannelRequest.error:type_name -> duplo.mcp.v1.ErrorResponse\n+\t22, // 27: duplo.mcp.v1.ChannelRequest.call_tool:type_name -> duplo.mcp.v1.CallToolPayload\n+\t24, // 28: duplo.mcp.v1.ChannelRequest.subscribe_events:type_name -> duplo.mcp.v1.SubscribeEventsPayload\n+\t25, // 29: duplo.mcp.v1.ChannelRequest.unsubscribe_events:type_name -> duplo.mcp.v1.UnsubscribeEventsPayload\n+\t26, // 30: duplo.mcp.v1.ChannelRequest.ping:type_name -> duplo.mcp.v1.PingPayload\n+\t19, // 31: duplo.mcp.v1.ChannelResponse.error:type_name -> duplo.mcp.v1.ErrorResponse\n+\t28, // 32: duplo.mcp.v1.ChannelResponse.progress:type_name -> duplo.mcp.v1.ProgressNotification\n+\t23, // 33: duplo.mcp.v1.ChannelResponse.call_tool_result:type_name -> duplo.mcp.v1.CallToolResult\n+\t29, // 34: duplo.mcp.v1.ChannelResponse.tool_list_changed:type_name -> duplo.mcp.v1.ToolListChangedEvent\n+\t30, // 35: duplo.mcp.v1.ChannelResponse.logging_message:type_name -> duplo.mcp.v1.LoggingMessageEvent\n+\t27, // 36: duplo.mcp.v1.ChannelResponse.pong:type_name -> duplo.mcp.v1.PongPayload\n+\t43, // 37: duplo.mcp.v1.CallToolPayload.meta:type_name -> google.protobuf.Struct\n+\t39, // 38: duplo.mcp.v1.CallToolResult.content:type_name -> duplo.mcp.v1.Content\n+\t43, // 39: duplo.mcp.v1.CallToolResult.meta:type_name -> google.protobuf.Struct\n+\t1,  // 40: duplo.mcp.v1.AuthContext.auth_method:type_name -> duplo.mcp.v1.AuthMethod\n+\t42, // 41: duplo.mcp.v1.AuthContext.metadata:type_name -> duplo.mcp.v1.AuthContext.MetadataEntry\n+\t35, // 42: duplo.mcp.v1.ServerCapabilities.tools:type_name -> duplo.mcp.v1.ToolsCapability\n+\t36, // 43: duplo.mcp.v1.ServerCapabilities.logging:type_name -> duplo.mcp.v1.LoggingCapability\n+\t43, // 44: duplo.mcp.v1.Tool.meta:type_name -> google.protobuf.Struct\n+\t40, // 45: duplo.mcp.v1.Content.text:type_name -> duplo.mcp.v1.TextContent\n+\t41, // 46: duplo.mcp.v1.Content.image:type_name -> duplo.mcp.v1.ImageContent\n+\t2,  // 47: duplo.mcp.v1.McpConnectorService.Send:input_type -> duplo.mcp.v1.SendRequest\n+\t20, // 48: duplo.mcp.v1.McpConnectorService.Channel:input_type -> duplo.mcp.v1.ChannelRequest\n+\t3,  // 49: duplo.mcp.v1.McpConnectorService.Send:output_type -> duplo.mcp.v1.SendResponse\n+\t21, // 50: duplo.mcp.v1.McpConnectorService.Channel:output_type -> duplo.mcp.v1.ChannelResponse\n+\t49, // [49:51] is the sub-list for method output_type\n+\t47, // [47:49] is the sub-list for method input_type\n+\t47, // [47:47] is the sub-list for extension type_name\n+\t47, // [47:47] is the sub-list for extension extendee\n+\t0,  // [0:47] is the sub-list for field type_name\n+}\n+\n+func init() { file_duplo_mcp_v1_mcp_connector_proto_init() }\n+func file_duplo_mcp_v1_mcp_connector_proto_init() {\n+\tif File_duplo_mcp_v1_mcp_connector_proto != nil {\n+\t\treturn\n+\t}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[0].OneofWrappers = []any{\n+\t\t(*SendRequest_CreateSession)(nil),\n+\t\t(*SendRequest_ListTools)(nil),\n+\t\t(*SendRequest_CloseSession)(nil),\n+\t\t(*SendRequest_SendNotification)(nil),\n+\t\t(*SendRequest_QuerySession)(nil),\n+\t\t(*SendRequest_DeleteSession)(nil),\n+\t\t(*SendRequest_VerifyAccessKey)(nil),\n+\t\t(*SendRequest_CallTool)(nil),\n+\t}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[1].OneofWrappers = []any{\n+\t\t(*SendResponse_Error)(nil),\n+\t\t(*SendResponse_CreateSession)(nil),\n+\t\t(*SendResponse_ListTools)(nil),\n+\t\t(*SendResponse_CloseSession)(nil),\n+\t\t(*SendResponse_SendNotification)(nil),\n+\t\t(*SendResponse_QuerySession)(nil),\n+\t\t(*SendResponse_DeleteSession)(nil),\n+\t\t(*SendResponse_VerifyAccessKey)(nil),\n+\t\t(*SendResponse_CallTool)(nil),\n+\t}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[13].OneofWrappers = []any{\n+\t\t(*DeleteSessionRequest_SessionId)(nil),\n+\t\t(*DeleteSessionRequest_AgentInstallationId)(nil),\n+\t}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[18].OneofWrappers = []any{\n+\t\t(*ChannelRequest_Error)(nil),\n+\t\t(*ChannelRequest_CallTool)(nil),\n+\t\t(*ChannelRequest_SubscribeEvents)(nil),\n+\t\t(*ChannelRequest_UnsubscribeEvents)(nil),\n+\t\t(*ChannelRequest_Ping)(nil),\n+\t}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[19].OneofWrappers = []any{\n+\t\t(*ChannelResponse_Error)(nil),\n+\t\t(*ChannelResponse_Progress)(nil),\n+\t\t(*ChannelResponse_CallToolResult)(nil),\n+\t\t(*ChannelResponse_ToolListChanged)(nil),\n+\t\t(*ChannelResponse_LoggingMessage)(nil),\n+\t\t(*ChannelResponse_Pong)(nil),\n+\t}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[26].OneofWrappers = []any{}\n+\tfile_duplo_mcp_v1_mcp_connector_proto_msgTypes[37].OneofWrappers = []any{\n+\t\t(*Content_Text)(nil),\n+\t\t(*Content_Image)(nil),\n+\t}\n+\ttype x struct{}\n+\tout := protoimpl.TypeBuilder{\n+\t\tFile: protoimpl.DescBuilder{\n+\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n+\t\t\tRawDescriptor: unsafe.Slice(unsafe.StringData(file_duplo_mcp_v1_mcp_connector_proto_rawDesc), len(file_duplo_mcp_v1_mcp_connector_proto_rawDesc)),\n+\t\t\tNumEnums:      2,\n+\t\t\tNumMessages:   41,\n+\t\t\tNumExtensions: 0,\n+\t\t\tNumServices:   1,\n+\t\t},\n+\t\tGoTypes:           file_duplo_mcp_v1_mcp_connector_proto_goTypes,\n+\t\tDependencyIndexes: file_duplo_mcp_v1_mcp_connector_proto_depIdxs,\n+\t\tEnumInfos:         file_duplo_mcp_v1_mcp_connector_proto_enumTypes,\n+\t\tMessageInfos:      file_duplo_mcp_v1_mcp_connector_proto_msgTypes,\n+\t}.Build()\n+\tFile_duplo_mcp_v1_mcp_connector_proto = out.File\n+\tfile_duplo_mcp_v1_mcp_connector_proto_goTypes = nil\n+\tfile_duplo_mcp_v1_mcp_connector_proto_depIdxs = nil\n+}\ndiff --git a/mcp-proxy/gen/duplo/mcp/v1/mcp_connector_grpc.pb.go b/mcp-proxy/gen/duplo/mcp/v1/mcp_connector_grpc.pb.go\nnew file mode 100644\nindex 000000000..829fef3ea\n--- /dev/null\n+++ b/mcp-proxy/gen/duplo/mcp/v1/mcp_connector_grpc.pb.go\n@@ -0,0 +1,168 @@\n+// MCP Connector gRPC Service\n+//\n+// Go Proxy ↔ Kotlin Backend 간 gRPC 인터페이스 정의\n+// Go Proxy가 클라이언트 연결·인증·세션 관리를 담당하고,\n+// Kotlin Backend가 커넥터·비즈니스 로직을 담당한다\n+\n+// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n+// versions:\n+// - protoc-gen-go-grpc v1.6.1\n+// - protoc             v6.33.4\n+// source: duplo/mcp/v1/mcp_connector.proto\n+\n+package mcpv1\n+\n+import (\n+\tcontext \"context\"\n+\tgrpc \"google.golang.org/grpc\"\n+\tcodes \"google.golang.org/grpc/codes\"\n+\tstatus \"google.golang.org/grpc/status\"\n+)\n+\n+// This is a compile-time assertion to ensure that this generated file\n+// is compatible with the grpc package it is being compiled against.\n+// Requires gRPC-Go v1.64.0 or later.\n+const _ = grpc.SupportPackageIsVersion9\n+\n+const (\n+\tMcpConnectorService_Send_FullMethodName    = \"/duplo.mcp.v1.McpConnectorService/Send\"\n+\tMcpConnectorService_Channel_FullMethodName = \"/duplo.mcp.v1.McpConnectorService/Channel\"\n+)\n+\n+// McpConnectorServiceClient is the client API for McpConnectorService service.\n+//\n+// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\n+//\n+// Go Proxy ↔ Kotlin Backend 간 MCP 커넥터 서비스\n+type McpConnectorServiceClient interface {\n+\t// 단일 요청-응답. oneof payload로 메시지를 구분한다\n+\tSend(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)\n+\t// 양방향 스트리밍. Go Proxy ↔ Backend 연결 단위(멀티플렉싱)\n+\t// 여러 세션의 메시지가 session_id로 구분되어 하나의 스트림에서 교환된다\n+\tChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChannelRequest, ChannelResponse], error)\n+}\n+\n+type mcpConnectorServiceClient struct {\n+\tcc grpc.ClientConnInterface\n+}\n+\n+func NewMcpConnectorServiceClient(cc grpc.ClientConnInterface) McpConnectorServiceClient {\n+\treturn &mcpConnectorServiceClient{cc}\n+}\n+\n+func (c *mcpConnectorServiceClient) Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {\n+\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n+\tout := new(SendResponse)\n+\terr := c.cc.Invoke(ctx, McpConnectorService_Send_FullMethodName, in, out, cOpts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n+func (c *mcpConnectorServiceClient) Channel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChannelRequest, ChannelResponse], error) {\n+\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n+\tstream, err := c.cc.NewStream(ctx, &McpConnectorService_ServiceDesc.Streams[0], McpConnectorService_Channel_FullMethodName, cOpts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tx := &grpc.GenericClientStream[ChannelRequest, ChannelResponse]{ClientStream: stream}\n+\treturn x, nil\n+}\n+\n+// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.\n+type McpConnectorService_ChannelClient = grpc.BidiStreamingClient[ChannelRequest, ChannelResponse]\n+\n+// McpConnectorServiceServer is the server API for McpConnectorService service.\n+// All implementations should embed UnimplementedMcpConnectorServiceServer\n+// for forward compatibility.\n+//\n+// Go Proxy ↔ Kotlin Backend 간 MCP 커넥터 서비스\n+type McpConnectorServiceServer interface {\n+\t// 단일 요청-응답. oneof payload로 메시지를 구분한다\n+\tSend(context.Context, *SendRequest) (*SendResponse, error)\n+\t// 양방향 스트리밍. Go Proxy ↔ Backend 연결 단위(멀티플렉싱)\n+\t// 여러 세션의 메시지가 session_id로 구분되어 하나의 스트림에서 교환된다\n+\tChannel(grpc.BidiStreamingServer[ChannelRequest, ChannelResponse]) error\n+}\n+\n+// UnimplementedMcpConnectorServiceServer should be embedded to have\n+// forward compatible implementations.\n+//\n+// NOTE: this should be embedded by value instead of pointer to avoid a nil\n+// pointer dereference when methods are called.\n+type UnimplementedMcpConnectorServiceServer struct{}\n+\n+func (UnimplementedMcpConnectorServiceServer) Send(context.Context, *SendRequest) (*SendResponse, error) {\n+\treturn nil, status.Error(codes.Unimplemented, \"method Send not implemented\")\n+}\n+func (UnimplementedMcpConnectorServiceServer) Channel(grpc.BidiStreamingServer[ChannelRequest, ChannelResponse]) error {\n+\treturn status.Error(codes.Unimplemented, \"method Channel not implemented\")\n+}\n+func (UnimplementedMcpConnectorServiceServer) testEmbeddedByValue() {}\n+\n+// UnsafeMcpConnectorServiceServer may be embedded to opt out of forward compatibility for this service.\n+// Use of this interface is not recommended, as added methods to McpConnectorServiceServer will\n+// result in compilation errors.\n+type UnsafeMcpConnectorServiceServer interface {\n+\tmustEmbedUnimplementedMcpConnectorServiceServer()\n+}\n+\n+func RegisterMcpConnectorServiceServer(s grpc.ServiceRegistrar, srv McpConnectorServiceServer) {\n+\t// If the following call panics, it indicates UnimplementedMcpConnectorServiceServer was\n+\t// embedded by pointer and is nil.  This will cause panics if an\n+\t// unimplemented method is ever invoked, so we test this at initialization\n+\t// time to prevent it from happening at runtime later due to I/O.\n+\tif t, ok := srv.(interface{ testEmbeddedByValue() }); ok {\n+\t\tt.testEmbeddedByValue()\n+\t}\n+\ts.RegisterService(&McpConnectorService_ServiceDesc, srv)\n+}\n+\n+func _McpConnectorService_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(SendRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(McpConnectorServiceServer).Send(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: McpConnectorService_Send_FullMethodName,\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(McpConnectorServiceServer).Send(ctx, req.(*SendRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n+func _McpConnectorService_Channel_Handler(srv interface{}, stream grpc.ServerStream) error {\n+\treturn srv.(McpConnectorServiceServer).Channel(&grpc.GenericServerStream[ChannelRequest, ChannelResponse]{ServerStream: stream})\n+}\n+\n+// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.\n+type McpConnectorService_ChannelServer = grpc.BidiStreamingServer[ChannelRequest, ChannelResponse]\n+\n+// McpConnectorService_ServiceDesc is the grpc.ServiceDesc for McpConnectorService service.\n+// It's only intended for direct use with grpc.RegisterService,\n+// and not to be introspected or modified (even as a copy)\n+var McpConnectorService_ServiceDesc = grpc.ServiceDesc{\n+\tServiceName: \"duplo.mcp.v1.McpConnectorService\",\n+\tHandlerType: (*McpConnectorServiceServer)(nil),\n+\tMethods: []grpc.MethodDesc{\n+\t\t{\n+\t\t\tMethodName: \"Send\",\n+\t\t\tHandler:    _McpConnectorService_Send_Handler,\n+\t\t},\n+\t},\n+\tStreams: []grpc.StreamDesc{\n+\t\t{\n+\t\t\tStreamName:    \"Channel\",\n+\t\t\tHandler:       _McpConnectorService_Channel_Handler,\n+\t\t\tServerStreams: true,\n+\t\t\tClientStreams: true,\n+\t\t},\n+\t},\n+\tMetadata: \"duplo/mcp/v1/mcp_connector.proto\",\n+}\ndiff --git a/mcp-proxy/go.mod b/mcp-proxy/go.mod\nnew file mode 100644\nindex 000000000..f21768937\n--- /dev/null\n+++ b/mcp-proxy/go.mod\n@@ -0,0 +1,35 @@\n+module mcp-proxy\n+\n+go 1.25\n+\n+require (\n+\tgithub.com/go-viper/mapstructure/v2 v2.4.0\n+\tgithub.com/google/uuid v1.6.0\n+\tgithub.com/rs/zerolog v1.34.0\n+\tgithub.com/spf13/afero v1.15.0\n+\tgithub.com/spf13/viper v1.21.0\n+\tgithub.com/stretchr/testify v1.11.1\n+\tgolang.org/x/sync v0.18.0\n+\tgoogle.golang.org/grpc v1.78.0\n+\tgoogle.golang.org/protobuf v1.36.11\n+)\n+\n+require (\n+\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n+\tgithub.com/fsnotify/fsnotify v1.9.0 // indirect\n+\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n+\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n+\tgithub.com/pelletier/go-toml/v2 v2.2.4 // indirect\n+\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n+\tgithub.com/sagikazarmark/locafero v0.11.0 // indirect\n+\tgithub.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8 // indirect\n+\tgithub.com/spf13/cast v1.10.0 // indirect\n+\tgithub.com/spf13/pflag v1.0.10 // indirect\n+\tgithub.com/subosito/gotenv v1.6.0 // indirect\n+\tgo.yaml.in/yaml/v3 v3.0.4 // indirect\n+\tgolang.org/x/net v0.47.0 // indirect\n+\tgolang.org/x/sys v0.38.0 // indirect\n+\tgolang.org/x/text v0.31.0 // indirect\n+\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20251029180050-ab9386a59fda // indirect\n+\tgopkg.in/yaml.v3 v3.0.1 // indirect\n+)\ndiff --git a/mcp-proxy/go.sum b/mcp-proxy/go.sum\nnew file mode 100644\nindex 000000000..a9348eb46\n--- /dev/null\n+++ b/mcp-proxy/go.sum\n@@ -0,0 +1,93 @@\n+github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\n+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\n+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\n+github.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\n+github.com/fsnotify/fsnotify v1.9.0 h1:2Ml+OJNzbYCTzsxtv8vKSFD9PbJjmhYF14k/jKC7S9k=\n+github.com/fsnotify/fsnotify v1.9.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=\n+github.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=\n+github.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\n+github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\n+github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\n+github.com/go-viper/mapstructure/v2 v2.4.0 h1:EBsztssimR/CONLSZZ04E8qAkxNYq4Qp9LvH92wZUgs=\n+github.com/go-viper/mapstructure/v2 v2.4.0/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=\n+github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\n+github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\n+github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\n+github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=\n+github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=\n+github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\n+github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\n+github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\n+github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\n+github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\n+github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\n+github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\n+github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\n+github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\n+github.com/mattn/go-isatty v0.0.19 h1:JITubQf0MOLdlGRuRq+jtsDlekdYPia9ZFsB8h/APPA=\n+github.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\n+github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=\n+github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=\n+github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n+github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\n+github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\n+github.com/rs/xid v1.6.0/go.mod h1:7XoLgs4eV+QndskICGsho+ADou8ySMSjJKDIan90Nz0=\n+github.com/rs/zerolog v1.34.0 h1:k43nTLIwcTVQAncfCw4KZ2VY6ukYoZaBPNOE8txlOeY=\n+github.com/rs/zerolog v1.34.0/go.mod h1:bJsvje4Z08ROH4Nhs5iH600c3IkWhwp44iRc54W6wYQ=\n+github.com/sagikazarmark/locafero v0.11.0 h1:1iurJgmM9G3PA/I+wWYIOw/5SyBtxapeHDcg+AAIFXc=\n+github.com/sagikazarmark/locafero v0.11.0/go.mod h1:nVIGvgyzw595SUSUE6tvCp3YYTeHs15MvlmU87WwIik=\n+github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8 h1:+jumHNA0Wrelhe64i8F6HNlS8pkoyMv5sreGx2Ry5Rw=\n+github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8/go.mod h1:3n1Cwaq1E1/1lhQhtRK2ts/ZwZEhjcQeJQ1RuC6Q/8U=\n+github.com/spf13/afero v1.15.0 h1:b/YBCLWAJdFWJTN9cLhiXXcD7mzKn9Dm86dNnfyQw1I=\n+github.com/spf13/afero v1.15.0/go.mod h1:NC2ByUVxtQs4b3sIUphxK0NioZnmxgyCrfzeuq8lxMg=\n+github.com/spf13/cast v1.10.0 h1:h2x0u2shc1QuLHfxi+cTJvs30+ZAHOGRic8uyGTDWxY=\n+github.com/spf13/cast v1.10.0/go.mod h1:jNfB8QC9IA6ZuY2ZjDp0KtFO2LZZlg4S/7bzP6qqeHo=\n+github.com/spf13/pflag v1.0.10 h1:4EBh2KAYBwaONj6b2Ye1GiHfwjqyROoF4RwYO+vPwFk=\n+github.com/spf13/pflag v1.0.10/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\n+github.com/spf13/viper v1.21.0 h1:x5S+0EU27Lbphp4UKm1C+1oQO+rKx36vfCoaVebLFSU=\n+github.com/spf13/viper v1.21.0/go.mod h1:P0lhsswPGWD/1lZJ9ny3fYnVqxiegrlNrEmgLjbTCAY=\n+github.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=\n+github.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=\n+github.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=\n+github.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=\n+go.opentelemetry.io/auto/sdk v1.2.1 h1:jXsnJ4Lmnqd11kwkBV2LgLoFMZKizbCi5fNZ/ipaZ64=\n+go.opentelemetry.io/auto/sdk v1.2.1/go.mod h1:KRTj+aOaElaLi+wW1kO/DZRXwkF4C5xPbEe3ZiIhN7Y=\n+go.opentelemetry.io/otel v1.38.0 h1:RkfdswUDRimDg0m2Az18RKOsnI8UDzppJAtj01/Ymk8=\n+go.opentelemetry.io/otel v1.38.0/go.mod h1:zcmtmQ1+YmQM9wrNsTGV/q/uyusom3P8RxwExxkZhjM=\n+go.opentelemetry.io/otel/metric v1.38.0 h1:Kl6lzIYGAh5M159u9NgiRkmoMKjvbsKtYRwgfrA6WpA=\n+go.opentelemetry.io/otel/metric v1.38.0/go.mod h1:kB5n/QoRM8YwmUahxvI3bO34eVtQf2i4utNVLr9gEmI=\n+go.opentelemetry.io/otel/sdk v1.38.0 h1:l48sr5YbNf2hpCUj/FoGhW9yDkl+Ma+LrVl8qaM5b+E=\n+go.opentelemetry.io/otel/sdk v1.38.0/go.mod h1:ghmNdGlVemJI3+ZB5iDEuk4bWA3GkTpW+DOoZMYBVVg=\n+go.opentelemetry.io/otel/sdk/metric v1.38.0 h1:aSH66iL0aZqo//xXzQLYozmWrXxyFkBJ6qT5wthqPoM=\n+go.opentelemetry.io/otel/sdk/metric v1.38.0/go.mod h1:dg9PBnW9XdQ1Hd6ZnRz689CbtrUp0wMMs9iPcgT9EZA=\n+go.opentelemetry.io/otel/trace v1.38.0 h1:Fxk5bKrDZJUH+AMyyIXGcFAPah0oRcT+LuNtJrmcNLE=\n+go.opentelemetry.io/otel/trace v1.38.0/go.mod h1:j1P9ivuFsTceSWe1oY+EeW3sc+Pp42sO++GHkg4wwhs=\n+go.yaml.in/yaml/v3 v3.0.4 h1:tfq32ie2Jv2UxXFdLJdh3jXuOzWiL1fo0bu/FbuKpbc=\n+go.yaml.in/yaml/v3 v3.0.4/go.mod h1:DhzuOOF2ATzADvBadXxruRBLzYTpT36CKvDb3+aBEFg=\n+golang.org/x/net v0.47.0 h1:Mx+4dIFzqraBXUugkia1OOvlD6LemFo1ALMHjrXDOhY=\n+golang.org/x/net v0.47.0/go.mod h1:/jNxtkgq5yWUGYkaZGqo27cfGZ1c5Nen03aYrrKpVRU=\n+golang.org/x/sync v0.18.0 h1:kr88TuHDroi+UVf+0hZnirlk8o8T+4MrK6mr60WkH/I=\n+golang.org/x/sync v0.18.0/go.mod h1:9KTHXmSnoGruLpwFjVSX0lNNA75CykiMECbovNTZqGI=\n+golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n+golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n+golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n+golang.org/x/sys v0.38.0 h1:3yZWxaJjBmCWXqhN1qh02AkOnCQ1poK6oF+a7xWL6Gc=\n+golang.org/x/sys v0.38.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=\n+golang.org/x/text v0.31.0 h1:aC8ghyu4JhP8VojJ2lEHBnochRno1sgL6nEi9WGFGMM=\n+golang.org/x/text v0.31.0/go.mod h1:tKRAlv61yKIjGGHX/4tP1LTbc13YSec1pxVEWXzfoeM=\n+gonum.org/v1/gonum v0.16.0 h1:5+ul4Swaf3ESvrOnidPp4GZbzf0mxVQpDCYUQE7OJfk=\n+gonum.org/v1/gonum v0.16.0/go.mod h1:fef3am4MQ93R2HHpKnLk4/Tbh/s0+wqD5nfa6Pnwy4E=\n+google.golang.org/genproto/googleapis/rpc v0.0.0-20251029180050-ab9386a59fda h1:i/Q+bfisr7gq6feoJnS/DlpdwEL4ihp41fvRiM3Ork0=\n+google.golang.org/genproto/googleapis/rpc v0.0.0-20251029180050-ab9386a59fda/go.mod h1:7i2o+ce6H/6BluujYR+kqX3GKH+dChPTQU19wjRPiGk=\n+google.golang.org/grpc v1.78.0 h1:K1XZG/yGDJnzMdd/uZHAkVqJE+xIDOcmdSFZkBUicNc=\n+google.golang.org/grpc v1.78.0/go.mod h1:I47qjTo4OKbMkjA/aOOwxDIiPSBofUtQUI5EfpWvW7U=\n+google.golang.org/protobuf v1.36.11 h1:fV6ZwhNocDyBLK0dj+fg8ektcVegBBuEolpbTQyBNVE=\n+google.golang.org/protobuf v1.36.11/go.mod h1:HTf+CrKn2C3g5S8VImy6tdcUvCska2kB7j23XfzDpco=\n+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\n+gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\n+gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\n+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\n+gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ndiff --git a/mcp-proxy/internal/app/app.go b/mcp-proxy/internal/app/app.go\nnew file mode 100644\nindex 000000000..4e2e25ae5\n--- /dev/null\n+++ b/mcp-proxy/internal/app/app.go\n@@ -0,0 +1,156 @@\n+// Package app provides application lifecycle management with graceful shutdown.\n+package app\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n+\t\"golang.org/x/sync/errgroup\"\n+)\n+\n+// Application manages the lifecycle of multiple services with graceful shutdown.\n+type Application struct {\n+\tctx    context.Context\n+\tcancel context.CancelFunc\n+\tonce   sync.Once\n+\n+\t// Logger is used for application-level logging.\n+\tLogger zerolog.Logger\n+\t// ShutdownTimeout is the maximum time to wait for services to stop.\n+\tShutdownTimeout time.Duration\n+\t// Services holds the registered services to run.\n+\tServices []Service\n+\t// Closers holds resources to close on shutdown.\n+\tClosers []io.Closer\n+}\n+\n+// Service is a long-running process managed by the application.\n+type Service interface {\n+\t// Name returns a human-readable service identifier.\n+\tName() string\n+\t// Run starts the service and blocks until ctx is cancelled or it fails.\n+\tRun(ctx context.Context) error\n+}\n+\n+func (a *Application) init() {\n+\ta.once.Do(func() {\n+\t\ta.ctx, a.cancel = context.WithCancel(context.Background())\n+\t})\n+}\n+\n+// Context returns the application-scoped context.\n+func (a *Application) Context() context.Context {\n+\ta.init()\n+\treturn a.ctx\n+}\n+\n+// AddService registers one or more services for the application to run.\n+func (a *Application) AddService(service ...Service) {\n+\ta.Services = append(a.Services, service...)\n+}\n+\n+// AddCloser registers resources to close on shutdown.\n+func (a *Application) AddCloser(closer ...io.Closer) {\n+\ta.Closers = append(a.Closers, closer...)\n+}\n+\n+// Run starts all services and blocks until shutdown, returning the exit code.\n+func (a *Application) Run() int {\n+\tif len(a.Services) == 0 {\n+\t\ta.Logger.Warn().Ctx(a.ctx).Msg(\"no services to run\")\n+\t\treturn 0\n+\t}\n+\n+\ta.init()\n+\ta.Logger.Info().Ctx(a.ctx).Msg(\"starting application\")\n+\n+\tdefer a.cancel()\n+\tdefer a.closeAll()\n+\n+\teg, egCtx := errgroup.WithContext(a.ctx)\n+\n+\t// Start all services\n+\tif err := a.startServices(eg, egCtx); err != nil {\n+\t\ta.cancel()\n+\t\ta.Logger.Error().Ctx(a.ctx).Err(err).Msg(err.Error())\n+\t\treturn 1\n+\t}\n+\n+\t// Service result channel\n+\tdoneChan := make(chan error, 1)\n+\tgo func() { doneChan <- eg.Wait() }()\n+\n+\t// OS signal channel\n+\tsigChan := make(chan os.Signal, 1)\n+\tsignal.Notify(sigChan, syscall.SIGQUIT, syscall.SIGINT, syscall.SIGTERM)\n+\n+\t// Wait for OS signal or a service failing/finishing\n+\tselect {\n+\tcase <-sigChan:\n+\t\ta.Logger.Info().Ctx(a.ctx).Msg(\"shutdown signal received\")\n+\t\ta.cancel()\n+\n+\t\tselect {\n+\t\tcase err := <-doneChan:\n+\t\t\tif err != nil {\n+\t\t\t\ta.Logger.Error().Ctx(a.ctx).Err(err).Msg(\"shutdown complete with error\")\n+\t\t\t\treturn 1\n+\t\t\t}\n+\t\t\ta.Logger.Info().Ctx(a.ctx).Msg(\"shutdown complete\")\n+\t\t\treturn 0\n+\n+\t\tcase <-time.After(a.ShutdownTimeout):\n+\t\t\ta.Logger.Error().Ctx(a.ctx).Msg(\"shutdown timed out\")\n+\t\t\treturn 1\n+\n+\t\tcase <-sigChan:\n+\t\t\ta.Logger.Warn().Ctx(a.ctx).Msg(\"forced shutdown signal received\")\n+\t\t\treturn 1\n+\t\t}\n+\n+\tcase err := <-doneChan:\n+\t\ta.cancel()\n+\t\tif err != nil {\n+\t\t\ta.Logger.Error().Ctx(a.ctx).Err(err).Msg(\"service failed, shutting down\")\n+\t\t\treturn 1\n+\t\t}\n+\n+\t\ta.Logger.Info().Ctx(a.ctx).Msg(\"all services completed normally, shutting down\")\n+\t\treturn 0\n+\t}\n+}\n+\n+func (a *Application) closeAll() {\n+\tfor _, c := range a.Closers {\n+\t\tif err := c.Close(); err != nil {\n+\t\t\ta.Logger.Warn().Err(err).Msg(\"closer error\")\n+\t\t}\n+\t}\n+}\n+\n+func (a *Application) startServices(eg *errgroup.Group, ctx context.Context) error {\n+\tfor _, service := range a.Services {\n+\t\ts := service\n+\n+\t\teg.Go(func() error {\n+\t\t\ta.Logger.Debug().Ctx(ctx).Str(\"service\", s.Name()).Msg(\"service starting\")\n+\n+\t\t\tif err := s.Run(ctx); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed to run %s service: %w\", s.Name(), err)\n+\t\t\t}\n+\n+\t\t\ta.Logger.Debug().Ctx(ctx).Str(\"service\", s.Name()).Msg(\"service stopped\")\n+\t\t\treturn nil\n+\t\t})\n+\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/mcp-proxy/internal/config/common.go b/mcp-proxy/internal/config/common.go\nnew file mode 100644\nindex 000000000..257dc299f\n--- /dev/null\n+++ b/mcp-proxy/internal/config/common.go\n@@ -0,0 +1,20 @@\n+package config\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/rs/zerolog\"\n+)\n+\n+// LoggerConfig holds structured logging settings.\n+type LoggerConfig struct {\n+\tJSON  bool          `mapstructure:\"json\"`\n+\tLevel zerolog.Level `mapstructure:\"level\"`\n+}\n+\n+func validatePort(name string, port int) error {\n+\tif port <= 0 || port > 65535 {\n+\t\treturn fmt.Errorf(\"invalid %s: %d, must be between 1 and 65535\", name, port)\n+\t}\n+\treturn nil\n+}\ndiff --git a/mcp-proxy/internal/config/config.go b/mcp-proxy/internal/config/config.go\nnew file mode 100644\nindex 000000000..d282e76ac\n--- /dev/null\n+++ b/mcp-proxy/internal/config/config.go\n@@ -0,0 +1,87 @@\n+// Package config loads and validates the proxy server configuration.\n+package config\n+\n+import (\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+// Config is the top-level configuration for the MCP proxy.\n+type Config struct {\n+\tServer    ServerConfig    `mapstructure:\"server\"`\n+\tGRPC      GRPCConfig      `mapstructure:\"grpc\"`\n+\tDiscovery DiscoveryConfig `mapstructure:\"discovery\"`\n+\tSession   SessionConfig   `mapstructure:\"session\"`\n+\tAuth      AuthConfig      `mapstructure:\"auth\"`\n+\tProxy     ProxyConfig     `mapstructure:\"proxy\"`\n+\tLogger    LoggerConfig    `mapstructure:\"logger\"`\n+}\n+\n+// ProxyConfig holds proxy instance identification settings.\n+type ProxyConfig struct {\n+\tID string `mapstructure:\"id\"`\n+}\n+\n+// DiscoveryConfig holds backend discovery settings.\n+type DiscoveryConfig struct {\n+\tAddrs []string `mapstructure:\"addrs\"`\n+}\n+\n+// SessionConfig holds SSE session settings.\n+type SessionConfig struct {\n+\tPingInterval    time.Duration `mapstructure:\"ping_interval\"`\n+\tTimeout         time.Duration `mapstructure:\"timeout\"`\n+\tCleanupInterval time.Duration `mapstructure:\"cleanup_interval\"`\n+}\n+\n+// AuthConfig holds access-key verification cache settings.\n+type AuthConfig struct {\n+\tCacheTTL time.Duration `mapstructure:\"cache_ttl\"`\n+}\n+\n+// ServerConfig holds HTTP server settings.\n+// Note: WriteTimeout is intentionally omitted because SSE (long-lived connections)\n+// is incompatible with a global write deadline. ReadHeaderTimeout protects against\n+// slowloris attacks without affecting SSE streams.\n+type ServerConfig struct {\n+\tPort              int           `mapstructure:\"port\"`\n+\tReadHeaderTimeout time.Duration `mapstructure:\"read_header_timeout\"`\n+\tIdleTimeout       time.Duration `mapstructure:\"idle_timeout\"`\n+\tShutdownTimeout   time.Duration `mapstructure:\"shutdown_timeout\"`\n+\tMaxRequestBodyMB  int           `mapstructure:\"max_request_body_mb\"`\n+}\n+\n+// GRPCConfig holds backend gRPC connection settings.\n+type GRPCConfig struct {\n+\tKeepAliveTime    time.Duration `mapstructure:\"keep_alive_time\"`\n+\tKeepAliveTimeout time.Duration `mapstructure:\"keep_alive_timeout\"`\n+\tMaxMessageSizeMB int           `mapstructure:\"max_message_size_mb\"`\n+}\n+\n+func (c *Config) validate() error {\n+\tif err := validatePort(\"server.port\", c.Server.Port); err != nil {\n+\t\treturn err\n+\t}\n+\tif c.Server.ShutdownTimeout <= 0 {\n+\t\treturn fmt.Errorf(\"invalid server.shutdown_timeout: must be positive\")\n+\t}\n+\tif c.Server.MaxRequestBodyMB < 0 {\n+\t\treturn fmt.Errorf(\"invalid server.max_request_body_mb: must be non-negative\")\n+\t}\n+\tif len(c.Discovery.Addrs) == 0 {\n+\t\treturn fmt.Errorf(\"discovery.addrs is required: at least one backend address\")\n+\t}\n+\tif c.GRPC.MaxMessageSizeMB <= 0 {\n+\t\treturn fmt.Errorf(\"invalid grpc.max_message_size_mb: must be positive\")\n+\t}\n+\tif c.Session.Timeout <= 0 {\n+\t\treturn fmt.Errorf(\"invalid session.timeout: must be positive\")\n+\t}\n+\tif c.Session.CleanupInterval <= 0 {\n+\t\treturn fmt.Errorf(\"invalid session.cleanup_interval: must be positive (prevents ticker panic)\")\n+\t}\n+\tif c.Proxy.ID == \"\" {\n+\t\treturn fmt.Errorf(\"proxy.id is required\")\n+\t}\n+\treturn nil\n+}\ndiff --git a/mcp-proxy/internal/config/env.go b/mcp-proxy/internal/config/env.go\nnew file mode 100644\nindex 000000000..1a6c3e9ef\n--- /dev/null\n+++ b/mcp-proxy/internal/config/env.go\n@@ -0,0 +1,40 @@\n+package config\n+\n+import (\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+// Environment represents the deployment environment.\n+type Environment string\n+\n+// Supported environment values.\n+const (\n+\tEnvLocal  Environment = \"local\"\n+\tEnvDocker Environment = \"docker\"\n+\tEnvDev    Environment = \"dev\"\n+\tEnvStage  Environment = \"stage\"\n+\tEnvProd   Environment = \"prod\"\n+)\n+\n+// ENV holds the current environment, defaulting to EnvLocal.\n+var ENV = EnvLocal\n+\n+func init() {\n+\tenvStr := os.Getenv(\"ENV\")\n+\tenvStr = strings.ToLower(envStr)\n+\n+\tenvValues := []Environment{EnvLocal, EnvDocker, EnvDev, EnvStage, EnvProd}\n+\n+\tfor _, envValue := range envValues {\n+\t\tif strings.EqualFold(envStr, string(envValue)) {\n+\t\t\tENV = envValue\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+// String returns the environment name as a string.\n+func (e Environment) String() string {\n+\treturn string(e)\n+}\ndiff --git a/mcp-proxy/internal/config/files/default.yaml b/mcp-proxy/internal/config/files/default.yaml\nnew file mode 100644\nindex 000000000..3f416b2ea\n--- /dev/null\n+++ b/mcp-proxy/internal/config/files/default.yaml\n@@ -0,0 +1,24 @@\n+server:\n+  port: 9000\n+  read_header_timeout: 30s\n+  idle_timeout: 2h\n+  shutdown_timeout: 30s\n+  max_request_body_mb: 4\n+grpc:\n+  keep_alive_time: 30s\n+  keep_alive_timeout: 10s\n+  max_message_size_mb: 16\n+discovery:\n+  addrs:\n+    - \"localhost:9091\"\n+session:\n+  ping_interval: 30s\n+  timeout: 2h\n+  cleanup_interval: 5m\n+proxy:\n+  id: \"mcp-proxy-0\"\n+auth:\n+  cache_ttl: 5m\n+logger:\n+  json: false\n+  level: debug\ndiff --git a/mcp-proxy/internal/config/load.go b/mcp-proxy/internal/config/load.go\nnew file mode 100644\nindex 000000000..7cf98ed0e\n--- /dev/null\n+++ b/mcp-proxy/internal/config/load.go\n@@ -0,0 +1,60 @@\n+package config\n+\n+import (\n+\t\"embed\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"github.com/go-viper/mapstructure/v2\"\n+\t\"github.com/spf13/afero\"\n+\t\"github.com/spf13/viper\"\n+)\n+\n+//go:embed files/*.yaml\n+var configFS embed.FS\n+\n+// LoadConfig reads the default config, merges environment overrides, applies\n+// environment variables, and returns the validated configuration.\n+func LoadConfig() (*Config, error) {\n+\tv := viper.New()\n+\tv.SetFs(afero.FromIOFS{FS: configFS})\n+\tv.SetConfigType(\"yaml\")\n+\n+\t// base\n+\tv.SetConfigFile(\"files/default.yaml\")\n+\tif err := v.ReadInConfig(); err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to load default config: %w\", err)\n+\t}\n+\n+\t// ENV specific\n+\tv.SetConfigFile(fmt.Sprintf(\"files/%s.yaml\", ENV.String()))\n+\tif err := v.MergeInConfig(); err != nil {\n+\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\treturn nil, fmt.Errorf(\"failed to merge %s config: %w\", ENV.String(), err)\n+\t\t}\n+\t}\n+\n+\t// override from environment variables\n+\tv.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n+\tv.AutomaticEnv()\n+\n+\t// unmarshal\n+\tcfg := &Config{}\n+\terr := v.UnmarshalExact(cfg,\n+\t\tfunc(c *mapstructure.DecoderConfig) {\n+\t\t\tc.DecodeHook = mapstructure.ComposeDecodeHookFunc(\n+\t\t\t\tc.DecodeHook,\n+\t\t\t\tmapstructure.TextUnmarshallerHookFunc(),\n+\t\t\t)\n+\t\t},\n+\t)\n+\n+\t// validate\n+\tif err == nil {\n+\t\terr = cfg.validate()\n+\t}\n+\n+\treturn cfg, err\n+}\ndiff --git a/mcp-proxy/internal/grpcclient/backend_pool.go b/mcp-proxy/internal/grpcclient/backend_pool.go\nnew file mode 100644\nindex 000000000..fe679ee55\n--- /dev/null\n+++ b/mcp-proxy/internal/grpcclient/backend_pool.go\n@@ -0,0 +1,142 @@\n+package grpcclient\n+\n+import (\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\n+\t\"google.golang.org/grpc\"\n+)\n+\n+// BackendPool manages gRPC connections to multiple backend pods.\n+// Each pod gets at most one connection (HTTP/2 multiplexing).\n+type BackendPool struct {\n+\tmu       sync.RWMutex\n+\tconns    map[string]*grpc.ClientConn // addr → conn (lazy-dialed)\n+\taddrs    []string                    // sorted snapshot of known addrs\n+\tcounter  atomic.Uint64              // round-robin counter\n+\tdialOpts []grpc.DialOption\n+}\n+\n+// NewBackendPool creates an empty pool with the given dial options.\n+func NewBackendPool(opts ...grpc.DialOption) *BackendPool {\n+\treturn &BackendPool{\n+\t\tconns:    make(map[string]*grpc.ClientConn),\n+\t\tdialOpts: opts,\n+\t}\n+}\n+\n+// UpdateAddrs replaces the set of known backend addresses.\n+// New addresses are registered (connections are lazy-dialed on first Conn call).\n+// Removed addresses have their connections closed immediately.\n+func (p *BackendPool) UpdateAddrs(addrs []string) {\n+\tsorted := make([]string, len(addrs))\n+\tcopy(sorted, addrs)\n+\tsort.Strings(sorted)\n+\n+\tnewSet := make(map[string]struct{}, len(sorted))\n+\tfor _, a := range sorted {\n+\t\tnewSet[a] = struct{}{}\n+\t}\n+\n+\tp.mu.Lock()\n+\tdefer p.mu.Unlock()\n+\n+\t// Close connections for removed addrs\n+\tfor addr, conn := range p.conns {\n+\t\tif _, ok := newSet[addr]; !ok {\n+\t\t\tif conn != nil {\n+\t\t\t\tconn.Close()\n+\t\t\t}\n+\t\t\tdelete(p.conns, addr)\n+\t\t}\n+\t}\n+\n+\t// Register new addrs (no conn yet — lazy dial)\n+\tfor _, addr := range sorted {\n+\t\tif _, ok := p.conns[addr]; !ok {\n+\t\t\tp.conns[addr] = nil // placeholder for known addr\n+\t\t}\n+\t}\n+\n+\tp.addrs = sorted\n+}\n+\n+// Addrs returns the current sorted list of known backend addresses.\n+func (p *BackendPool) Addrs() []string {\n+\tp.mu.RLock()\n+\tdefer p.mu.RUnlock()\n+\n+\tout := make([]string, len(p.addrs))\n+\tcopy(out, p.addrs)\n+\treturn out\n+}\n+\n+// PickAddr selects the next backend address using round-robin.\n+func (p *BackendPool) PickAddr() (string, error) {\n+\tp.mu.RLock()\n+\tdefer p.mu.RUnlock()\n+\n+\tif len(p.addrs) == 0 {\n+\t\treturn \"\", fmt.Errorf(\"no backend available\")\n+\t}\n+\n+\tidx := p.counter.Add(1) - 1\n+\treturn p.addrs[idx%uint64(len(p.addrs))], nil\n+}\n+\n+// Conn returns the gRPC connection for the given address, dialing lazily if needed.\n+// Returns an error if the address is not in the known set.\n+func (p *BackendPool) Conn(addr string) (*grpc.ClientConn, error) {\n+\t// Fast path: check if conn already exists\n+\tp.mu.RLock()\n+\tconn, known := p.conns[addr]\n+\tp.mu.RUnlock()\n+\n+\tif !known {\n+\t\treturn nil, fmt.Errorf(\"unknown backend addr: %s\", addr)\n+\t}\n+\tif conn != nil {\n+\t\treturn conn, nil\n+\t}\n+\n+\t// Slow path: dial under write lock\n+\tp.mu.Lock()\n+\tdefer p.mu.Unlock()\n+\n+\t// Double-check after acquiring write lock (addr may have been dialed or removed)\n+\tconn, ok := p.conns[addr]\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"unknown backend addr: %s\", addr)\n+\t}\n+\tif conn != nil {\n+\t\treturn conn, nil\n+\t}\n+\n+\tnewConn, err := grpc.NewClient(addr, p.dialOpts...)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to dial %s: %w\", addr, err)\n+\t}\n+\n+\tp.conns[addr] = newConn\n+\treturn newConn, nil\n+}\n+\n+// Close shuts down all connections in the pool.\n+func (p *BackendPool) Close() error {\n+\tp.mu.Lock()\n+\tdefer p.mu.Unlock()\n+\n+\tvar firstErr error\n+\tfor addr, conn := range p.conns {\n+\t\tif conn != nil {\n+\t\t\tif err := conn.Close(); err != nil && firstErr == nil {\n+\t\t\t\tfirstErr = err\n+\t\t\t}\n+\t\t}\n+\t\tdelete(p.conns, addr)\n+\t}\n+\tp.addrs = nil\n+\treturn firstErr\n+}\ndiff --git a/mcp-proxy/internal/grpcclient/backend_pool_test.go b/mcp-proxy/internal/grpcclient/backend_pool_test.go\nnew file mode 100644\nindex 000000000..6c171693e\n--- /dev/null\n+++ b/mcp-proxy/internal/grpcclient/backend_pool_test.go\n@@ -0,0 +1,153 @@\n+package grpcclient\n+\n+import (\n+\t\"sort\"\n+\t\"sync\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+)\n+\n+func TestBackendPool_UpdateAddrs_AddNew(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr2\"})\n+\n+\taddrs := pool.Addrs()\n+\tsort.Strings(addrs)\n+\tassert.Equal(t, []string{\"addr1\", \"addr2\"}, addrs)\n+}\n+\n+func TestBackendPool_UpdateAddrs_RemoveStale(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr2\", \"addr3\"})\n+\n+\t// Get conn for addr1 to ensure it's created\n+\t_, err := pool.Conn(\"addr1\")\n+\trequire.NoError(t, err)\n+\n+\tpool.UpdateAddrs([]string{\"addr2\", \"addr3\"})\n+\n+\taddrs := pool.Addrs()\n+\tsort.Strings(addrs)\n+\tassert.Equal(t, []string{\"addr2\", \"addr3\"}, addrs)\n+\n+\t// addr1 should no longer be reachable\n+\t_, err = pool.Conn(\"addr1\")\n+\tassert.Error(t, err)\n+}\n+\n+func TestBackendPool_UpdateAddrs_KeepExisting(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr2\"})\n+\tconn1, err := pool.Conn(\"addr1\")\n+\trequire.NoError(t, err)\n+\n+\t// Update with addr1 still present\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr3\"})\n+\tconn1Again, err := pool.Conn(\"addr1\")\n+\trequire.NoError(t, err)\n+\n+\t// Same connection should be reused\n+\tassert.True(t, conn1 == conn1Again, \"existing conn should be reused\")\n+}\n+\n+func TestBackendPool_Conn_KnownAddr(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"localhost:9091\"})\n+\n+\tconn, err := pool.Conn(\"localhost:9091\")\n+\trequire.NoError(t, err)\n+\tassert.NotNil(t, conn)\n+\n+\t// Same conn returned on second call\n+\tconn2, err := pool.Conn(\"localhost:9091\")\n+\trequire.NoError(t, err)\n+\tassert.True(t, conn == conn2)\n+}\n+\n+func TestBackendPool_Conn_UnknownAddr(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"addr1\"})\n+\n+\t_, err := pool.Conn(\"unknown-addr\")\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"unknown backend addr\")\n+}\n+\n+func TestBackendPool_PickAddr_RoundRobin(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr2\", \"addr3\"})\n+\taddrs := pool.Addrs() // sorted\n+\n+\tpicked := make([]string, 6)\n+\tfor i := range picked {\n+\t\taddr, err := pool.PickAddr()\n+\t\trequire.NoError(t, err)\n+\t\tpicked[i] = addr\n+\t}\n+\n+\t// Should cycle through sorted addrs\n+\tfor i, addr := range picked {\n+\t\tassert.Equal(t, addrs[i%3], addr)\n+\t}\n+}\n+\n+func TestBackendPool_PickAddr_Empty(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\t_, err := pool.PickAddr()\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"no backend\")\n+}\n+\n+func TestBackendPool_Close(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr2\"})\n+\t_, _ = pool.Conn(\"addr1\")\n+\t_, _ = pool.Conn(\"addr2\")\n+\n+\terr := pool.Close()\n+\tassert.NoError(t, err)\n+}\n+\n+func TestBackendPool_RaceCondition(t *testing.T) {\n+\tpool := NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"addr1\", \"addr2\", \"addr3\"})\n+\n+\tvar wg sync.WaitGroup\n+\tfor range 50 {\n+\t\twg.Add(3)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tpool.PickAddr()\n+\t\t}()\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tpool.Conn(\"addr1\")\n+\t\t}()\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tpool.Addrs()\n+\t\t}()\n+\t}\n+\twg.Wait()\n+}\ndiff --git a/mcp-proxy/internal/logging/component_writer.go b/mcp-proxy/internal/logging/component_writer.go\nnew file mode 100644\nindex 000000000..fb596dc76\n--- /dev/null\n+++ b/mcp-proxy/internal/logging/component_writer.go\n@@ -0,0 +1,91 @@\n+// Package logging provides structured logging backed by zerolog.\n+package logging\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"io\"\n+\t\"strings\"\n+)\n+\n+// Log type constants for the component log envelope.\n+const (\n+\tLogTypeComponent = \"COMPONENT_LOG\"\n+\tLogTypeAccess    = \"ACCESS_LOG\"\n+)\n+\n+type componentLog struct {\n+\tComponentName string         `json:\"component_name\"`\n+\tLogLevel      string         `json:\"log_level\"`\n+\tLogType       string         `json:\"log_type\"`\n+\tTime          string         `json:\"time\"`\n+\tContent       map[string]any `json:\"content\"`\n+}\n+\n+// ComponentLogWriter wraps zerolog JSON output into the component log envelope.\n+type ComponentLogWriter struct {\n+\tout           io.Writer\n+\tcomponentName string\n+}\n+\n+// NewComponentLogWriter creates a writer that re-formats zerolog JSON entries.\n+func NewComponentLogWriter(out io.Writer, componentName string) *ComponentLogWriter {\n+\treturn &ComponentLogWriter{\n+\t\tout:           out,\n+\t\tcomponentName: componentName,\n+\t}\n+}\n+\n+// Write re-encodes a zerolog JSON entry as a component log.\n+func (w *ComponentLogWriter) Write(p []byte) (n int, err error) {\n+\tvar evt map[string]any\n+\td := json.NewDecoder(bytes.NewReader(p))\n+\td.UseNumber()\n+\tif err := d.Decode(&evt); err != nil {\n+\t\treturn w.out.Write(p)\n+\t}\n+\n+\t// Extract special fields\n+\tlevelVal, _ := evt[\"level\"].(string)\n+\tdelete(evt, \"level\")\n+\n+\ttimestampVal, _ := evt[\"time\"].(string)\n+\tdelete(evt, \"time\")\n+\n+\tmessageVal, _ := evt[\"message\"].(string)\n+\tdelete(evt, \"message\")\n+\n+\tlogTypeVal, _ := evt[\"log_type\"].(string)\n+\tdelete(evt, \"log_type\")\n+\n+\t// Set default values\n+\tlevel := \"INFO\"\n+\tif levelVal != \"\" {\n+\t\tlevel = strings.ToUpper(levelVal)\n+\t}\n+\n+\tlogType := LogTypeComponent\n+\tif logTypeVal != \"\" {\n+\t\tlogType = logTypeVal\n+\t}\n+\n+\t// Build content with message first\n+\tcontent := make(map[string]any, len(evt)+2)\n+\tcontent[\"message\"] = messageVal\n+\tfor k, v := range evt {\n+\t\tcontent[k] = v\n+\t}\n+\n+\tentry := componentLog{\n+\t\tComponentName: w.componentName,\n+\t\tLogLevel:      level,\n+\t\tLogType:       logType,\n+\t\tTime:          timestampVal,\n+\t\tContent:       content,\n+\t}\n+\n+\tif err := json.NewEncoder(w.out).Encode(entry); err != nil {\n+\t\treturn w.out.Write(p)\n+\t}\n+\treturn len(p), nil\n+}\ndiff --git a/mcp-proxy/internal/logging/logger.go b/mcp-proxy/internal/logging/logger.go\nnew file mode 100644\nindex 000000000..dd0e770e0\n--- /dev/null\n+++ b/mcp-proxy/internal/logging/logger.go\n@@ -0,0 +1,64 @@\n+// Package logging provides structured logging backed by zerolog.\n+package logging\n+\n+import (\n+\t\"context\"\n+\t\"io\"\n+\t\"os\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n+)\n+\n+func init() {\n+\tzerolog.TimeFieldFormat = time.RFC3339Nano\n+}\n+\n+var defaultLogger = zerolog.Nop()\n+var defaultComponentName = \"duplo-mcp-proxy\"\n+\n+// Options configures the global logger.\n+type Options struct {\n+\tJSON          bool\n+\tLevel         zerolog.Level\n+\tComponentName string\n+}\n+\n+// Init initializes the global logger with the given options.\n+func Init(options Options) {\n+\tvar output io.Writer\n+\n+\tcomponentName := options.ComponentName\n+\tif componentName == \"\" {\n+\t\tcomponentName = defaultComponentName\n+\t}\n+\n+\tif options.JSON {\n+\t\toutput = NewComponentLogWriter(os.Stderr, componentName)\n+\t} else {\n+\t\toutput = zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339}\n+\t}\n+\n+\tzerolog.SetGlobalLevel(options.Level)\n+\n+\tdefaultLogger = zerolog.New(output).With().Timestamp().Logger()\n+}\n+\n+// Default returns the global logger.\n+func Default() zerolog.Logger {\n+\treturn defaultLogger\n+}\n+\n+// ForModule returns a logger tagged with the given module name.\n+func ForModule(name string) zerolog.Logger {\n+\treturn defaultLogger.With().Str(\"module\", name).Logger()\n+}\n+\n+// Ctx extracts a logger from the context, falling back to the global logger.\n+func Ctx(ctx context.Context) *zerolog.Logger {\n+\tif logger := zerolog.Ctx(ctx); logger.GetLevel() != zerolog.Disabled {\n+\t\treturn logger\n+\t}\n+\n+\treturn &defaultLogger\n+}\ndiff --git a/mcp-proxy/internal/mcp/auth.go b/mcp-proxy/internal/mcp/auth.go\nnew file mode 100644\nindex 000000000..6171e7b59\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/auth.go\n@@ -0,0 +1,92 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+)\n+\n+// AuthInfo holds verified access-key information.\n+type AuthInfo struct {\n+\tUserID   string\n+\tDeviceID string\n+}\n+\n+type cacheEntry struct {\n+\tinfo      *AuthInfo\n+\texpiresAt time.Time\n+}\n+\n+// AccessKeyVerifier validates access keys against the backend with TTL caching.\n+type AccessKeyVerifier struct {\n+\tbackend  BackendClient\n+\tcacheTTL time.Duration\n+\tmu       sync.RWMutex\n+\tcache    map[string]*cacheEntry\n+}\n+\n+// NewAccessKeyVerifier creates a verifier with the given cache TTL.\n+func NewAccessKeyVerifier(backend BackendClient, cacheTTL time.Duration) *AccessKeyVerifier {\n+\treturn &AccessKeyVerifier{\n+\t\tbackend:  backend,\n+\t\tcacheTTL: cacheTTL,\n+\t\tcache:    make(map[string]*cacheEntry),\n+\t}\n+}\n+\n+// Verify validates an access key for the given preset, returning AuthInfo on success.\n+func (v *AccessKeyVerifier) Verify(ctx context.Context, accessKey, presetID string) (*AuthInfo, error) {\n+\tcacheKey := accessKey + \":\" + presetID\n+\n+\t// Cache hit\n+\tv.mu.RLock()\n+\tif entry, ok := v.cache[cacheKey]; ok && time.Now().Before(entry.expiresAt) {\n+\t\tv.mu.RUnlock()\n+\t\treturn entry.info, nil\n+\t}\n+\tv.mu.RUnlock()\n+\n+\t// Cache miss — call backend\n+\tresp, err := v.backend.VerifyAccessKey(ctx, &mcpv1.VerifyAccessKeyRequest{\n+\t\tAccessKey: accessKey,\n+\t\tPresetId:  presetID,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to verify access key: %w\", err)\n+\t}\n+\tif !resp.Valid {\n+\t\treturn nil, fmt.Errorf(\"invalid access key\")\n+\t}\n+\n+\tinfo := &AuthInfo{\n+\t\tUserID:   resp.UserId,\n+\t\tDeviceID: resp.DeviceId,\n+\t}\n+\n+\t// Store in cache\n+\tv.mu.Lock()\n+\tv.cache[cacheKey] = &cacheEntry{\n+\t\tinfo:      info,\n+\t\texpiresAt: time.Now().Add(v.cacheTTL),\n+\t}\n+\tv.mu.Unlock()\n+\n+\treturn info, nil\n+}\n+\n+// ParseBearerToken extracts the token from an \"Authorization: Bearer <token>\" header.\n+func ParseBearerToken(header string) (string, error) {\n+\tconst prefix = \"Bearer \"\n+\tif !strings.HasPrefix(header, prefix) {\n+\t\treturn \"\", fmt.Errorf(\"missing Bearer prefix\")\n+\t}\n+\ttoken := strings.TrimSpace(header[len(prefix):])\n+\tif token == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"empty bearer token\")\n+\t}\n+\treturn token, nil\n+}\ndiff --git a/mcp-proxy/internal/mcp/auth_test.go b/mcp-proxy/internal/mcp/auth_test.go\nnew file mode 100644\nindex 000000000..277762c75\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/auth_test.go\n@@ -0,0 +1,100 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestAccessKeyVerifier_ValidKey(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tv := NewAccessKeyVerifier(mock, 5*time.Minute)\n+\n+\tinfo, err := v.Verify(context.Background(), \"valid-key\", \"preset-1\")\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"user-1\", info.UserID)\n+\tassert.Equal(t, \"device-1\", info.DeviceID)\n+\tassert.Equal(t, 1, mock.calls[\"VerifyAccessKey\"])\n+}\n+\n+func TestAccessKeyVerifier_InvalidKey(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tmock.verifyAccessKeyFn = func(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\t\treturn &mcpv1.VerifyAccessKeyResponse{Valid: false}, nil\n+\t}\n+\tv := NewAccessKeyVerifier(mock, 5*time.Minute)\n+\n+\t_, err := v.Verify(context.Background(), \"bad-key\", \"preset-1\")\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"invalid access key\")\n+}\n+\n+func TestAccessKeyVerifier_BackendError(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tmock.verifyAccessKeyFn = func(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\t\treturn nil, fmt.Errorf(\"connection refused\")\n+\t}\n+\tv := NewAccessKeyVerifier(mock, 5*time.Minute)\n+\n+\t_, err := v.Verify(context.Background(), \"key\", \"preset-1\")\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"connection refused\")\n+}\n+\n+func TestAccessKeyVerifier_CacheHit(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tv := NewAccessKeyVerifier(mock, 5*time.Minute)\n+\n+\t// First call\n+\tinfo1, err := v.Verify(context.Background(), \"key-1\", \"preset-1\")\n+\trequire.NoError(t, err)\n+\n+\t// Second call — cache hit\n+\tinfo2, err := v.Verify(context.Background(), \"key-1\", \"preset-1\")\n+\trequire.NoError(t, err)\n+\n+\tassert.Equal(t, info1, info2)\n+\tassert.Equal(t, 1, mock.calls[\"VerifyAccessKey\"]) // only 1 backend call\n+}\n+\n+func TestAccessKeyVerifier_CacheTTLExpired(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tv := NewAccessKeyVerifier(mock, 1*time.Millisecond) // very short TTL\n+\n+\t// First call\n+\t_, err := v.Verify(context.Background(), \"key-1\", \"preset-1\")\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, mock.calls[\"VerifyAccessKey\"])\n+\n+\t// Wait for TTL to expire\n+\ttime.Sleep(5 * time.Millisecond)\n+\n+\t// Second call — cache miss due to expiry\n+\t_, err = v.Verify(context.Background(), \"key-1\", \"preset-1\")\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 2, mock.calls[\"VerifyAccessKey\"])\n+}\n+\n+func TestParseBearerToken(t *testing.T) {\n+\ttoken, err := ParseBearerToken(\"Bearer my-token-123\")\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"my-token-123\", token)\n+}\n+\n+func TestParseBearerToken_MissingPrefix(t *testing.T) {\n+\t_, err := ParseBearerToken(\"Basic abc\")\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"missing Bearer prefix\")\n+}\n+\n+func TestParseBearerToken_Empty(t *testing.T) {\n+\t_, err := ParseBearerToken(\"Bearer \")\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"empty bearer token\")\n+}\ndiff --git a/mcp-proxy/internal/mcp/backend.go b/mcp-proxy/internal/mcp/backend.go\nnew file mode 100644\nindex 000000000..c05e5aab0\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/backend.go\n@@ -0,0 +1,26 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+)\n+\n+// BackendClient abstracts the gRPC Send RPC to the Kotlin backend.\n+type BackendClient interface {\n+\tCreateSession(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error)\n+\tListTools(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error)\n+\tCloseSession(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error)\n+\tCallTool(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error)\n+\tVerifyAccessKey(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error)\n+}\n+\n+// BackendRouter creates a BackendClient routed to a specific backend address.\n+type BackendRouter interface {\n+\tForAddr(addr string) (BackendClient, error)\n+}\n+\n+// AddrPicker selects a backend address. Used by Handler during initialize.\n+type AddrPicker interface {\n+\tPickAddr() (string, error)\n+}\ndiff --git a/mcp-proxy/internal/mcp/backend_routing.go b/mcp-proxy/internal/mcp/backend_routing.go\nnew file mode 100644\nindex 000000000..5870f7049\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/backend_routing.go\n@@ -0,0 +1,147 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\t\"mcp-proxy/internal/grpcclient\"\n+\n+\t\"google.golang.org/grpc\"\n+)\n+\n+var (\n+\t_ BackendClient = (*RoutingBackendClient)(nil)\n+\t_ BackendRouter = (*RoutingBackendClient)(nil)\n+)\n+\n+// RoutingBackendClient implements BackendClient (pick-any) and BackendRouter (routed).\n+// As a BackendClient, it uses PickAddr to select any available backend.\n+// As a BackendRouter, ForAddr returns a client bound to a specific backend.\n+type RoutingBackendClient struct {\n+\tpool *grpcclient.BackendPool\n+}\n+\n+// NewRoutingBackendClient creates a routing client backed by the given pool.\n+func NewRoutingBackendClient(pool *grpcclient.BackendPool) *RoutingBackendClient {\n+\treturn &RoutingBackendClient{pool: pool}\n+}\n+\n+// ForAddr returns a BackendClient bound to the given backend address.\n+func (c *RoutingBackendClient) ForAddr(addr string) (BackendClient, error) {\n+\tconn, err := c.pool.Conn(addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &singleConnClient{conn: conn}, nil\n+}\n+\n+// --- BackendClient (pick-any) implementation ---\n+\n+func (c *RoutingBackendClient) CreateSession(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error) {\n+\tclient, err := c.pickClient()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn client.CreateSession(ctx, req)\n+}\n+\n+func (c *RoutingBackendClient) ListTools(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\tclient, err := c.pickClient()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn client.ListTools(ctx, req)\n+}\n+\n+func (c *RoutingBackendClient) CloseSession(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error) {\n+\tclient, err := c.pickClient()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn client.CloseSession(ctx, req)\n+}\n+\n+func (c *RoutingBackendClient) CallTool(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\tclient, err := c.pickClient()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn client.CallTool(ctx, req)\n+}\n+\n+func (c *RoutingBackendClient) VerifyAccessKey(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\tclient, err := c.pickClient()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn client.VerifyAccessKey(ctx, req)\n+}\n+\n+func (c *RoutingBackendClient) pickClient() (BackendClient, error) {\n+\taddr, err := c.pool.PickAddr()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn c.ForAddr(addr)\n+}\n+\n+// singleConnClient implements BackendClient over a single gRPC connection.\n+type singleConnClient struct {\n+\tconn *grpc.ClientConn\n+}\n+\n+func (s *singleConnClient) CreateSession(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error) {\n+\treturn sendAndExtract(s, ctx,\n+\t\t&mcpv1.SendRequest{Payload: &mcpv1.SendRequest_CreateSession{CreateSession: req}},\n+\t\t(*mcpv1.SendResponse).GetCreateSession,\n+\t)\n+}\n+\n+func (s *singleConnClient) ListTools(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\treturn sendAndExtract(s, ctx,\n+\t\t&mcpv1.SendRequest{Payload: &mcpv1.SendRequest_ListTools{ListTools: req}},\n+\t\t(*mcpv1.SendResponse).GetListTools,\n+\t)\n+}\n+\n+func (s *singleConnClient) CloseSession(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error) {\n+\treturn sendAndExtract(s, ctx,\n+\t\t&mcpv1.SendRequest{Payload: &mcpv1.SendRequest_CloseSession{CloseSession: req}},\n+\t\t(*mcpv1.SendResponse).GetCloseSession,\n+\t)\n+}\n+\n+func (s *singleConnClient) CallTool(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\treturn sendAndExtract(s, ctx,\n+\t\t&mcpv1.SendRequest{Payload: &mcpv1.SendRequest_CallTool{CallTool: req}},\n+\t\t(*mcpv1.SendResponse).GetCallTool,\n+\t)\n+}\n+\n+func (s *singleConnClient) VerifyAccessKey(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\treturn sendAndExtract(s, ctx,\n+\t\t&mcpv1.SendRequest{Payload: &mcpv1.SendRequest_VerifyAccessKey{VerifyAccessKey: req}},\n+\t\t(*mcpv1.SendResponse).GetVerifyAccessKey,\n+\t)\n+}\n+\n+// sendAndExtract sends a request and extracts the typed result from the response envelope.\n+// It checks for backend error responses and unexpected (nil) payloads.\n+func sendAndExtract[T any](s *singleConnClient, ctx context.Context, req *mcpv1.SendRequest, extract func(*mcpv1.SendResponse) T) (T, error) {\n+\tvar zero T\n+\n+\tclient := mcpv1.NewMcpConnectorServiceClient(s.conn)\n+\tresp, err := client.Send(ctx, req)\n+\tif err != nil {\n+\t\treturn zero, err\n+\t}\n+\tif errResp := resp.GetError(); errResp != nil {\n+\t\treturn zero, fmt.Errorf(\"backend error: %s (code=%d)\", errResp.Message, errResp.Code)\n+\t}\n+\tresult := extract(resp)\n+\tif any(result) == nil {\n+\t\treturn zero, fmt.Errorf(\"unexpected response payload type\")\n+\t}\n+\treturn result, nil\n+}\ndiff --git a/mcp-proxy/internal/mcp/backend_routing_test.go b/mcp-proxy/internal/mcp/backend_routing_test.go\nnew file mode 100644\nindex 000000000..0c4b65458\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/backend_routing_test.go\n@@ -0,0 +1,46 @@\n+package mcp\n+\n+import (\n+\t\"testing\"\n+\n+\t\"mcp-proxy/internal/grpcclient\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+)\n+\n+func TestRoutingBackendClient_ForAddr_Known(t *testing.T) {\n+\tpool := grpcclient.NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"localhost:9091\"})\n+\trc := NewRoutingBackendClient(pool)\n+\n+\tclient, err := rc.ForAddr(\"localhost:9091\")\n+\trequire.NoError(t, err)\n+\tassert.NotNil(t, client)\n+}\n+\n+func TestRoutingBackendClient_ForAddr_Unknown(t *testing.T) {\n+\tpool := grpcclient.NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\tpool.UpdateAddrs([]string{\"localhost:9091\"})\n+\trc := NewRoutingBackendClient(pool)\n+\n+\t_, err := rc.ForAddr(\"unknown:9091\")\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"unknown backend addr\")\n+}\n+\n+func TestRoutingBackendClient_ImplementsInterfaces(t *testing.T) {\n+\tpool := grpcclient.NewBackendPool(grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tdefer pool.Close()\n+\n+\trc := NewRoutingBackendClient(pool)\n+\n+\tvar _ BackendClient = rc\n+\tvar _ BackendRouter = rc\n+}\ndiff --git a/mcp-proxy/internal/mcp/event_subscriber.go b/mcp-proxy/internal/mcp/event_subscriber.go\nnew file mode 100644\nindex 000000000..209d8a477\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/event_subscriber.go\n@@ -0,0 +1,147 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"time\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\t\"mcp-proxy/internal/grpcclient\"\n+\t\"mcp-proxy/pkg/jsonrpc\"\n+\t\"mcp-proxy/pkg/sessionid\"\n+)\n+\n+const maxReconnectRetries = 3\n+\n+// EventSubscriber subscribes to backend events for a session.\n+type EventSubscriber interface {\n+\t// Subscribe blocks until ctx is cancelled, calling callback for each event.\n+\tSubscribe(ctx context.Context, sessionID string, callback func([]byte)) error\n+}\n+\n+// GRPCEventSubscriber implements EventSubscriber over the Channel RPC.\n+// It routes to the correct backend using the session ID.\n+type GRPCEventSubscriber struct {\n+\tpool *grpcclient.BackendPool\n+}\n+\n+// NewGRPCEventSubscriber creates a subscriber using the given backend pool.\n+func NewGRPCEventSubscriber(pool *grpcclient.BackendPool) *GRPCEventSubscriber {\n+\treturn &GRPCEventSubscriber{pool: pool}\n+}\n+\n+// Subscribe opens a Channel stream and relays events as JSON-RPC notifications.\n+// On stream failure it reconnects with linear backoff up to maxReconnectRetries.\n+func (s *GRPCEventSubscriber) Subscribe(ctx context.Context, sessionID string, callback func([]byte)) error {\n+\tvar failures int\n+\tfor {\n+\t\terr := s.subscribeOnce(ctx, sessionID, callback)\n+\t\tif ctx.Err() != nil {\n+\t\t\treturn nil // context cancelled, normal shutdown\n+\t\t}\n+\n+\t\tfailures++\n+\t\tif failures > maxReconnectRetries {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil\n+\t\tcase <-time.After(time.Duration(failures) * time.Second): // linear backoff\n+\t\t}\n+\t}\n+}\n+\n+// subscribeOnce opens a single Channel stream and blocks until it ends.\n+func (s *GRPCEventSubscriber) subscribeOnce(ctx context.Context, sessionID string, callback func([]byte)) error {\n+\tparsed, err := sessionid.Parse(sessionID)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to parse session id: %w\", err)\n+\t}\n+\n+\tconn, err := s.pool.Conn(parsed.BackendAddr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to get backend connection: %w\", err)\n+\t}\n+\n+\tclient := mcpv1.NewMcpConnectorServiceClient(conn)\n+\n+\tstream, err := client.Channel(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to open channel: %w\", err)\n+\t}\n+\n+\t// Subscribe to events\n+\tif err := stream.Send(&mcpv1.ChannelRequest{\n+\t\tSessionId: sessionID,\n+\t\tPayload:   &mcpv1.ChannelRequest_SubscribeEvents{SubscribeEvents: &mcpv1.SubscribeEventsPayload{}},\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"failed to send subscribe: %w\", err)\n+\t}\n+\n+\t// Receive loop\n+\tfor {\n+\t\tresp, err := stream.Recv()\n+\t\tif err != nil {\n+\t\t\tif ctx.Err() != nil {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\treturn fmt.Errorf(\"channel recv error: %w\", err)\n+\t\t}\n+\n+\t\tdata := convertChannelEvent(resp)\n+\t\tif data != nil {\n+\t\t\tcallback(data)\n+\t\t}\n+\t}\n+}\n+\n+func convertChannelEvent(resp *mcpv1.ChannelResponse) []byte {\n+\tvar notif *jsonrpc.Notification\n+\n+\tswitch resp.Payload.(type) {\n+\tcase *mcpv1.ChannelResponse_ToolListChanged:\n+\t\tnotif = jsonrpc.NewNotification(\"notifications/tools/list_changed\", nil)\n+\n+\tcase *mcpv1.ChannelResponse_Progress:\n+\t\tp := resp.GetProgress()\n+\t\tparams := map[string]any{\n+\t\t\t\"progressToken\": p.ProgressToken,\n+\t\t}\n+\t\tif p.Progress != nil {\n+\t\t\tparams[\"progress\"] = *p.Progress\n+\t\t}\n+\t\tif p.Total != nil {\n+\t\t\tparams[\"total\"] = *p.Total\n+\t\t}\n+\t\tif p.Message != \"\" {\n+\t\t\tparams[\"message\"] = p.Message\n+\t\t}\n+\t\tnotif = jsonrpc.NewNotification(\"notifications/progress\", params)\n+\n+\tcase *mcpv1.ChannelResponse_LoggingMessage:\n+\t\tlm := resp.GetLoggingMessage()\n+\t\tparams := map[string]any{\n+\t\t\t\"level\":  lm.Level,\n+\t\t\t\"logger\": lm.Logger,\n+\t\t}\n+\t\tif lm.DataJson != \"\" {\n+\t\t\tvar data any\n+\t\t\tif err := json.Unmarshal([]byte(lm.DataJson), &data); err == nil {\n+\t\t\t\tparams[\"data\"] = data\n+\t\t\t}\n+\t\t}\n+\t\tnotif = jsonrpc.NewNotification(\"notifications/message\", params)\n+\n+\tdefault:\n+\t\treturn nil\n+\t}\n+\n+\tdata, err := json.Marshal(notif)\n+\tif err != nil {\n+\t\treturn nil\n+\t}\n+\treturn data\n+}\ndiff --git a/mcp-proxy/internal/mcp/event_subscriber_test.go b/mcp-proxy/internal/mcp/event_subscriber_test.go\nnew file mode 100644\nindex 000000000..5a81a1c87\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/event_subscriber_test.go\n@@ -0,0 +1,102 @@\n+package mcp\n+\n+import (\n+\t\"encoding/json\"\n+\t\"testing\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"google.golang.org/protobuf/proto\"\n+)\n+\n+func TestConvertChannelEvent_ToolListChanged(t *testing.T) {\n+\tresp := &mcpv1.ChannelResponse{\n+\t\tPayload: &mcpv1.ChannelResponse_ToolListChanged{\n+\t\t\tToolListChanged: &mcpv1.ToolListChangedEvent{},\n+\t\t},\n+\t}\n+\n+\tdata := convertChannelEvent(resp)\n+\trequire.NotNil(t, data)\n+\n+\tvar notif map[string]any\n+\trequire.NoError(t, json.Unmarshal(data, &notif))\n+\tassert.Equal(t, \"2.0\", notif[\"jsonrpc\"])\n+\tassert.Equal(t, \"notifications/tools/list_changed\", notif[\"method\"])\n+}\n+\n+func TestConvertChannelEvent_Progress(t *testing.T) {\n+\tprogress := float64(50)\n+\ttotal := float64(100)\n+\tresp := &mcpv1.ChannelResponse{\n+\t\tPayload: &mcpv1.ChannelResponse_Progress{\n+\t\t\tProgress: &mcpv1.ProgressNotification{\n+\t\t\t\tProgressToken: \"tok-1\",\n+\t\t\t\tProgress:      proto.Float64(progress),\n+\t\t\t\tTotal:         proto.Float64(total),\n+\t\t\t\tMessage:       \"processing\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tdata := convertChannelEvent(resp)\n+\trequire.NotNil(t, data)\n+\n+\tvar notif map[string]any\n+\trequire.NoError(t, json.Unmarshal(data, &notif))\n+\tassert.Equal(t, \"notifications/progress\", notif[\"method\"])\n+\n+\tparams := notif[\"params\"].(map[string]any)\n+\tassert.Equal(t, \"tok-1\", params[\"progressToken\"])\n+\tassert.Equal(t, progress, params[\"progress\"])\n+\tassert.Equal(t, total, params[\"total\"])\n+\tassert.Equal(t, \"processing\", params[\"message\"])\n+}\n+\n+func TestConvertChannelEvent_LoggingMessage(t *testing.T) {\n+\tresp := &mcpv1.ChannelResponse{\n+\t\tPayload: &mcpv1.ChannelResponse_LoggingMessage{\n+\t\t\tLoggingMessage: &mcpv1.LoggingMessageEvent{\n+\t\t\t\tLevel:    \"info\",\n+\t\t\t\tLogger:   \"test-logger\",\n+\t\t\t\tDataJson: `{\"key\":\"value\"}`,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tdata := convertChannelEvent(resp)\n+\trequire.NotNil(t, data)\n+\n+\tvar notif map[string]any\n+\trequire.NoError(t, json.Unmarshal(data, &notif))\n+\tassert.Equal(t, \"notifications/message\", notif[\"method\"])\n+\n+\tparams := notif[\"params\"].(map[string]any)\n+\tassert.Equal(t, \"info\", params[\"level\"])\n+\tassert.Equal(t, \"test-logger\", params[\"logger\"])\n+\tassert.NotNil(t, params[\"data\"])\n+}\n+\n+func TestConvertChannelEvent_Pong_ReturnsNil(t *testing.T) {\n+\tresp := &mcpv1.ChannelResponse{\n+\t\tPayload: &mcpv1.ChannelResponse_Pong{\n+\t\t\tPong: &mcpv1.PongPayload{},\n+\t\t},\n+\t}\n+\n+\tdata := convertChannelEvent(resp)\n+\tassert.Nil(t, data)\n+}\n+\n+func TestConvertChannelEvent_Error_ReturnsNil(t *testing.T) {\n+\tresp := &mcpv1.ChannelResponse{\n+\t\tPayload: &mcpv1.ChannelResponse_Error{\n+\t\t\tError: &mcpv1.ErrorResponse{Code: 500, Message: \"error\"},\n+\t\t},\n+\t}\n+\n+\tdata := convertChannelEvent(resp)\n+\tassert.Nil(t, data)\n+}\ndiff --git a/mcp-proxy/internal/mcp/handler.go b/mcp-proxy/internal/mcp/handler.go\nnew file mode 100644\nindex 000000000..afd9c5be2\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/handler.go\n@@ -0,0 +1,364 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\t\"mcp-proxy/pkg/jsonrpc\"\n+\n+\t\"github.com/rs/zerolog\"\n+)\n+\n+type contextKey string\n+\n+const authInfoKey contextKey = \"authInfo\"\n+\n+// Handler routes HTTP requests to the appropriate MCP protocol handler.\n+type Handler struct {\n+\tsessions            *SessionManager\n+\tlazy                *LazyConnector\n+\tauth                *AccessKeyVerifier\n+\tevents              EventSubscriber\n+\taddrPicker          AddrPicker\n+\tpingInterval        time.Duration\n+\tmaxRequestBodyBytes int64\n+\tlogger              zerolog.Logger\n+}\n+\n+// NewHandler creates an MCP HTTP handler.\n+// auth and events may be nil to disable those features.\n+// maxRequestBodyMB limits the request body size in megabytes (0 = no limit).\n+func NewHandler(sessions *SessionManager, lazy *LazyConnector, auth *AccessKeyVerifier, events EventSubscriber, addrPicker AddrPicker, pingInterval time.Duration, maxRequestBodyMB int, logger zerolog.Logger) *Handler {\n+\tvar maxBytes int64\n+\tif maxRequestBodyMB > 0 {\n+\t\tmaxBytes = int64(maxRequestBodyMB) * 1024 * 1024\n+\t}\n+\treturn &Handler{\n+\t\tsessions:            sessions,\n+\t\tlazy:                lazy,\n+\t\tauth:                auth,\n+\t\tevents:              events,\n+\t\taddrPicker:          addrPicker,\n+\t\tpingInterval:        pingInterval,\n+\t\tmaxRequestBodyBytes: maxBytes,\n+\t\tlogger:              logger,\n+\t}\n+}\n+\n+// ServeHTTP dispatches incoming HTTP requests by method and path.\n+func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n+\t// Health check — no auth required\n+\tif r.URL.Path == \"/health\" {\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write([]byte(\"ok\"))\n+\t\treturn\n+\t}\n+\n+\t// Authentication\n+\tif h.auth != nil {\n+\t\tauthHeader := r.Header.Get(\"Authorization\")\n+\t\tif authHeader == \"\" {\n+\t\t\thttp.Error(w, \"missing Authorization header\", http.StatusUnauthorized)\n+\t\t\treturn\n+\t\t}\n+\n+\t\ttoken, err := ParseBearerToken(authHeader)\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, \"invalid Authorization header\", http.StatusUnauthorized)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tpresetID := extractPresetID(r.URL.Path)\n+\t\tinfo, err := h.auth.Verify(r.Context(), token, presetID)\n+\t\tif err != nil {\n+\t\t\th.logger.Warn().Err(err).Str(\"presetID\", presetID).Msg(\"auth failed\")\n+\t\t\thttp.Error(w, \"unauthorized\", http.StatusUnauthorized)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tr = r.WithContext(context.WithValue(r.Context(), authInfoKey, info))\n+\t}\n+\n+\tswitch r.Method {\n+\tcase http.MethodPost:\n+\t\th.handlePost(w, r)\n+\tcase http.MethodGet:\n+\t\th.handleSSE(w, r)\n+\tcase http.MethodDelete:\n+\t\th.handleDelete(w, r)\n+\tdefault:\n+\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t}\n+}\n+\n+func (h *Handler) handlePost(w http.ResponseWriter, r *http.Request) {\n+\tif h.maxRequestBodyBytes > 0 {\n+\t\tr.Body = http.MaxBytesReader(w, r.Body, h.maxRequestBodyBytes)\n+\t}\n+\n+\tbody, err := io.ReadAll(r.Body)\n+\tif err != nil {\n+\t\th.writeError(w, nil, jsonrpc.InternalError, \"failed to read request body\")\n+\t\treturn\n+\t}\n+\n+\treq, err := jsonrpc.Parse(body)\n+\tif err != nil {\n+\t\th.writeError(w, nil, jsonrpc.ParseError, \"Parse error\")\n+\t\treturn\n+\t}\n+\n+\tbaseURL := r.URL.Path\n+\n+\tswitch req.Method {\n+\tcase \"initialize\":\n+\t\th.handleInitialize(w, r, req, baseURL)\n+\tdefault:\n+\t\th.handleWithSession(w, r, req)\n+\t}\n+}\n+\n+func (h *Handler) handleInitialize(w http.ResponseWriter, r *http.Request, req *jsonrpc.Request, baseURL string) {\n+\taddr, err := h.addrPicker.PickAddr()\n+\tif err != nil {\n+\t\th.writeError(w, req.ID, jsonrpc.InternalError, \"no backend available\")\n+\t\treturn\n+\t}\n+\n+\tsession := h.sessions.Create(baseURL, addr)\n+\n+\tcaps, serverInfo, protoVersion := h.lazy.HandleInitialize()\n+\n+\tresult := map[string]any{\n+\t\t\"protocolVersion\": protoVersion,\n+\t\t\"capabilities\":    caps,\n+\t\t\"serverInfo\":      serverInfo,\n+\t}\n+\n+\tw.Header().Set(\"Mcp-Session-Id\", session.ID)\n+\th.writeResult(w, req.ID, result)\n+}\n+\n+func (h *Handler) handleWithSession(w http.ResponseWriter, r *http.Request, req *jsonrpc.Request) {\n+\tsessionID := r.Header.Get(\"Mcp-Session-Id\")\n+\tsession := h.sessions.Get(sessionID)\n+\tif session == nil {\n+\t\th.writeError(w, req.ID, jsonrpc.InvalidRequest, \"invalid or missing session\")\n+\t\treturn\n+\t}\n+\n+\tsession.Touch()\n+\n+\t// Handle notifications (no id)\n+\tif req.IsNotification() {\n+\t\tw.WriteHeader(http.StatusAccepted)\n+\t\treturn\n+\t}\n+\n+\tswitch req.Method {\n+\tcase \"tools/list\":\n+\t\th.handleToolsList(w, r, req, session)\n+\tcase \"tools/call\":\n+\t\th.handleToolsCall(w, r, req, session)\n+\tcase \"ping\":\n+\t\th.handlePing(w, req)\n+\tdefault:\n+\t\th.writeError(w, req.ID, jsonrpc.MethodNotFound, \"Method not found: \"+req.Method)\n+\t}\n+}\n+\n+func (h *Handler) handleToolsList(w http.ResponseWriter, r *http.Request, req *jsonrpc.Request, session *Session) {\n+\ttools, err := h.lazy.HandleListTools(r.Context(), session)\n+\tif err != nil {\n+\t\th.logger.Error().Err(err).Str(\"session\", session.ID).Msg(\"failed to list tools\")\n+\t\th.writeError(w, req.ID, jsonrpc.InternalError, \"failed to list tools\")\n+\t\treturn\n+\t}\n+\n+\tmcpTools := make([]map[string]any, 0, len(tools))\n+\tfor _, t := range tools {\n+\t\ttool := map[string]any{\n+\t\t\t\"name\":        t.Name,\n+\t\t\t\"description\": t.Description,\n+\t\t}\n+\t\tif t.InputSchemaJson != \"\" {\n+\t\t\tvar schema any\n+\t\t\tif err := json.Unmarshal([]byte(t.InputSchemaJson), &schema); err == nil {\n+\t\t\t\ttool[\"inputSchema\"] = schema\n+\t\t\t}\n+\t\t}\n+\t\tmcpTools = append(mcpTools, tool)\n+\t}\n+\n+\th.writeResult(w, req.ID, map[string]any{\"tools\": mcpTools})\n+}\n+\n+func (h *Handler) handleToolsCall(w http.ResponseWriter, r *http.Request, req *jsonrpc.Request, session *Session) {\n+\tif req.Params == nil {\n+\t\th.writeError(w, req.ID, jsonrpc.InvalidParams, \"missing params\")\n+\t\treturn\n+\t}\n+\n+\tvar params struct {\n+\t\tName      string          `json:\"name\"`\n+\t\tArguments json.RawMessage `json:\"arguments\"`\n+\t\tMeta      map[string]any  `json:\"_meta,omitempty\"`\n+\t}\n+\tif err := json.Unmarshal(*req.Params, &params); err != nil {\n+\t\th.writeError(w, req.ID, jsonrpc.InvalidParams, \"invalid params\")\n+\t\treturn\n+\t}\n+\tif params.Name == \"\" {\n+\t\th.writeError(w, req.ID, jsonrpc.InvalidParams, \"missing tool name\")\n+\t\treturn\n+\t}\n+\n+\targsJSON := \"{}\"\n+\tif len(params.Arguments) > 0 {\n+\t\targsJSON = string(params.Arguments)\n+\t}\n+\n+\tresult, err := h.lazy.HandleCallTool(r.Context(), session, params.Name, argsJSON, params.Meta)\n+\tif err != nil {\n+\t\th.logger.Error().Err(err).Str(\"session\", session.ID).Str(\"tool\", params.Name).Msg(\"failed to call tool\")\n+\t\th.writeError(w, req.ID, jsonrpc.InternalError, \"failed to call tool\")\n+\t\treturn\n+\t}\n+\n+\th.writeResult(w, req.ID, convertCallToolResult(result))\n+}\n+\n+func convertCallToolResult(result *mcpv1.CallToolResult) map[string]any {\n+\tcontent := make([]map[string]any, 0, len(result.Content))\n+\tfor _, c := range result.Content {\n+\t\tswitch v := c.Content.(type) {\n+\t\tcase *mcpv1.Content_Text:\n+\t\t\tcontent = append(content, map[string]any{\"type\": \"text\", \"text\": v.Text.Text})\n+\t\tcase *mcpv1.Content_Image:\n+\t\t\tcontent = append(content, map[string]any{\"type\": \"image\", \"data\": v.Image.Data, \"mimeType\": v.Image.MimeType})\n+\t\t}\n+\t}\n+\tresp := map[string]any{\"content\": content}\n+\tif result.IsError {\n+\t\tresp[\"isError\"] = true\n+\t}\n+\treturn resp\n+}\n+\n+func (h *Handler) handlePing(w http.ResponseWriter, req *jsonrpc.Request) {\n+\th.writeResult(w, req.ID, map[string]any{})\n+}\n+\n+func (h *Handler) handleDelete(w http.ResponseWriter, r *http.Request) {\n+\tsessionID := r.Header.Get(\"Mcp-Session-Id\")\n+\tsession := h.sessions.Get(sessionID)\n+\tif session == nil {\n+\t\thttp.Error(w, \"invalid or missing session\", http.StatusBadRequest)\n+\t\treturn\n+\t}\n+\n+\tif err := h.lazy.HandleCloseSession(r.Context(), session); err != nil {\n+\t\th.logger.Error().Err(err).Str(\"session\", session.ID).Msg(\"failed to close backend session\")\n+\t}\n+\n+\th.sessions.Close(sessionID)\n+\tw.WriteHeader(http.StatusOK)\n+}\n+\n+func (h *Handler) handleSSE(w http.ResponseWriter, r *http.Request) {\n+\tsessionID := r.Header.Get(\"Mcp-Session-Id\")\n+\tsession := h.sessions.Get(sessionID)\n+\tif session == nil {\n+\t\thttp.Error(w, \"invalid or missing session\", http.StatusBadRequest)\n+\t\treturn\n+\t}\n+\n+\tsession.Touch()\n+\n+\tif h.events == nil {\n+\t\thttp.Error(w, \"SSE not available\", http.StatusNotImplemented)\n+\t\treturn\n+\t}\n+\n+\tif !session.IsInitialized() {\n+\t\thttp.Error(w, \"session not initialized\", http.StatusBadRequest)\n+\t\treturn\n+\t}\n+\n+\tsse, err := NewSSEWriter(w)\n+\tif err != nil {\n+\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\treturn\n+\t}\n+\n+\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n+\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n+\tw.Header().Set(\"Connection\", \"keep-alive\")\n+\n+\tctx, cancel := context.WithCancel(r.Context())\n+\tdefer cancel()\n+\n+\t// Ping goroutine — must start after IsInitialized check to avoid race.\n+\tif h.pingInterval > 0 {\n+\t\tgo func() {\n+\t\t\tticker := time.NewTicker(h.pingInterval)\n+\t\t\tdefer ticker.Stop()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-ctx.Done():\n+\t\t\t\t\treturn\n+\t\t\t\tcase <-ticker.C:\n+\t\t\t\t\tif err := sse.WritePing(); err != nil {\n+\t\t\t\t\t\tcancel()\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.Touch()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\tif err := h.events.Subscribe(ctx, session.ID, func(data []byte) {\n+\t\tif writeErr := sse.WriteEvent(data); writeErr != nil {\n+\t\t\tcancel()\n+\t\t\treturn\n+\t\t}\n+\t\tsession.Touch()\n+\t}); err != nil {\n+\t\th.logger.Error().Err(err).Str(\"session\", session.ID).Msg(\"SSE subscribe error\")\n+\t}\n+}\n+\n+func (h *Handler) writeResult(w http.ResponseWriter, id *json.RawMessage, result any) {\n+\tresultBytes, err := json.Marshal(result)\n+\tif err != nil {\n+\t\th.writeError(w, id, jsonrpc.InternalError, \"failed to marshal result\")\n+\t\treturn\n+\t}\n+\traw := json.RawMessage(resultBytes)\n+\tresp := jsonrpc.NewResponse(id, raw)\n+\n+\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\tjson.NewEncoder(w).Encode(resp)\n+}\n+\n+func (h *Handler) writeError(w http.ResponseWriter, id *json.RawMessage, code int, message string) {\n+\tresp := jsonrpc.NewErrorResponse(id, code, message, nil)\n+\n+\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\tjson.NewEncoder(w).Encode(resp)\n+}\n+\n+// extractPresetID parses the preset ID from \"/presets/{id}/mcp\".\n+func extractPresetID(path string) string {\n+\tparts := strings.Split(strings.Trim(path, \"/\"), \"/\")\n+\tif len(parts) >= 2 && parts[0] == \"presets\" {\n+\t\treturn parts[1]\n+\t}\n+\treturn \"\"\n+}\ndiff --git a/mcp-proxy/internal/mcp/handler_test.go b/mcp-proxy/internal/mcp/handler_test.go\nnew file mode 100644\nindex 000000000..a3c9a56ac\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/handler_test.go\n@@ -0,0 +1,653 @@\n+package mcp\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\t\"mcp-proxy/pkg/jsonrpc\"\n+\n+\t\"github.com/rs/zerolog\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+// mockAddrPicker always returns a fixed address.\n+type mockAddrPicker struct {\n+\taddr string\n+\terr  error\n+}\n+\n+func (m *mockAddrPicker) PickAddr() (string, error) {\n+\tif m.err != nil {\n+\t\treturn \"\", m.err\n+\t}\n+\treturn m.addr, nil\n+}\n+\n+func setupTestHandler() (*Handler, *mockBackendClient) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tmgr := NewSessionManager(testProxyID)\n+\tlc := NewLazyConnector(router)\n+\tpicker := &mockAddrPicker{addr: testBackendAddr}\n+\tlogger := zerolog.Nop()\n+\treturn NewHandler(mgr, lc, nil, nil, picker, 0, 0, logger), mock\n+}\n+\n+func setupTestHandlerWithAuth() (*Handler, *mockBackendClient) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tmgr := NewSessionManager(testProxyID)\n+\tlc := NewLazyConnector(router)\n+\tauth := NewAccessKeyVerifier(mock, 5*time.Minute)\n+\tpicker := &mockAddrPicker{addr: testBackendAddr}\n+\tlogger := zerolog.Nop()\n+\treturn NewHandler(mgr, lc, auth, nil, picker, 0, 0, logger), mock\n+}\n+\n+func doPost(handler http.Handler, path string, body []byte, headers map[string]string) *httptest.ResponseRecorder {\n+\treq := httptest.NewRequest(http.MethodPost, path, bytes.NewReader(body))\n+\treq.Header.Set(\"Content-Type\", \"application/json\")\n+\tfor k, v := range headers {\n+\t\treq.Header.Set(k, v)\n+\t}\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\treturn rec\n+}\n+\n+func initSession(t *testing.T, handler *Handler) string {\n+\tt.Helper()\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), nil)\n+\tsessionID := rec.Header().Get(\"Mcp-Session-Id\")\n+\trequire.NotEmpty(t, sessionID)\n+\treturn sessionID\n+}\n+\n+func initSessionWithAuth(t *testing.T, handler *Handler) string {\n+\tt.Helper()\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Authorization\": \"Bearer valid-key\",\n+\t})\n+\tsessionID := rec.Header().Get(\"Mcp-Session-Id\")\n+\trequire.NotEmpty(t, sessionID)\n+\treturn sessionID\n+}\n+\n+// --- Existing tests (no auth) ---\n+\n+func TestHandler_Initialize(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), nil)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tsessionID := rec.Header().Get(\"Mcp-Session-Id\")\n+\tassert.NotEmpty(t, sessionID)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.Equal(t, \"2.0\", resp.JSONRPC)\n+\tassert.Nil(t, resp.Error)\n+\tassert.NotNil(t, resp.Result)\n+\n+\tvar result map[string]any\n+\trequire.NoError(t, json.Unmarshal(*resp.Result, &result))\n+\tassert.Contains(t, result, \"serverInfo\")\n+\tassert.Contains(t, result, \"capabilities\")\n+\tassert.Contains(t, result, \"protocolVersion\")\n+}\n+\n+func TestHandler_Initialize_NoBackends(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tmgr := NewSessionManager(testProxyID)\n+\tlc := NewLazyConnector(router)\n+\tpicker := &mockAddrPicker{err: fmt.Errorf(\"no backend available\")}\n+\tlogger := zerolog.Nop()\n+\thandler := NewHandler(mgr, lc, nil, nil, picker, 0, 0, logger)\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), nil)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\trequire.NotNil(t, resp.Error)\n+\tassert.Equal(t, jsonrpc.InternalError, resp.Error.Code)\n+\tassert.Contains(t, resp.Error.Message, \"no backend available\")\n+}\n+\n+func TestHandler_ToolsList(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\ttoolsBody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/list\"}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(toolsBody), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.Nil(t, resp.Error)\n+\tassert.NotNil(t, resp.Result)\n+\n+\tvar result map[string]any\n+\trequire.NoError(t, json.Unmarshal(*resp.Result, &result))\n+\tassert.Contains(t, result, \"tools\")\n+}\n+\n+func TestHandler_Ping(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tpingBody := `{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"ping\"}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(pingBody), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.Nil(t, resp.Error)\n+\tassert.NotNil(t, resp.Result)\n+\n+\tvar result map[string]any\n+\trequire.NoError(t, json.Unmarshal(*resp.Result, &result))\n+\tassert.Empty(t, result)\n+}\n+\n+func TestHandler_NotificationInitialized(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tnotifBody := `{\"jsonrpc\":\"2.0\",\"method\":\"notifications/initialized\"}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(notifBody), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tassert.Equal(t, http.StatusAccepted, rec.Code)\n+\n+\tbody, _ := io.ReadAll(rec.Body)\n+\tassert.Empty(t, body)\n+}\n+\n+func TestHandler_UnknownMethod(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":4,\"method\":\"unknown/method\"}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.NotNil(t, resp.Error)\n+\tassert.Equal(t, jsonrpc.MethodNotFound, resp.Error.Code)\n+}\n+\n+func TestHandler_InvalidSession(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/list\"}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": \"nonexistent-session\",\n+\t})\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.NotNil(t, resp.Error)\n+\tassert.Equal(t, jsonrpc.InvalidRequest, resp.Error.Code)\n+}\n+\n+func TestHandler_InvalidJSON(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(`{invalid`), nil)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.NotNil(t, resp.Error)\n+\tassert.Equal(t, jsonrpc.ParseError, resp.Error.Code)\n+}\n+\n+func TestHandler_Health(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/health\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\tassert.Equal(t, \"ok\", rec.Body.String())\n+}\n+\n+// --- tools/call tests ---\n+\n+func TestHandler_ToolsCall(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"myTool\",\"arguments\":{\"key\":\"value\"}}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.Nil(t, resp.Error)\n+\trequire.NotNil(t, resp.Result)\n+\n+\tvar result map[string]any\n+\trequire.NoError(t, json.Unmarshal(*resp.Result, &result))\n+\tassert.Contains(t, result, \"content\")\n+\n+\tcontent := result[\"content\"].([]any)\n+\trequire.Len(t, content, 1)\n+\titem := content[0].(map[string]any)\n+\tassert.Equal(t, \"text\", item[\"type\"])\n+\tassert.Equal(t, \"result\", item[\"text\"])\n+}\n+\n+func TestHandler_ToolsCall_MissingName(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"arguments\":{}}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\trequire.NotNil(t, resp.Error)\n+\tassert.Equal(t, jsonrpc.InvalidParams, resp.Error.Code)\n+}\n+\n+func TestHandler_ToolsCall_IsError(t *testing.T) {\n+\thandler, mock := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tmock.callToolFn = func(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\t\treturn &mcpv1.CallToolResult{\n+\t\t\tContent: []*mcpv1.Content{\n+\t\t\t\t{Content: &mcpv1.Content_Text{Text: &mcpv1.TextContent{Text: \"error occurred\"}}},\n+\t\t\t},\n+\t\t\tIsError: true,\n+\t\t}, nil\n+\t}\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"failTool\",\"arguments\":{}}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\tassert.Nil(t, resp.Error)\n+\trequire.NotNil(t, resp.Result)\n+\n+\tvar result map[string]any\n+\trequire.NoError(t, json.Unmarshal(*resp.Result, &result))\n+\tassert.Equal(t, true, result[\"isError\"])\n+}\n+\n+func TestHandler_ToolsCall_MissingParams(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\"}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tvar resp jsonrpc.Response\n+\trequire.NoError(t, json.NewDecoder(rec.Body).Decode(&resp))\n+\trequire.NotNil(t, resp.Error)\n+\tassert.Equal(t, jsonrpc.InvalidParams, resp.Error.Code)\n+}\n+\n+// --- Auth tests ---\n+\n+func TestHandler_Auth_NoAuthHeader(t *testing.T) {\n+\thandler, _ := setupTestHandlerWithAuth()\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), nil)\n+\n+\tassert.Equal(t, http.StatusUnauthorized, rec.Code)\n+}\n+\n+func TestHandler_Auth_InvalidToken(t *testing.T) {\n+\thandler, mock := setupTestHandlerWithAuth()\n+\tmock.verifyAccessKeyFn = func(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\t\treturn &mcpv1.VerifyAccessKeyResponse{Valid: false}, nil\n+\t}\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Authorization\": \"Bearer bad-key\",\n+\t})\n+\n+\tassert.Equal(t, http.StatusUnauthorized, rec.Code)\n+}\n+\n+func TestHandler_Auth_ValidToken(t *testing.T) {\n+\thandler, _ := setupTestHandlerWithAuth()\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Authorization\": \"Bearer valid-key\",\n+\t})\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\tassert.NotEmpty(t, rec.Header().Get(\"Mcp-Session-Id\"))\n+}\n+\n+func TestHandler_Auth_HealthBypassesAuth(t *testing.T) {\n+\thandler, _ := setupTestHandlerWithAuth()\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/health\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\tassert.Equal(t, \"ok\", rec.Body.String())\n+}\n+\n+func TestHandler_Auth_ExtractPresetID(t *testing.T) {\n+\thandler, mock := setupTestHandlerWithAuth()\n+\tvar capturedPresetID string\n+\tmock.verifyAccessKeyFn = func(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\t\tcapturedPresetID = req.PresetId\n+\t\treturn &mcpv1.VerifyAccessKeyResponse{Valid: true, UserId: \"u1\", DeviceId: \"d1\"}, nil\n+\t}\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\tdoPost(handler, \"/presets/my-preset-id/mcp\", []byte(body), map[string]string{\n+\t\t\"Authorization\": \"Bearer key-1\",\n+\t})\n+\n+\tassert.Equal(t, \"my-preset-id\", capturedPresetID)\n+}\n+\n+func TestHandler_Auth_MissingBearerPrefix(t *testing.T) {\n+\thandler, _ := setupTestHandlerWithAuth()\n+\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Authorization\": \"Basic abc\",\n+\t})\n+\n+\tassert.Equal(t, http.StatusUnauthorized, rec.Code)\n+}\n+\n+// --- DELETE tests ---\n+\n+func TestHandler_Delete(t *testing.T) {\n+\thandler, mock := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\t// Force backend session initialization via tools/list\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/list\"}`\n+\tdoPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\treq := httptest.NewRequest(http.MethodDelete, \"/presets/test-uuid/mcp\", nil)\n+\treq.Header.Set(\"Mcp-Session-Id\", sessionID)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\tassert.Equal(t, 1, mock.calls[\"CloseSession\"])\n+}\n+\n+func TestHandler_Delete_NoSession(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\treq := httptest.NewRequest(http.MethodDelete, \"/presets/test-uuid/mcp\", nil)\n+\treq.Header.Set(\"Mcp-Session-Id\", \"nonexistent\")\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusBadRequest, rec.Code)\n+}\n+\n+func TestHandler_Delete_BackendError(t *testing.T) {\n+\thandler, mock := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\t// Initialize backend\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/list\"}`\n+\tdoPost(handler, \"/presets/test-uuid/mcp\", []byte(body), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tmock.closeSessionFn = func(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error) {\n+\t\treturn nil, fmt.Errorf(\"backend unavailable\")\n+\t}\n+\n+\treq := httptest.NewRequest(http.MethodDelete, \"/presets/test-uuid/mcp\", nil)\n+\treq.Header.Set(\"Mcp-Session-Id\", sessionID)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\t// Still returns 200, local session is cleaned up\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\t// Session should be gone locally\n+\tsession := handler.sessions.Get(sessionID)\n+\tassert.Nil(t, session)\n+}\n+\n+// --- SSE tests ---\n+\n+func TestHandler_SSE_NoSession(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/presets/test/mcp\", nil)\n+\treq.Header.Set(\"Mcp-Session-Id\", \"nonexistent\")\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusBadRequest, rec.Code)\n+}\n+\n+func TestHandler_SSE_NoEventsSubscriber(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\tsessionID := initSession(t, handler)\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/presets/test/mcp\", nil)\n+\treq.Header.Set(\"Mcp-Session-Id\", sessionID)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusNotImplemented, rec.Code)\n+}\n+\n+// --- SSE Touch tests ---\n+\n+// mockEventSubscriber implements EventSubscriber for testing.\n+type mockEventSubscriber struct {\n+\tonSubscribe func(ctx context.Context, sessionID string, callback func([]byte)) error\n+}\n+\n+func (m *mockEventSubscriber) Subscribe(ctx context.Context, sessionID string, callback func([]byte)) error {\n+\treturn m.onSubscribe(ctx, sessionID, callback)\n+}\n+\n+func setupTestHandlerWithEvents(events EventSubscriber, pingInterval time.Duration) (*Handler, *SessionManager) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tmgr := NewSessionManager(testProxyID)\n+\tlc := NewLazyConnector(router)\n+\tpicker := &mockAddrPicker{addr: testBackendAddr}\n+\tlogger := zerolog.Nop()\n+\treturn NewHandler(mgr, lc, nil, events, picker, pingInterval, 0, logger), mgr\n+}\n+\n+// initSSESession initializes a session and triggers backend initialization via tools/list.\n+func initSSESession(t *testing.T, handler *Handler, mgr *SessionManager) (string, *Session) {\n+\tt.Helper()\n+\tbody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`\n+\trec := doPost(handler, \"/presets/test-uuid/mcp\", []byte(body), nil)\n+\tsessionID := rec.Header().Get(\"Mcp-Session-Id\")\n+\trequire.NotEmpty(t, sessionID)\n+\n+\t// Trigger EnsureInitialized via tools/list\n+\ttoolsBody := `{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/list\"}`\n+\tdoPost(handler, \"/presets/test-uuid/mcp\", []byte(toolsBody), map[string]string{\n+\t\t\"Mcp-Session-Id\": sessionID,\n+\t})\n+\n+\tsession := mgr.Get(sessionID)\n+\trequire.NotNil(t, session)\n+\trequire.True(t, session.IsInitialized())\n+\treturn sessionID, session\n+}\n+\n+func TestHandler_SSE_TouchesSessionOnPing(t *testing.T) {\n+\tevents := &mockEventSubscriber{\n+\t\tonSubscribe: func(ctx context.Context, _ string, _ func([]byte)) error {\n+\t\t\t<-ctx.Done()\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\n+\thandler, mgr := setupTestHandlerWithEvents(events, 50*time.Millisecond)\n+\tsessionID, session := initSSESession(t, handler, mgr)\n+\n+\t// Set lastAccessAt to 1 hour ago\n+\tsession.mu.Lock()\n+\tsession.lastAccessAt = time.Now().Add(-1 * time.Hour)\n+\tsession.mu.Unlock()\n+\n+\t// Run SSE with timeout\n+\tctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)\n+\tdefer cancel()\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/presets/test-uuid/mcp\", nil).WithContext(ctx)\n+\treq.Header.Set(\"Mcp-Session-Id\", sessionID)\n+\tsseRec := httptest.NewRecorder()\n+\thandler.ServeHTTP(sseRec, req)\n+\n+\t// After pings, lastAccessAt should have been updated to recent time\n+\tassert.WithinDuration(t, time.Now(), session.LastAccessAt(), 5*time.Second)\n+}\n+\n+func TestHandler_SSE_TouchesSessionOnEvent(t *testing.T) {\n+\tevents := &mockEventSubscriber{\n+\t\tonSubscribe: func(ctx context.Context, _ string, callback func([]byte)) error {\n+\t\t\t// Send one event immediately\n+\t\t\tcallback([]byte(`{\"jsonrpc\":\"2.0\",\"method\":\"notifications/tools/list_changed\"}`))\n+\t\t\t<-ctx.Done()\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\n+\thandler, mgr := setupTestHandlerWithEvents(events, 0)\n+\tsessionID, session := initSSESession(t, handler, mgr)\n+\n+\t// Set lastAccessAt to 1 hour ago\n+\tsession.mu.Lock()\n+\tsession.lastAccessAt = time.Now().Add(-1 * time.Hour)\n+\tsession.mu.Unlock()\n+\n+\t// Run SSE with timeout\n+\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n+\tdefer cancel()\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/presets/test-uuid/mcp\", nil).WithContext(ctx)\n+\treq.Header.Set(\"Mcp-Session-Id\", sessionID)\n+\tsseRec := httptest.NewRecorder()\n+\thandler.ServeHTTP(sseRec, req)\n+\n+\t// After event callback, lastAccessAt should have been updated\n+\tassert.WithinDuration(t, time.Now(), session.LastAccessAt(), 5*time.Second)\n+}\n+\n+func TestHandler_SSE_SessionNotEvictedDuringActiveConnection(t *testing.T) {\n+\tevents := &mockEventSubscriber{\n+\t\tonSubscribe: func(ctx context.Context, _ string, _ func([]byte)) error {\n+\t\t\t<-ctx.Done()\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\n+\thandler, mgr := setupTestHandlerWithEvents(events, 50*time.Millisecond)\n+\tsessionID, session := initSSESession(t, handler, mgr)\n+\n+\tsessionTTL := 500 * time.Millisecond\n+\n+\t// Set lastAccessAt to just before TTL expiry\n+\tsession.mu.Lock()\n+\tsession.lastAccessAt = time.Now().Add(-sessionTTL + 100*time.Millisecond)\n+\tsession.mu.Unlock()\n+\n+\t// Run SSE in background (pings will Touch the session)\n+\tctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)\n+\tdefer cancel()\n+\n+\tdone := make(chan struct{})\n+\tgo func() {\n+\t\treq := httptest.NewRequest(http.MethodGet, \"/presets/test-uuid/mcp\", nil).WithContext(ctx)\n+\t\treq.Header.Set(\"Mcp-Session-Id\", sessionID)\n+\t\tsseRec := httptest.NewRecorder()\n+\t\thandler.ServeHTTP(sseRec, req)\n+\t\tclose(done)\n+\t}()\n+\n+\t// Wait for at least one ping to Touch the session\n+\ttime.Sleep(100 * time.Millisecond)\n+\n+\t// Try to evict — session should survive because ping has refreshed it\n+\terrs := mgr.EvictExpired(sessionTTL, nil)\n+\tassert.Empty(t, errs)\n+\tassert.NotNil(t, mgr.Get(sessionID), \"active SSE session should not be evicted\")\n+\n+\tcancel()\n+\t<-done\n+}\n+\n+// --- extractPresetID ---\n+\n+func TestExtractPresetID(t *testing.T) {\n+\ttests := []struct {\n+\t\tpath string\n+\t\twant string\n+\t}{\n+\t\t{\"/presets/abc-123/mcp\", \"abc-123\"},\n+\t\t{\"/presets/uuid/mcp/extra\", \"uuid\"},\n+\t\t{\"/other/path\", \"\"},\n+\t\t{\"/presets/\", \"\"},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tassert.Equal(t, tt.want, extractPresetID(tt.path), \"path=%s\", tt.path)\n+\t}\n+}\ndiff --git a/mcp-proxy/internal/mcp/lazy.go b/mcp-proxy/internal/mcp/lazy.go\nnew file mode 100644\nindex 000000000..e80720787\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/lazy.go\n@@ -0,0 +1,168 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\t\"mcp-proxy/pkg/sessionid\"\n+\n+\t\"google.golang.org/protobuf/types/known/structpb\"\n+)\n+\n+const maxRecoveryRetries = 1 // 1 retry (2 total attempts)\n+\n+// LazyConnector defers backend session creation until the first tool-related request.\n+// It routes each RPC to the backend encoded in the session ID.\n+type LazyConnector struct {\n+\trouter BackendRouter\n+}\n+\n+// NewLazyConnector creates a connector backed by the given router.\n+func NewLazyConnector(router BackendRouter) *LazyConnector {\n+\treturn &LazyConnector{router: router}\n+}\n+\n+// HandleInitialize returns fixed server capabilities without contacting the backend.\n+func (lc *LazyConnector) HandleInitialize() (*mcpv1.ServerCapabilities, *mcpv1.ServerInfo, string) {\n+\treturn &mcpv1.ServerCapabilities{\n+\t\t\tTools:   &mcpv1.ToolsCapability{ListChanged: true},\n+\t\t\tLogging: &mcpv1.LoggingCapability{},\n+\t\t},\n+\t\t&mcpv1.ServerInfo{Name: \"duplo-mcp-proxy\", Version: \"1.0.0\"},\n+\t\t\"2025-03-26\"\n+}\n+\n+// HandleListTools returns tools for the session, lazily initializing the backend if needed.\n+// Each call fetches from the backend — no caching.\n+// If the backend returns \"session not found\", the session is re-initialized and retried.\n+func (lc *LazyConnector) HandleListTools(ctx context.Context, session *Session) ([]*mcpv1.Tool, error) {\n+\tif err := session.EnsureInitialized(ctx, lc.initBackendSession); err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to create backend session: %w\", err)\n+\t}\n+\n+\tvar tools []*mcpv1.Tool\n+\terr := lc.withRecovery(ctx, session, func(client BackendClient) error {\n+\t\tresp, err := client.ListTools(ctx, &mcpv1.ListToolsRequest{\n+\t\t\tSessionId: session.ID,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ttools = resp.Tools\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to list tools: %w\", err)\n+\t}\n+\n+\treturn tools, nil\n+}\n+\n+// HandleCallTool invokes a tool via the Send RPC, lazily initializing the backend if needed.\n+// If the backend returns \"session not found\", the session is re-initialized and retried.\n+func (lc *LazyConnector) HandleCallTool(ctx context.Context, session *Session, name, argsJSON string, meta map[string]any) (*mcpv1.CallToolResult, error) {\n+\tif err := session.EnsureInitialized(ctx, lc.initBackendSession); err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to create backend session: %w\", err)\n+\t}\n+\n+\tpayload := &mcpv1.CallToolPayload{Name: name, ArgumentsJson: argsJSON}\n+\tif len(meta) > 0 {\n+\t\ts, err := structpb.NewStruct(meta)\n+\t\tif err == nil {\n+\t\t\tpayload.Meta = s\n+\t\t}\n+\t}\n+\n+\tvar result *mcpv1.CallToolResult\n+\terr := lc.withRecovery(ctx, session, func(client BackendClient) error {\n+\t\tvar err error\n+\t\tresult, err = client.CallTool(ctx, &mcpv1.CallToolSendRequest{\n+\t\t\tSessionId: session.ID,\n+\t\t\tPayload:   payload,\n+\t\t})\n+\t\treturn err\n+\t})\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to call tool: %w\", err)\n+\t}\n+\treturn result, nil\n+}\n+\n+// HandleCloseSession closes the backend session if initialized.\n+func (lc *LazyConnector) HandleCloseSession(ctx context.Context, session *Session) error {\n+\tif !session.IsInitialized() {\n+\t\treturn nil\n+\t}\n+\n+\tclient, err := lc.routedClient(session.ID)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to route to backend: %w\", err)\n+\t}\n+\n+\t_, err = client.CloseSession(ctx, &mcpv1.CloseSessionRequest{SessionId: session.ID})\n+\treturn err\n+}\n+\n+// withRecovery executes fn and, if the backend returns \"session not found\",\n+// resets the session and retries once.\n+func (lc *LazyConnector) withRecovery(ctx context.Context, session *Session, fn func(client BackendClient) error) error {\n+\tclient, err := lc.routedClient(session.ID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor attempt := 0; attempt <= maxRecoveryRetries; attempt++ {\n+\t\terr = fn(client)\n+\t\tif err == nil || !isSessionNotFound(err) {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\t// Last attempt — don't recover, just return the error\n+\t\tif attempt == maxRecoveryRetries {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\t// Session lost on backend — re-initialize\n+\t\tsession.ResetInitialized()\n+\t\tif initErr := session.EnsureInitialized(ctx, lc.initBackendSession); initErr != nil {\n+\t\t\treturn initErr\n+\t\t}\n+\t}\n+\treturn err\n+}\n+\n+// isSessionNotFound checks if the error indicates the backend lost the session.\n+func isSessionNotFound(err error) bool {\n+\tif err == nil {\n+\t\treturn false\n+\t}\n+\tmsg := err.Error()\n+\treturn strings.Contains(msg, \"Session not found\") ||\n+\t\tstrings.Contains(msg, \"session not found\")\n+}\n+\n+// routedClient parses the session ID and returns a BackendClient routed to the correct backend.\n+func (lc *LazyConnector) routedClient(sessionID string) (BackendClient, error) {\n+\tparsed, err := sessionid.Parse(sessionID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to parse session id: %w\", err)\n+\t}\n+\treturn lc.router.ForAddr(parsed.BackendAddr)\n+}\n+\n+// initBackendSession is the initFn passed to EnsureInitialized.\n+// It sends the proxy-assigned session ID to the backend via CreateSession.\n+func (lc *LazyConnector) initBackendSession(ctx context.Context, sessionID, baseURL string) error {\n+\tclient, err := lc.routedClient(sessionID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = client.CreateSession(ctx, &mcpv1.CreateSessionRequest{\n+\t\tBaseUrl:         baseURL,\n+\t\tProtocolVersion: \"2025-03-26\",\n+\t\tSessionId:       sessionID,\n+\t})\n+\treturn err\n+}\ndiff --git a/mcp-proxy/internal/mcp/lazy_test.go b/mcp-proxy/internal/mcp/lazy_test.go\nnew file mode 100644\nindex 000000000..fd1c03d65\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/lazy_test.go\n@@ -0,0 +1,421 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"testing\"\n+\n+\tmcpv1 \"mcp-proxy/gen/duplo/mcp/v1\"\n+\t\"mcp-proxy/pkg/sessionid\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+// mockBackendRouter wraps a mockBackendClient and implements BackendRouter.\n+type mockBackendRouter struct {\n+\tclient *mockBackendClient\n+}\n+\n+func (m *mockBackendRouter) ForAddr(addr string) (BackendClient, error) {\n+\treturn m.client, nil\n+}\n+\n+type mockBackendClient struct {\n+\tcreateSessionFn   func(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error)\n+\tlistToolsFn       func(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error)\n+\tcloseSessionFn    func(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error)\n+\tcallToolFn        func(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error)\n+\tverifyAccessKeyFn func(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error)\n+\tcalls             map[string]int\n+}\n+\n+func newMockBackendClient() *mockBackendClient {\n+\treturn &mockBackendClient{calls: make(map[string]int)}\n+}\n+\n+func (m *mockBackendClient) CreateSession(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error) {\n+\tm.calls[\"CreateSession\"]++\n+\tif m.createSessionFn != nil {\n+\t\treturn m.createSessionFn(ctx, req)\n+\t}\n+\treturn &mcpv1.CreateSessionResponse{\n+\t\tProtocolVersion: \"2025-03-26\",\n+\t\tServerCapabilities: &mcpv1.ServerCapabilities{\n+\t\t\tTools: &mcpv1.ToolsCapability{ListChanged: true},\n+\t\t},\n+\t\tServerInfo: &mcpv1.ServerInfo{Name: \"test-server\", Version: \"1.0\"},\n+\t}, nil\n+}\n+\n+func (m *mockBackendClient) ListTools(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\tm.calls[\"ListTools\"]++\n+\tif m.listToolsFn != nil {\n+\t\treturn m.listToolsFn(ctx, req)\n+\t}\n+\treturn &mcpv1.ListToolsResponse{\n+\t\tTools: []*mcpv1.Tool{\n+\t\t\t{Name: \"tool1\", Description: \"desc1\"},\n+\t\t\t{Name: \"tool2\", Description: \"desc2\"},\n+\t\t},\n+\t}, nil\n+}\n+\n+func (m *mockBackendClient) CloseSession(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error) {\n+\tm.calls[\"CloseSession\"]++\n+\tif m.closeSessionFn != nil {\n+\t\treturn m.closeSessionFn(ctx, req)\n+\t}\n+\treturn &mcpv1.CloseSessionResponse{}, nil\n+}\n+\n+func (m *mockBackendClient) CallTool(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\tm.calls[\"CallTool\"]++\n+\tif m.callToolFn != nil {\n+\t\treturn m.callToolFn(ctx, req)\n+\t}\n+\treturn &mcpv1.CallToolResult{\n+\t\tContent: []*mcpv1.Content{\n+\t\t\t{Content: &mcpv1.Content_Text{Text: &mcpv1.TextContent{Text: \"result\"}}},\n+\t\t},\n+\t}, nil\n+}\n+\n+func (m *mockBackendClient) VerifyAccessKey(ctx context.Context, req *mcpv1.VerifyAccessKeyRequest) (*mcpv1.VerifyAccessKeyResponse, error) {\n+\tm.calls[\"VerifyAccessKey\"]++\n+\tif m.verifyAccessKeyFn != nil {\n+\t\treturn m.verifyAccessKeyFn(ctx, req)\n+\t}\n+\treturn &mcpv1.VerifyAccessKeyResponse{Valid: true, UserId: \"user-1\", DeviceId: \"device-1\"}, nil\n+}\n+\n+// testSessionID returns a valid, parseable session ID for testing.\n+func testSessionID() string {\n+\treturn sessionid.New(testBackendAddr, testProxyID).String()\n+}\n+\n+func TestLazyConnector_HandleInitialize(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tcaps, serverInfo, protoVersion := lc.HandleInitialize()\n+\n+\tassert.NotNil(t, caps)\n+\tassert.NotNil(t, caps.Tools)\n+\tassert.True(t, caps.Tools.ListChanged)\n+\tassert.Equal(t, \"duplo-mcp-proxy\", serverInfo.Name)\n+\tassert.Equal(t, \"2025-03-26\", protoVersion)\n+\n+\tassert.Equal(t, 0, mock.calls[\"CreateSession\"])\n+}\n+\n+func TestLazyConnector_HandleListTools_LazyInit(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{\n+\t\tID:      testSessionID(),\n+\t\tBaseURL: \"/presets/test/mcp\",\n+\t}\n+\n+\ttools, err := lc.HandleListTools(context.Background(), session)\n+\trequire.NoError(t, err)\n+\n+\t// CreateSession called once for lazy init, then ListTools for fetching\n+\tassert.Equal(t, 1, mock.calls[\"CreateSession\"])\n+\tassert.Equal(t, 1, mock.calls[\"ListTools\"])\n+\tassert.True(t, session.IsInitialized())\n+\n+\trequire.Len(t, tools, 2)\n+\tassert.Equal(t, \"tool1\", tools[0].Name)\n+}\n+\n+func TestLazyConnector_HandleListTools_AlwaysCallsBackend(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{\n+\t\tID:      testSessionID(),\n+\t\tBaseURL: \"/presets/test/mcp\",\n+\t}\n+\n+\t// First call\n+\t_, err := lc.HandleListTools(context.Background(), session)\n+\trequire.NoError(t, err)\n+\n+\t// Second call — should call backend again (no caching)\n+\t_, err = lc.HandleListTools(context.Background(), session)\n+\trequire.NoError(t, err)\n+\n+\tassert.Equal(t, 1, mock.calls[\"CreateSession\"]) // init only once\n+\tassert.Equal(t, 2, mock.calls[\"ListTools\"])      // called every time\n+}\n+\n+func TestLazyConnector_HandleListTools_PassesSessionID(t *testing.T) {\n+\tvar capturedReq *mcpv1.ListToolsRequest\n+\tmock := newMockBackendClient()\n+\tmock.listToolsFn = func(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\t\tcapturedReq = req\n+\t\treturn &mcpv1.ListToolsResponse{Tools: []*mcpv1.Tool{{Name: \"t1\"}}}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsid := testSessionID()\n+\tsession := &Session{ID: sid, BaseURL: \"/test\"}\n+\n+\t_, err := lc.HandleListTools(context.Background(), session)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, capturedReq)\n+\tassert.Equal(t, sid, capturedReq.SessionId)\n+}\n+\n+func TestLazyConnector_HandleListTools_CreateSessionPassesSessionID(t *testing.T) {\n+\tvar capturedReq *mcpv1.CreateSessionRequest\n+\tmock := newMockBackendClient()\n+\tmock.createSessionFn = func(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error) {\n+\t\tcapturedReq = req\n+\t\treturn &mcpv1.CreateSessionResponse{}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsid := testSessionID()\n+\tsession := &Session{ID: sid, BaseURL: \"/presets/test/mcp\"}\n+\n+\t_, err := lc.HandleListTools(context.Background(), session)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, capturedReq)\n+\tassert.Equal(t, sid, capturedReq.SessionId)\n+\tassert.Equal(t, \"/presets/test/mcp\", capturedReq.BaseUrl)\n+}\n+\n+func TestLazyConnector_HandleListTools_GRPCError(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tmock.createSessionFn = func(ctx context.Context, req *mcpv1.CreateSessionRequest) (*mcpv1.CreateSessionResponse, error) {\n+\t\treturn nil, fmt.Errorf(\"connection refused\")\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{\n+\t\tID:      testSessionID(),\n+\t\tBaseURL: \"/presets/test/mcp\",\n+\t}\n+\n+\t_, err := lc.HandleListTools(context.Background(), session)\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"connection refused\")\n+\tassert.False(t, session.IsInitialized())\n+}\n+\n+func TestLazyConnector_HandleCallTool(t *testing.T) {\n+\tvar capturedReq *mcpv1.CallToolSendRequest\n+\tmock := newMockBackendClient()\n+\tmock.callToolFn = func(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\t\tcapturedReq = req\n+\t\treturn &mcpv1.CallToolResult{\n+\t\t\tContent: []*mcpv1.Content{\n+\t\t\t\t{Content: &mcpv1.Content_Text{Text: &mcpv1.TextContent{Text: \"result\"}}},\n+\t\t\t},\n+\t\t}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsid := testSessionID()\n+\tsession := &Session{ID: sid, BaseURL: \"/presets/test/mcp\"}\n+\n+\tresult, err := lc.HandleCallTool(context.Background(), session, \"myTool\", `{\"key\":\"value\"}`, nil)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, result)\n+\n+\t// session.ID is used for RPC calls\n+\tassert.Equal(t, sid, capturedReq.SessionId)\n+\tassert.Equal(t, 1, mock.calls[\"CreateSession\"])\n+\tassert.Equal(t, 1, mock.calls[\"CallTool\"])\n+\tassert.Len(t, result.Content, 1)\n+}\n+\n+func TestLazyConnector_HandleCallTool_LazyInit(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/presets/test/mcp\"}\n+\n+\tresult, err := lc.HandleCallTool(context.Background(), session, \"myTool\", `{}`, nil)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, result)\n+\n+\tassert.Equal(t, 1, mock.calls[\"CreateSession\"])\n+\tassert.Equal(t, 1, mock.calls[\"CallTool\"])\n+\tassert.True(t, session.IsInitialized())\n+}\n+\n+func TestLazyConnector_HandleCallTool_BackendError(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tmock.callToolFn = func(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\t\treturn nil, fmt.Errorf(\"tool execution failed\")\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/presets/test/mcp\"}\n+\n+\t_, err := lc.HandleCallTool(context.Background(), session, \"myTool\", `{}`, nil)\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"tool execution failed\")\n+}\n+\n+func TestLazyConnector_HandleCallTool_WithMeta(t *testing.T) {\n+\tvar capturedReq *mcpv1.CallToolSendRequest\n+\tmock := newMockBackendClient()\n+\tmock.callToolFn = func(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\t\tcapturedReq = req\n+\t\treturn &mcpv1.CallToolResult{}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/presets/test/mcp\"}\n+\n+\tmeta := map[string]any{\"progressToken\": \"tok-1\"}\n+\t_, err := lc.HandleCallTool(context.Background(), session, \"myTool\", `{}`, meta)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, capturedReq.Payload.Meta)\n+\tassert.Equal(t, \"tok-1\", capturedReq.Payload.Meta.Fields[\"progressToken\"].GetStringValue())\n+}\n+\n+func TestLazyConnector_HandleCloseSession(t *testing.T) {\n+\tvar capturedReq *mcpv1.CloseSessionRequest\n+\tmock := newMockBackendClient()\n+\tmock.closeSessionFn = func(ctx context.Context, req *mcpv1.CloseSessionRequest) (*mcpv1.CloseSessionResponse, error) {\n+\t\tcapturedReq = req\n+\t\treturn &mcpv1.CloseSessionResponse{}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsid := testSessionID()\n+\tsession := &Session{ID: sid, BaseURL: \"/test\"}\n+\t// Mark initialized so close will proceed\n+\t_ = session.EnsureInitialized(context.Background(), func(ctx context.Context, s, base string) error {\n+\t\treturn nil\n+\t})\n+\n+\terr := lc.HandleCloseSession(context.Background(), session)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, mock.calls[\"CloseSession\"])\n+\tassert.Equal(t, sid, capturedReq.SessionId)\n+}\n+\n+func TestLazyConnector_HandleCloseSession_NotInitialized(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/test\"}\n+\n+\terr := lc.HandleCloseSession(context.Background(), session)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 0, mock.calls[\"CloseSession\"]) // no backend call\n+}\n+\n+// --- Recovery tests ---\n+\n+func TestLazyConnector_HandleListTools_SessionNotFound_Recovers(t *testing.T) {\n+\tvar listCallCount int\n+\tmock := newMockBackendClient()\n+\tmock.listToolsFn = func(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\t\tlistCallCount++\n+\t\tif listCallCount == 1 {\n+\t\t\treturn nil, fmt.Errorf(\"backend error: Session not found (code=5)\")\n+\t\t}\n+\t\treturn &mcpv1.ListToolsResponse{\n+\t\t\tTools: []*mcpv1.Tool{{Name: \"recovered-tool\"}},\n+\t\t}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/test\"}\n+\n+\ttools, err := lc.HandleListTools(context.Background(), session)\n+\trequire.NoError(t, err)\n+\trequire.Len(t, tools, 1)\n+\tassert.Equal(t, \"recovered-tool\", tools[0].Name)\n+\n+\t// CreateSession called twice: initial + recovery\n+\tassert.Equal(t, 2, mock.calls[\"CreateSession\"])\n+\tassert.Equal(t, 2, listCallCount)\n+}\n+\n+func TestLazyConnector_HandleCallTool_SessionNotFound_Recovers(t *testing.T) {\n+\tvar callCount int\n+\tmock := newMockBackendClient()\n+\tmock.callToolFn = func(ctx context.Context, req *mcpv1.CallToolSendRequest) (*mcpv1.CallToolResult, error) {\n+\t\tcallCount++\n+\t\tif callCount == 1 {\n+\t\t\treturn nil, fmt.Errorf(\"backend error: session not found (code=5)\")\n+\t\t}\n+\t\treturn &mcpv1.CallToolResult{\n+\t\t\tContent: []*mcpv1.Content{\n+\t\t\t\t{Content: &mcpv1.Content_Text{Text: &mcpv1.TextContent{Text: \"recovered\"}}},\n+\t\t\t},\n+\t\t}, nil\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/test\"}\n+\n+\tresult, err := lc.HandleCallTool(context.Background(), session, \"myTool\", `{}`, nil)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, result)\n+\n+\tassert.Equal(t, 2, mock.calls[\"CreateSession\"])\n+\tassert.Equal(t, 2, callCount)\n+}\n+\n+func TestLazyConnector_SessionNotFound_MaxRetries(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tmock.listToolsFn = func(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\t\treturn nil, fmt.Errorf(\"Session not found\")\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/test\"}\n+\n+\t_, err := lc.HandleListTools(context.Background(), session)\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"Session not found\")\n+\n+\t// Initial EnsureInitialized(1) + 1 recovery = 2 CreateSession calls\n+\tassert.Equal(t, 2, mock.calls[\"CreateSession\"])\n+\t// attempt 0 + retry 1 = 2 ListTools calls\n+\tassert.Equal(t, 2, mock.calls[\"ListTools\"])\n+}\n+\n+func TestLazyConnector_OtherError_NoRetry(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\tmock.listToolsFn = func(ctx context.Context, req *mcpv1.ListToolsRequest) (*mcpv1.ListToolsResponse, error) {\n+\t\treturn nil, fmt.Errorf(\"connection timeout\")\n+\t}\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tsession := &Session{ID: testSessionID(), BaseURL: \"/test\"}\n+\n+\t_, err := lc.HandleListTools(context.Background(), session)\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"connection timeout\")\n+\n+\t// Only initial CreateSession, no recovery\n+\tassert.Equal(t, 1, mock.calls[\"CreateSession\"])\n+\tassert.Equal(t, 1, mock.calls[\"ListTools\"])\n+}\ndiff --git a/mcp-proxy/internal/mcp/middleware.go b/mcp-proxy/internal/mcp/middleware.go\nnew file mode 100644\nindex 000000000..e037a635f\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/middleware.go\n@@ -0,0 +1,101 @@\n+package mcp\n+\n+import (\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"runtime/debug\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n+)\n+\n+// RecoveryMiddleware recovers from panics, logs the stack trace, and returns 500.\n+// If the response header has already been sent (e.g., SSE), it only logs without\n+// attempting to write the error response.\n+func RecoveryMiddleware(logger zerolog.Logger) func(http.Handler) http.Handler {\n+\treturn func(next http.Handler) http.Handler {\n+\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\t\tdefer func() {\n+\t\t\t\tif rec := recover(); rec != nil {\n+\t\t\t\t\tlogger.Error().\n+\t\t\t\t\t\tStr(\"method\", r.Method).\n+\t\t\t\t\t\tStr(\"path\", r.URL.Path).\n+\t\t\t\t\t\tStr(\"panic\", fmt.Sprint(rec)).\n+\t\t\t\t\t\tStr(\"stack\", string(debug.Stack())).\n+\t\t\t\t\t\tMsg(\"panic recovered\")\n+\n+\t\t\t\t\t// Only write error response if headers haven't been sent yet\n+\t\t\t\t\tif rw, ok := w.(*responseWriter); ok && rw.headerSent {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\tnext.ServeHTTP(w, r)\n+\t\t})\n+\t}\n+}\n+\n+// RequestLoggingMiddleware logs each request with method, path, status, and duration.\n+func RequestLoggingMiddleware(logger zerolog.Logger) func(http.Handler) http.Handler {\n+\treturn func(next http.Handler) http.Handler {\n+\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\t\tstart := time.Now()\n+\n+\t\t\twrapped := &responseWriter{\n+\t\t\t\tResponseWriter: w,\n+\t\t\t\tstatusCode:     http.StatusOK,\n+\t\t\t}\n+\n+\t\t\tnext.ServeHTTP(wrapped, r)\n+\n+\t\t\tevent := logger.Info().\n+\t\t\t\tStr(\"method\", r.Method).\n+\t\t\t\tStr(\"path\", r.URL.Path).\n+\t\t\t\tStr(\"remote_addr\", r.RemoteAddr).\n+\t\t\t\tInt(\"status\", wrapped.statusCode).\n+\t\t\t\tInt(\"bytes\", wrapped.bytesWritten).\n+\t\t\t\tDur(\"duration\", time.Since(start))\n+\n+\t\t\tif strings.HasPrefix(wrapped.Header().Get(\"Content-Type\"), \"text/event-stream\") {\n+\t\t\t\tevent.Bool(\"sse\", true)\n+\t\t\t}\n+\n+\t\t\tevent.Msg(\"http request\")\n+\t\t})\n+\t}\n+}\n+\n+type responseWriter struct {\n+\thttp.ResponseWriter\n+\tstatusCode   int\n+\tbytesWritten int\n+\theaderSent   bool\n+}\n+\n+func (rw *responseWriter) WriteHeader(code int) {\n+\trw.headerSent = true\n+\trw.statusCode = code\n+\trw.ResponseWriter.WriteHeader(code)\n+}\n+\n+func (rw *responseWriter) Write(b []byte) (int, error) {\n+\trw.headerSent = true\n+\tn, err := rw.ResponseWriter.Write(b)\n+\trw.bytesWritten += n\n+\treturn n, err\n+}\n+\n+// Flush implements http.Flusher, delegating to the underlying ResponseWriter.\n+// This is required for SSE to work through the middleware chain.\n+func (rw *responseWriter) Flush() {\n+\tif f, ok := rw.ResponseWriter.(http.Flusher); ok {\n+\t\tf.Flush()\n+\t}\n+}\n+\n+// Unwrap returns the underlying ResponseWriter for http.ResponseController support.\n+func (rw *responseWriter) Unwrap() http.ResponseWriter {\n+\treturn rw.ResponseWriter\n+}\ndiff --git a/mcp-proxy/internal/mcp/middleware_test.go b/mcp-proxy/internal/mcp/middleware_test.go\nnew file mode 100644\nindex 000000000..ad97fee3d\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/middleware_test.go\n@@ -0,0 +1,218 @@\n+package mcp\n+\n+import (\n+\t\"bytes\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"github.com/rs/zerolog\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestRecoveryMiddleware_PanicReturns500(t *testing.T) {\n+\tvar logBuf bytes.Buffer\n+\tlogger := zerolog.New(&logBuf)\n+\n+\tpanicking := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tpanic(\"test panic\")\n+\t})\n+\n+\thandler := RecoveryMiddleware(logger)(panicking)\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n+\tassert.Contains(t, logBuf.String(), \"test panic\")\n+\tassert.Contains(t, logBuf.String(), \"panic recovered\")\n+}\n+\n+func TestRecoveryMiddleware_NoPanic(t *testing.T) {\n+\tlogger := zerolog.Nop()\n+\n+\tnormal := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write([]byte(\"ok\"))\n+\t})\n+\n+\thandler := RecoveryMiddleware(logger)(normal)\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\tassert.Equal(t, \"ok\", rec.Body.String())\n+}\n+\n+func TestRequestLoggingMiddleware_LogsRequest(t *testing.T) {\n+\tvar logBuf bytes.Buffer\n+\tlogger := zerolog.New(&logBuf)\n+\n+\tinner := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.WriteHeader(http.StatusCreated)\n+\t\tw.Write([]byte(\"created\"))\n+\t})\n+\n+\thandler := RequestLoggingMiddleware(logger)(inner)\n+\n+\treq := httptest.NewRequest(http.MethodPost, \"/test/path\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusCreated, rec.Code)\n+\n+\tlogOutput := logBuf.String()\n+\tassert.Contains(t, logOutput, \"POST\")\n+\tassert.Contains(t, logOutput, \"/test/path\")\n+\tassert.Contains(t, logOutput, \"201\")\n+}\n+\n+func TestMaxBytesReader_ExceedsLimit(t *testing.T) {\n+\thandler, _ := setupTestHandler()\n+\n+\t// Reconfigure with 1 byte limit for testing\n+\thandler.maxRequestBodyBytes = 1\n+\n+\tlargeBody := `{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}`\n+\trec := doPost(handler, \"/presets/test/mcp\", []byte(largeBody), nil)\n+\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\n+\t// Should get an error response (body too large)\n+\tbody := rec.Body.String()\n+\tassert.Contains(t, body, \"failed to read request body\")\n+}\n+\n+func TestResponseWriter_Unwrap(t *testing.T) {\n+\trec := httptest.NewRecorder()\n+\trw := &responseWriter{ResponseWriter: rec, statusCode: http.StatusOK}\n+\n+\tassert.Equal(t, rec, rw.Unwrap())\n+}\n+\n+func TestResponseWriter_CapturesStatusAndBytes(t *testing.T) {\n+\trec := httptest.NewRecorder()\n+\trw := &responseWriter{ResponseWriter: rec, statusCode: http.StatusOK}\n+\n+\trw.WriteHeader(http.StatusNotFound)\n+\tn, err := rw.Write([]byte(\"not found\"))\n+\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 9, n)\n+\tassert.Equal(t, http.StatusNotFound, rw.statusCode)\n+\tassert.Equal(t, 9, rw.bytesWritten)\n+}\n+\n+func TestResponseWriter_ImplementsFlusher(t *testing.T) {\n+\trec := httptest.NewRecorder()\n+\trw := &responseWriter{ResponseWriter: rec, statusCode: http.StatusOK}\n+\n+\t// responseWriter must implement http.Flusher for SSE\n+\tflusher, ok := interface{}(rw).(http.Flusher)\n+\tassert.True(t, ok, \"responseWriter must implement http.Flusher\")\n+\tflusher.Flush() // should not panic\n+}\n+\n+func TestResponseWriter_HeaderSent(t *testing.T) {\n+\trec := httptest.NewRecorder()\n+\trw := &responseWriter{ResponseWriter: rec, statusCode: http.StatusOK}\n+\n+\tassert.False(t, rw.headerSent)\n+\n+\trw.WriteHeader(http.StatusOK)\n+\tassert.True(t, rw.headerSent)\n+}\n+\n+func TestRecoveryMiddleware_SkipsErrorAfterHeaderSent(t *testing.T) {\n+\tvar logBuf bytes.Buffer\n+\tlogger := zerolog.New(&logBuf)\n+\n+\t// Handler that sends header then panics (simulates SSE panic)\n+\t// Chain: Logging → Recovery → Handler (same order as server.go)\n+\thandler := RequestLoggingMiddleware(logger)(RecoveryMiddleware(logger)(\n+\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\t\tw.WriteHeader(http.StatusOK)\n+\t\t\tw.Write([]byte(\"data: hello\\n\\n\"))\n+\t\t\tpanic(\"sse panic\")\n+\t\t}),\n+\t))\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/sse\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\t// Panic is logged\n+\tassert.Contains(t, logBuf.String(), \"sse panic\")\n+\t// Status stays 200 (header was already sent, can't change to 500)\n+\tassert.Equal(t, http.StatusOK, rec.Code)\n+\t// Body must not be polluted with \"Internal Server Error\"\n+\tassert.NotContains(t, rec.Body.String(), \"Internal Server Error\")\n+\tassert.Equal(t, \"data: hello\\n\\n\", rec.Body.String())\n+}\n+\n+func TestMiddlewareChain_LoggingWrapsRecovery(t *testing.T) {\n+\tvar logBuf bytes.Buffer\n+\tlogger := zerolog.New(&logBuf)\n+\n+\tpanicking := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tpanic(\"chain test\")\n+\t})\n+\n+\t// Logging → Recovery → Handler (same order as server.go)\n+\thandler := RequestLoggingMiddleware(logger)(RecoveryMiddleware(logger)(panicking))\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/panic\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n+\n+\tlogOutput := logBuf.String()\n+\t// Recovery should log the panic\n+\tassert.Contains(t, logOutput, \"chain test\")\n+\t// Panic request should also be logged by RequestLoggingMiddleware\n+\tassert.Contains(t, logOutput, \"http request\")\n+}\n+\n+func TestRequestLoggingMiddleware_SSE_AddsSseField(t *testing.T) {\n+\tvar logBuf bytes.Buffer\n+\tlogger := zerolog.New(&logBuf)\n+\n+\tinner := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t})\n+\n+\thandler := RequestLoggingMiddleware(logger)(inner)\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/sse\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tlogOutput := logBuf.String()\n+\tassert.Contains(t, logOutput, `\"sse\":true`)\n+\tassert.Contains(t, logOutput, \"http request\")\n+}\n+\n+func TestRequestLoggingMiddleware_NonSSE_NoSseField(t *testing.T) {\n+\tvar logBuf bytes.Buffer\n+\tlogger := zerolog.New(&logBuf)\n+\n+\tinner := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t})\n+\n+\thandler := RequestLoggingMiddleware(logger)(inner)\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/api\", nil)\n+\trec := httptest.NewRecorder()\n+\thandler.ServeHTTP(rec, req)\n+\n+\tlogOutput := logBuf.String()\n+\tassert.NotContains(t, logOutput, \"sse\")\n+\tassert.Contains(t, logOutput, \"http request\")\n+}\ndiff --git a/mcp-proxy/internal/mcp/server.go b/mcp-proxy/internal/mcp/server.go\nnew file mode 100644\nindex 000000000..770c98e0c\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/server.go\n@@ -0,0 +1,92 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"mcp-proxy/internal/app\"\n+\n+\t\"github.com/rs/zerolog\"\n+)\n+\n+var _ app.Service = (*Server)(nil)\n+\n+// ServerConfig holds the HTTP server configuration values needed by Server.\n+// WriteTimeout is intentionally omitted — SSE (long-lived connections) is\n+// incompatible with a global write deadline.\n+type ServerConfig struct {\n+\tPort              int\n+\tReadHeaderTimeout time.Duration\n+\tIdleTimeout       time.Duration\n+\tShutdownTimeout   time.Duration\n+}\n+\n+// Server wraps an HTTP server that hosts the MCP handler.\n+type Server struct {\n+\tconfig  ServerConfig\n+\thandler http.Handler\n+\tlogger  zerolog.Logger\n+}\n+\n+// NewServer creates an HTTP server with the given configuration.\n+// The handler is wrapped with Recovery and RequestLogging middleware.\n+func NewServer(cfg ServerConfig, handler *Handler, logger zerolog.Logger) *Server {\n+\t// Middleware chain: Logging → Recovery → Handler\n+\tvar wrapped http.Handler = handler\n+\twrapped = RecoveryMiddleware(logger)(wrapped)\n+\twrapped = RequestLoggingMiddleware(logger)(wrapped)\n+\n+\treturn &Server{\n+\t\tconfig:  cfg,\n+\t\thandler: wrapped,\n+\t\tlogger:  logger,\n+\t}\n+}\n+\n+// Name returns the service identifier used in logs.\n+func (s *Server) Name() string {\n+\treturn \"mcp-http\"\n+}\n+\n+// Run starts the HTTP server and blocks until ctx is cancelled.\n+func (s *Server) Run(ctx context.Context) error {\n+\taddr := fmt.Sprintf(\":%d\", s.config.Port)\n+\tserver := &http.Server{\n+\t\tAddr:              addr,\n+\t\tHandler:           s.handler,\n+\t\tReadHeaderTimeout: s.config.ReadHeaderTimeout,\n+\t\tIdleTimeout:       s.config.IdleTimeout,\n+\t\tBaseContext: func(net.Listener) context.Context {\n+\t\t\treturn ctx\n+\t\t},\n+\t}\n+\n+\t// Graceful shutdown\n+\terrChan := make(chan error, 1)\n+\tgo func() {\n+\t\t<-ctx.Done()\n+\n+\t\ts.logger.Info().Ctx(ctx).Msg(\"shutting down http server\")\n+\n+\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), s.config.ShutdownTimeout)\n+\t\tdefer cancel()\n+\n+\t\tif err := server.Shutdown(shutdownCtx); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"http server shutdown failed: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\t\terrChan <- nil\n+\t}()\n+\n+\t// Start\n+\ts.logger.Info().Ctx(ctx).Str(\"addr\", addr).Msg(\"starting http server\")\n+\tif err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n+\t\treturn fmt.Errorf(\"http server failed: %w\", err)\n+\t}\n+\n+\treturn <-errChan\n+}\ndiff --git a/mcp-proxy/internal/mcp/session.go b/mcp-proxy/internal/mcp/session.go\nnew file mode 100644\nindex 000000000..595fde919\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/session.go\n@@ -0,0 +1,68 @@\n+// Package mcp implements the MCP protocol proxy between HTTP clients and the gRPC backend.\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+// Session holds per-client state for an MCP connection.\n+// The session ID is generated by the proxy and serves as the single\n+// authoritative identifier across both client and backend communication.\n+type Session struct {\n+\tID      string\n+\tBaseURL string\n+\n+\tmu           sync.Mutex\n+\tinitialized  bool\n+\tlastAccessAt time.Time\n+}\n+\n+// EnsureInitialized runs initFn exactly once to establish a backend session.\n+// Concurrent callers block on the mutex; only the first proceeds with initFn.\n+// The initFn receives the proxy-assigned session ID and base URL.\n+func (s *Session) EnsureInitialized(ctx context.Context, initFn func(ctx context.Context, sessionID, baseURL string) error) error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.initialized {\n+\t\treturn nil\n+\t}\n+\n+\tif err := initFn(ctx, s.ID, s.BaseURL); err != nil {\n+\t\treturn err\n+\t}\n+\n+\ts.initialized = true\n+\treturn nil\n+}\n+\n+// IsInitialized reports whether the backend session has been established.\n+func (s *Session) IsInitialized() bool {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\treturn s.initialized\n+}\n+\n+// ResetInitialized clears the initialized flag, allowing re-initialization.\n+// This is used for session recovery when the backend loses session state.\n+func (s *Session) ResetInitialized() {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.initialized = false\n+}\n+\n+// Touch updates lastAccessAt to the current time, extending the session TTL.\n+func (s *Session) Touch() {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.lastAccessAt = time.Now()\n+}\n+\n+// LastAccessAt returns the last access time.\n+func (s *Session) LastAccessAt() time.Time {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\treturn s.lastAccessAt\n+}\ndiff --git a/mcp-proxy/internal/mcp/session_cleaner.go b/mcp-proxy/internal/mcp/session_cleaner.go\nnew file mode 100644\nindex 000000000..5fbbd629b\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/session_cleaner.go\n@@ -0,0 +1,68 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"time\"\n+\n+\t\"mcp-proxy/internal/app\"\n+\n+\t\"github.com/rs/zerolog\"\n+)\n+\n+var _ app.Service = (*SessionCleaner)(nil)\n+\n+// SessionCleaner periodically evicts expired sessions and closes their backend sessions.\n+type SessionCleaner struct {\n+\tsessions        *SessionManager\n+\tlazy            *LazyConnector\n+\ttimeout         time.Duration\n+\tcleanupInterval time.Duration\n+\tlogger          zerolog.Logger\n+}\n+\n+// NewSessionCleaner creates a cleaner that evicts sessions older than timeout\n+// every cleanupInterval.\n+func NewSessionCleaner(sessions *SessionManager, lazy *LazyConnector, timeout, cleanupInterval time.Duration, logger zerolog.Logger) *SessionCleaner {\n+\treturn &SessionCleaner{\n+\t\tsessions:        sessions,\n+\t\tlazy:            lazy,\n+\t\ttimeout:         timeout,\n+\t\tcleanupInterval: cleanupInterval,\n+\t\tlogger:          logger,\n+\t}\n+}\n+\n+// Name returns the service identifier.\n+func (c *SessionCleaner) Name() string {\n+\treturn \"session-cleaner\"\n+}\n+\n+// Run starts the cleanup ticker and blocks until ctx is cancelled.\n+func (c *SessionCleaner) Run(ctx context.Context) error {\n+\tticker := time.NewTicker(c.cleanupInterval)\n+\tdefer ticker.Stop()\n+\n+\tc.logger.Info().\n+\t\tDur(\"timeout\", c.timeout).\n+\t\tDur(\"interval\", c.cleanupInterval).\n+\t\tMsg(\"session cleaner started\")\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil\n+\t\tcase <-ticker.C:\n+\t\t\tc.evict(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func (c *SessionCleaner) evict(ctx context.Context) {\n+\terrs := c.sessions.EvictExpired(c.timeout, func(session *Session) error {\n+\t\tc.logger.Info().Str(\"session\", session.ID).Msg(\"evicting expired session\")\n+\t\treturn c.lazy.HandleCloseSession(ctx, session)\n+\t})\n+\tfor _, err := range errs {\n+\t\tc.logger.Warn().Err(err).Msg(\"failed to close backend session during eviction\")\n+\t}\n+}\ndiff --git a/mcp-proxy/internal/mcp/session_cleaner_test.go b/mcp-proxy/internal/mcp/session_cleaner_test.go\nnew file mode 100644\nindex 000000000..cb96652d0\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/session_cleaner_test.go\n@@ -0,0 +1,174 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestSessionManager_EvictExpired_RemovesExpiredSessions(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts1 := mgr.Create(\"/test1\", testBackendAddr)\n+\ts2 := mgr.Create(\"/test2\", testBackendAddr)\n+\n+\t// Manually set s1's lastAccessAt to the past\n+\ts1.mu.Lock()\n+\ts1.lastAccessAt = time.Now().Add(-3 * time.Hour)\n+\ts1.mu.Unlock()\n+\n+\t// s2 was just created, should be within TTL\n+\tvar closedIDs []string\n+\terrs := mgr.EvictExpired(2*time.Hour, func(session *Session) error {\n+\t\tclosedIDs = append(closedIDs, session.ID)\n+\t\treturn nil\n+\t})\n+\n+\tassert.Empty(t, errs)\n+\tassert.Equal(t, []string{s1.ID}, closedIDs)\n+\n+\t// s1 should be gone, s2 should remain\n+\tassert.Nil(t, mgr.Get(s1.ID))\n+\tassert.NotNil(t, mgr.Get(s2.ID))\n+}\n+\n+func TestSessionManager_EvictExpired_KeepsActiveSession(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts := mgr.Create(\"/test\", testBackendAddr)\n+\ts.Touch() // refresh\n+\n+\tvar closedCount int\n+\terrs := mgr.EvictExpired(2*time.Hour, func(session *Session) error {\n+\t\tclosedCount++\n+\t\treturn nil\n+\t})\n+\n+\tassert.Empty(t, errs)\n+\tassert.Equal(t, 0, closedCount)\n+\tassert.NotNil(t, mgr.Get(s.ID))\n+}\n+\n+func TestSession_Touch_ExtendsLifetime(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\ts := mgr.Create(\"/test\", testBackendAddr)\n+\n+\t// Set to expired\n+\ts.mu.Lock()\n+\ts.lastAccessAt = time.Now().Add(-3 * time.Hour)\n+\ts.mu.Unlock()\n+\n+\t// Touch to refresh\n+\ts.Touch()\n+\n+\t// Should not be evicted\n+\terrs := mgr.EvictExpired(2*time.Hour, nil)\n+\tassert.Empty(t, errs)\n+\tassert.NotNil(t, mgr.Get(s.ID))\n+}\n+\n+func TestSessionManager_EvictExpired_CallsCloseFn(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tmgr := NewSessionManager(testProxyID)\n+\ts := mgr.Create(\"/test\", testBackendAddr)\n+\n+\t// Initialize the session so CloseSession will be called\n+\terr := s.EnsureInitialized(context.Background(), lc.initBackendSession)\n+\trequire.NoError(t, err)\n+\n+\t// Expire the session\n+\ts.mu.Lock()\n+\ts.lastAccessAt = time.Now().Add(-3 * time.Hour)\n+\ts.mu.Unlock()\n+\n+\terrs := mgr.EvictExpired(2*time.Hour, func(session *Session) error {\n+\t\treturn lc.HandleCloseSession(context.Background(), session)\n+\t})\n+\n+\tassert.Empty(t, errs)\n+\tassert.Equal(t, 1, mock.calls[\"CloseSession\"])\n+}\n+\n+func TestSessionManager_EvictExpired_CloseFnErrorContinuesEviction(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts1 := mgr.Create(\"/test1\", testBackendAddr)\n+\ts2 := mgr.Create(\"/test2\", testBackendAddr)\n+\n+\t// Expire both sessions\n+\tfor _, s := range []*Session{s1, s2} {\n+\t\ts.mu.Lock()\n+\t\ts.lastAccessAt = time.Now().Add(-3 * time.Hour)\n+\t\ts.mu.Unlock()\n+\t}\n+\n+\tvar closedCount int\n+\terrs := mgr.EvictExpired(2*time.Hour, func(session *Session) error {\n+\t\tclosedCount++\n+\t\treturn fmt.Errorf(\"backend unavailable\")\n+\t})\n+\n+\t// Both sessions attempted, both errors collected, both removed locally\n+\tassert.Len(t, errs, 2)\n+\tassert.Equal(t, 2, closedCount)\n+\tassert.Nil(t, mgr.Get(s1.ID))\n+\tassert.Nil(t, mgr.Get(s2.ID))\n+}\n+\n+func TestSessionManager_EvictExpired_MultipleExpiredSessions(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\tsessions := make([]*Session, 5)\n+\tfor i := range sessions {\n+\t\tsessions[i] = mgr.Create(fmt.Sprintf(\"/test%d\", i), testBackendAddr)\n+\t\tsessions[i].mu.Lock()\n+\t\tsessions[i].lastAccessAt = time.Now().Add(-3 * time.Hour)\n+\t\tsessions[i].mu.Unlock()\n+\t}\n+\n+\tvar closedCount int\n+\terrs := mgr.EvictExpired(2*time.Hour, func(session *Session) error {\n+\t\tclosedCount++\n+\t\treturn nil\n+\t})\n+\n+\tassert.Empty(t, errs)\n+\tassert.Equal(t, 5, closedCount)\n+\tfor _, s := range sessions {\n+\t\tassert.Nil(t, mgr.Get(s.ID))\n+\t}\n+}\n+\n+func TestSessionCleaner_EvictsOnTick(t *testing.T) {\n+\tmock := newMockBackendClient()\n+\trouter := &mockBackendRouter{client: mock}\n+\tlc := NewLazyConnector(router)\n+\n+\tmgr := NewSessionManager(testProxyID)\n+\ts := mgr.Create(\"/test\", testBackendAddr)\n+\n+\t// Initialize and expire the session\n+\t_ = s.EnsureInitialized(context.Background(), lc.initBackendSession)\n+\ts.mu.Lock()\n+\ts.lastAccessAt = time.Now().Add(-3 * time.Hour)\n+\ts.mu.Unlock()\n+\n+\tcleaner := NewSessionCleaner(mgr, lc, 2*time.Hour, 50*time.Millisecond, zerolog.Nop())\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)\n+\tdefer cancel()\n+\n+\t_ = cleaner.Run(ctx)\n+\n+\t// Session should have been evicted\n+\tassert.Nil(t, mgr.Get(s.ID))\n+\tassert.Equal(t, 1, mock.calls[\"CloseSession\"])\n+}\ndiff --git a/mcp-proxy/internal/mcp/session_manager.go b/mcp-proxy/internal/mcp/session_manager.go\nnew file mode 100644\nindex 000000000..40cd5ff14\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/session_manager.go\n@@ -0,0 +1,93 @@\n+package mcp\n+\n+import (\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"mcp-proxy/pkg/sessionid\"\n+)\n+\n+// SessionManager provides thread-safe storage for active MCP sessions.\n+type SessionManager struct {\n+\tmu       sync.RWMutex\n+\tsessions map[string]*Session\n+\tproxyID  string\n+}\n+\n+// NewSessionManager creates an empty session store bound to the given proxy instance ID.\n+func NewSessionManager(proxyID string) *SessionManager {\n+\treturn &SessionManager{\n+\t\tsessions: make(map[string]*Session),\n+\t\tproxyID:  proxyID,\n+\t}\n+}\n+\n+// Create allocates a new session for the given base URL and backend address, then returns it.\n+func (m *SessionManager) Create(baseURL, backendAddr string) *Session {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\n+\tid := sessionid.New(backendAddr, m.proxyID).String()\n+\ts := &Session{\n+\t\tID:           id,\n+\t\tBaseURL:      baseURL,\n+\t\tlastAccessAt: time.Now(),\n+\t}\n+\tm.sessions[id] = s\n+\treturn s\n+}\n+\n+// Get returns the session for the given ID, or nil if not found.\n+func (m *SessionManager) Get(id string) *Session {\n+\tm.mu.RLock()\n+\tdefer m.mu.RUnlock()\n+\n+\treturn m.sessions[id]\n+}\n+\n+// Close removes the session with the given ID.\n+// It reports whether the session existed.\n+func (m *SessionManager) Close(id string) bool {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\n+\tif _, ok := m.sessions[id]; !ok {\n+\t\treturn false\n+\t}\n+\tdelete(m.sessions, id)\n+\treturn true\n+}\n+\n+// EvictExpired removes sessions that have not been accessed within the given TTL.\n+// For each evicted session, closeFn is called to clean up backend resources.\n+// closeFn errors are collected but do not prevent other sessions from being evicted.\n+// If closeFn fails, the local session is still removed — orphaned backend sessions\n+// are expected to be cleaned up by the backend's own session timeout.\n+func (m *SessionManager) EvictExpired(ttl time.Duration, closeFn func(session *Session) error) []error {\n+\tnow := time.Now()\n+\tvar expired []*Session\n+\n+\tm.mu.RLock()\n+\tfor _, s := range m.sessions {\n+\t\tif now.Sub(s.LastAccessAt()) > ttl {\n+\t\t\texpired = append(expired, s)\n+\t\t}\n+\t}\n+\tm.mu.RUnlock()\n+\n+\tvar errs []error\n+\tfor _, s := range expired {\n+\t\t// Re-check: the session may have been Touch()'d between RLock and now.\n+\t\tif time.Since(s.LastAccessAt()) <= ttl {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif closeFn != nil {\n+\t\t\tif err := closeFn(s); err != nil {\n+\t\t\t\terrs = append(errs, err)\n+\t\t\t}\n+\t\t}\n+\t\tm.Close(s.ID)\n+\t}\n+\treturn errs\n+}\ndiff --git a/mcp-proxy/internal/mcp/session_manager_test.go b/mcp-proxy/internal/mcp/session_manager_test.go\nnew file mode 100644\nindex 000000000..427ac2ff4\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/session_manager_test.go\n@@ -0,0 +1,108 @@\n+package mcp\n+\n+import (\n+\t\"strings\"\n+\t\"sync\"\n+\t\"testing\"\n+\n+\t\"mcp-proxy/pkg/sessionid\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+const (\n+\ttestBackendAddr = \"test-backend\"\n+\ttestProxyID     = \"test-proxy\"\n+)\n+\n+func TestSessionManager_CreateAndGet(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts := mgr.Create(\"/presets/test/mcp\", testBackendAddr)\n+\trequire.NotNil(t, s)\n+\tassert.NotEmpty(t, s.ID)\n+\tassert.Equal(t, \"/presets/test/mcp\", s.BaseURL)\n+\n+\tgot := mgr.Get(s.ID)\n+\tassert.Equal(t, s, got)\n+}\n+\n+func TestSessionManager_Create_SessionIDFormat(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts := mgr.Create(\"/presets/test/mcp\", testBackendAddr)\n+\n+\t// ID must be parseable by sessionid.Parse\n+\tparsed, err := sessionid.Parse(s.ID)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, testBackendAddr, parsed.BackendAddr)\n+\tassert.Equal(t, testProxyID, parsed.ProxyID)\n+\tassert.Len(t, parsed.ShortID, 8)\n+}\n+\n+func TestSessionManager_Create_IDNotContainPlaintext(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts := mgr.Create(\"/presets/test/mcp\", testBackendAddr)\n+\n+\t// The routing part (before the last colon) must not contain plaintext\n+\tlastColon := strings.LastIndex(s.ID, \":\")\n+\trequire.Greater(t, lastColon, 0)\n+\troutingPart := s.ID[:lastColon]\n+\tassert.NotContains(t, routingPart, testBackendAddr)\n+\tassert.NotContains(t, routingPart, testProxyID)\n+}\n+\n+func TestSessionManager_Create_RoundTrip(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts := mgr.Create(\"/presets/test/mcp\", testBackendAddr)\n+\n+\tparsed, err := sessionid.Parse(s.ID)\n+\trequire.NoError(t, err)\n+\n+\t// Round-trip: encode back and compare\n+\tassert.Equal(t, s.ID, parsed.String())\n+}\n+\n+func TestSessionManager_Get_NotFound(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\tgot := mgr.Get(\"nonexistent\")\n+\tassert.Nil(t, got)\n+}\n+\n+func TestSessionManager_Close(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\ts := mgr.Create(\"/presets/test/mcp\", testBackendAddr)\n+\tok := mgr.Close(s.ID)\n+\tassert.True(t, ok)\n+\n+\tgot := mgr.Get(s.ID)\n+\tassert.Nil(t, got)\n+}\n+\n+func TestSessionManager_Close_NotFound(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\tok := mgr.Close(\"nonexistent\")\n+\tassert.False(t, ok)\n+}\n+\n+func TestSessionManager_RaceCondition(t *testing.T) {\n+\tmgr := NewSessionManager(testProxyID)\n+\n+\tvar wg sync.WaitGroup\n+\tfor range 100 {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\ts := mgr.Create(\"/test\", \"10.0.0.1\")\n+\t\t\tmgr.Get(s.ID)\n+\t\t\tmgr.Close(s.ID)\n+\t\t}()\n+\t}\n+\twg.Wait()\n+}\ndiff --git a/mcp-proxy/internal/mcp/session_test.go b/mcp-proxy/internal/mcp/session_test.go\nnew file mode 100644\nindex 000000000..ca92f7a27\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/session_test.go\n@@ -0,0 +1,110 @@\n+package mcp\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestSession_EnsureInitialized_RunsOnce(t *testing.T) {\n+\ts := &Session{ID: \"s1\", BaseURL: \"/test\"}\n+\n+\tvar callCount atomic.Int32\n+\tinitFn := func(ctx context.Context, sessionID, baseURL string) error {\n+\t\tcallCount.Add(1)\n+\t\tassert.Equal(t, \"s1\", sessionID)\n+\t\tassert.Equal(t, \"/test\", baseURL)\n+\t\treturn nil\n+\t}\n+\n+\tvar wg sync.WaitGroup\n+\tfor range 10 {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\terr := s.EnsureInitialized(context.Background(), initFn)\n+\t\t\tassert.NoError(t, err)\n+\t\t}()\n+\t}\n+\twg.Wait()\n+\n+\tassert.Equal(t, int32(1), callCount.Load())\n+\tassert.True(t, s.IsInitialized())\n+}\n+\n+func TestSession_EnsureInitialized_ErrorKeepsUninitialized(t *testing.T) {\n+\ts := &Session{ID: \"s1\", BaseURL: \"/test\"}\n+\n+\tinitFn := func(ctx context.Context, sessionID, baseURL string) error {\n+\t\treturn fmt.Errorf(\"connection refused\")\n+\t}\n+\n+\terr := s.EnsureInitialized(context.Background(), initFn)\n+\tassert.Error(t, err)\n+\tassert.False(t, s.IsInitialized())\n+}\n+\n+func TestSession_ResetInitialized(t *testing.T) {\n+\ts := &Session{ID: \"s1\", BaseURL: \"/test\"}\n+\n+\t// Initialize\n+\terr := s.EnsureInitialized(context.Background(), func(ctx context.Context, sid, base string) error {\n+\t\treturn nil\n+\t})\n+\tassert.NoError(t, err)\n+\tassert.True(t, s.IsInitialized())\n+\n+\t// Reset\n+\ts.ResetInitialized()\n+\tassert.False(t, s.IsInitialized())\n+}\n+\n+func TestSession_ResetInitialized_AllowsReInit(t *testing.T) {\n+\ts := &Session{ID: \"s1\", BaseURL: \"/test\"}\n+\n+\tvar callCount atomic.Int32\n+\n+\t// First init\n+\terr := s.EnsureInitialized(context.Background(), func(ctx context.Context, sid, base string) error {\n+\t\tcallCount.Add(1)\n+\t\treturn nil\n+\t})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, int32(1), callCount.Load())\n+\n+\t// Reset and re-init\n+\ts.ResetInitialized()\n+\terr = s.EnsureInitialized(context.Background(), func(ctx context.Context, sid, base string) error {\n+\t\tcallCount.Add(1)\n+\t\treturn nil\n+\t})\n+\tassert.NoError(t, err)\n+\tassert.True(t, s.IsInitialized())\n+\tassert.Equal(t, int32(2), callCount.Load())\n+}\n+\n+func TestSession_EnsureInitialized_RetryAfterError(t *testing.T) {\n+\ts := &Session{ID: \"s1\", BaseURL: \"/test\"}\n+\n+\tvar callCount atomic.Int32\n+\tinitFn := func(ctx context.Context, sessionID, baseURL string) error {\n+\t\tn := callCount.Add(1)\n+\t\tif n == 1 {\n+\t\t\treturn fmt.Errorf(\"transient error\")\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\terr := s.EnsureInitialized(context.Background(), initFn)\n+\tassert.Error(t, err)\n+\tassert.False(t, s.IsInitialized())\n+\n+\terr = s.EnsureInitialized(context.Background(), initFn)\n+\tassert.NoError(t, err)\n+\tassert.True(t, s.IsInitialized())\n+\tassert.Equal(t, int32(2), callCount.Load())\n+}\ndiff --git a/mcp-proxy/internal/mcp/sse.go b/mcp-proxy/internal/mcp/sse.go\nnew file mode 100644\nindex 000000000..cef6916af\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/sse.go\n@@ -0,0 +1,51 @@\n+package mcp\n+\n+import (\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"sync\"\n+)\n+\n+// SSEWriter writes Server-Sent Events to an http.ResponseWriter.\n+// All methods are safe for concurrent use.\n+type SSEWriter struct {\n+\tmu      sync.Mutex\n+\tw       http.ResponseWriter\n+\tflusher http.Flusher\n+}\n+\n+// NewSSEWriter creates an SSE writer.\n+// It returns an error if the ResponseWriter does not implement http.Flusher.\n+func NewSSEWriter(w http.ResponseWriter) (*SSEWriter, error) {\n+\tf, ok := w.(http.Flusher)\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"streaming not supported\")\n+\t}\n+\treturn &SSEWriter{w: w, flusher: f}, nil\n+}\n+\n+// WriteEvent sends an SSE \"message\" event with the given data.\n+func (s *SSEWriter) WriteEvent(data []byte) error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\t_, err := fmt.Fprintf(s.w, \"event:message\\ndata:%s\\n\\n\", data)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\ts.flusher.Flush()\n+\treturn nil\n+}\n+\n+// WritePing sends an SSE comment line as a keep-alive ping.\n+func (s *SSEWriter) WritePing() error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\t_, err := fmt.Fprint(s.w, \":ping\\n\\n\")\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\ts.flusher.Flush()\n+\treturn nil\n+}\ndiff --git a/mcp-proxy/internal/mcp/sse_test.go b/mcp-proxy/internal/mcp/sse_test.go\nnew file mode 100644\nindex 000000000..cfbfb6a29\n--- /dev/null\n+++ b/mcp-proxy/internal/mcp/sse_test.go\n@@ -0,0 +1,65 @@\n+package mcp\n+\n+import (\n+\t\"net/http\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+// flushRecorder wraps a simple buffer that implements http.ResponseWriter + http.Flusher.\n+type flushRecorder struct {\n+\tbuf     []byte\n+\theaders http.Header\n+\tcode    int\n+\tflushed int\n+}\n+\n+func newFlushRecorder() *flushRecorder {\n+\treturn &flushRecorder{headers: make(http.Header)}\n+}\n+\n+func (f *flushRecorder) Header() http.Header        { return f.headers }\n+func (f *flushRecorder) WriteHeader(code int)        { f.code = code }\n+func (f *flushRecorder) Write(b []byte) (int, error) { f.buf = append(f.buf, b...); return len(b), nil }\n+func (f *flushRecorder) Flush()                      { f.flushed++ }\n+\n+func TestSSEWriter_WriteEvent(t *testing.T) {\n+\trec := newFlushRecorder()\n+\tw, err := NewSSEWriter(rec)\n+\trequire.NoError(t, err)\n+\n+\terr = w.WriteEvent([]byte(`{\"jsonrpc\":\"2.0\",\"method\":\"notifications/tools/list_changed\"}`))\n+\trequire.NoError(t, err)\n+\n+\texpected := \"event:message\\ndata:{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"notifications/tools/list_changed\\\"}\\n\\n\"\n+\tassert.Equal(t, expected, string(rec.buf))\n+\tassert.Equal(t, 1, rec.flushed)\n+}\n+\n+func TestSSEWriter_WritePing(t *testing.T) {\n+\trec := newFlushRecorder()\n+\tw, err := NewSSEWriter(rec)\n+\trequire.NoError(t, err)\n+\n+\terr = w.WritePing()\n+\trequire.NoError(t, err)\n+\n+\tassert.Equal(t, \":ping\\n\\n\", string(rec.buf))\n+\tassert.Equal(t, 1, rec.flushed)\n+}\n+\n+func TestNewSSEWriter_NoFlusher(t *testing.T) {\n+\t// A minimal ResponseWriter without Flusher\n+\tw := &noFlushWriter{}\n+\t_, err := NewSSEWriter(w)\n+\tassert.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"streaming not supported\")\n+}\n+\n+type noFlushWriter struct{}\n+\n+func (n *noFlushWriter) Header() http.Header        { return http.Header{} }\n+func (n *noFlushWriter) Write([]byte) (int, error)   { return 0, nil }\n+func (n *noFlushWriter) WriteHeader(int)             {}\ndiff --git a/mcp-proxy/internal/version/version.go b/mcp-proxy/internal/version/version.go\nnew file mode 100644\nindex 000000000..a0322cf74\n--- /dev/null\n+++ b/mcp-proxy/internal/version/version.go\n@@ -0,0 +1,46 @@\n+// Package version exposes build metadata injected via ldflags.\n+package version\n+\n+import (\n+\t\"fmt\"\n+\t\"runtime\"\n+)\n+\n+// Build metadata variables, injected at link time via -ldflags.\n+var (\n+\tGitCommit = \"none\"\n+\tGitBranch = \"unknown\"\n+\tBuildTime = \"unknown\"\n+\tGoVersion = runtime.Version()\n+)\n+\n+// Info holds build metadata for the binary.\n+type Info struct {\n+\tGitCommit string\n+\tGitBranch string\n+\tBuildTime string\n+\tGoVersion string\n+}\n+\n+// Get returns the current build information.\n+func Get() Info {\n+\treturn Info{\n+\t\tGitCommit: GitCommit,\n+\t\tGitBranch: GitBranch,\n+\t\tBuildTime: BuildTime,\n+\t\tGoVersion: GoVersion,\n+\t}\n+}\n+\n+// String formats the build information as a single line.\n+func (i Info) String() string {\n+\tcommitShort := i.GitCommit\n+\tif len(commitShort) > 7 {\n+\t\tcommitShort = commitShort[:7]\n+\t}\n+\n+\treturn fmt.Sprintf(\n+\t\t\"build: %s, commit: %s, branch: %s runtime: %s\",\n+\t\ti.BuildTime, commitShort, i.GitBranch, i.GoVersion,\n+\t)\n+}\ndiff --git a/mcp-proxy/pkg/jsonrpc/jsonrpc.go b/mcp-proxy/pkg/jsonrpc/jsonrpc.go\nnew file mode 100644\nindex 000000000..eee7e1f23\n--- /dev/null\n+++ b/mcp-proxy/pkg/jsonrpc/jsonrpc.go\n@@ -0,0 +1,94 @@\n+// Package jsonrpc provides JSON-RPC 2.0 request/response helpers.\n+package jsonrpc\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+)\n+\n+// Standard JSON-RPC 2.0 error codes.\n+const (\n+\tParseError     = -32700\n+\tInvalidRequest = -32600\n+\tMethodNotFound = -32601\n+\tInvalidParams  = -32602\n+\tInternalError  = -32603\n+)\n+\n+// Request represents a JSON-RPC 2.0 request or notification.\n+type Request struct {\n+\tJSONRPC string           `json:\"jsonrpc\"`\n+\tID      *json.RawMessage `json:\"id,omitempty\"`\n+\tMethod  string           `json:\"method\"`\n+\tParams  *json.RawMessage `json:\"params,omitempty\"`\n+}\n+\n+// Response represents a JSON-RPC 2.0 response.\n+type Response struct {\n+\tJSONRPC string           `json:\"jsonrpc\"`\n+\tID      *json.RawMessage `json:\"id,omitempty\"`\n+\tResult  *json.RawMessage `json:\"result,omitempty\"`\n+\tError   *ErrorObject     `json:\"error,omitempty\"`\n+}\n+\n+// ErrorObject holds a JSON-RPC 2.0 error.\n+type ErrorObject struct {\n+\tCode    int              `json:\"code\"`\n+\tMessage string           `json:\"message\"`\n+\tData    *json.RawMessage `json:\"data,omitempty\"`\n+}\n+\n+// Parse decodes raw bytes into a JSON-RPC request.\n+func Parse(data []byte) (*Request, error) {\n+\tvar req Request\n+\tif err := json.Unmarshal(data, &req); err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid JSON: %w\", err)\n+\t}\n+\tif req.Method == \"\" {\n+\t\treturn nil, fmt.Errorf(\"missing method field\")\n+\t}\n+\treturn &req, nil\n+}\n+\n+// IsNotification reports whether the request has no ID (i.e. is a notification).\n+func (r *Request) IsNotification() bool {\n+\treturn r.ID == nil\n+}\n+\n+// NewResponse creates a successful JSON-RPC response.\n+func NewResponse(id *json.RawMessage, result json.RawMessage) *Response {\n+\treturn &Response{\n+\t\tJSONRPC: \"2.0\",\n+\t\tID:      id,\n+\t\tResult:  &result,\n+\t}\n+}\n+\n+// Notification represents a JSON-RPC 2.0 notification (no id).\n+type Notification struct {\n+\tJSONRPC string `json:\"jsonrpc\"`\n+\tMethod  string `json:\"method\"`\n+\tParams  any    `json:\"params,omitempty\"`\n+}\n+\n+// NewNotification creates a JSON-RPC notification.\n+func NewNotification(method string, params any) *Notification {\n+\treturn &Notification{\n+\t\tJSONRPC: \"2.0\",\n+\t\tMethod:  method,\n+\t\tParams:  params,\n+\t}\n+}\n+\n+// NewErrorResponse creates an error JSON-RPC response.\n+func NewErrorResponse(id *json.RawMessage, code int, message string, data *json.RawMessage) *Response {\n+\treturn &Response{\n+\t\tJSONRPC: \"2.0\",\n+\t\tID:      id,\n+\t\tError: &ErrorObject{\n+\t\t\tCode:    code,\n+\t\t\tMessage: message,\n+\t\t\tData:    data,\n+\t\t},\n+\t}\n+}\ndiff --git a/mcp-proxy/pkg/jsonrpc/jsonrpc_test.go b/mcp-proxy/pkg/jsonrpc/jsonrpc_test.go\nnew file mode 100644\nindex 000000000..951dddf78\n--- /dev/null\n+++ b/mcp-proxy/pkg/jsonrpc/jsonrpc_test.go\n@@ -0,0 +1,111 @@\n+package jsonrpc\n+\n+import (\n+\t\"encoding/json\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestParse_ValidRequest(t *testing.T) {\n+\tdata := []byte(`{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-03-26\"}}`)\n+\n+\treq, err := Parse(data)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"2.0\", req.JSONRPC)\n+\tassert.Equal(t, \"initialize\", req.Method)\n+\tassert.NotNil(t, req.ID)\n+\tassert.NotNil(t, req.Params)\n+}\n+\n+func TestParse_StringID(t *testing.T) {\n+\tdata := []byte(`{\"jsonrpc\":\"2.0\",\"id\":\"abc\",\"method\":\"ping\"}`)\n+\n+\treq, err := Parse(data)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"ping\", req.Method)\n+\n+\tvar id string\n+\trequire.NoError(t, json.Unmarshal(*req.ID, &id))\n+\tassert.Equal(t, \"abc\", id)\n+}\n+\n+func TestParse_InvalidJSON(t *testing.T) {\n+\tdata := []byte(`{invalid`)\n+\n+\t_, err := Parse(data)\n+\tassert.Error(t, err)\n+}\n+\n+func TestParse_MissingMethod(t *testing.T) {\n+\tdata := []byte(`{\"jsonrpc\":\"2.0\",\"id\":1}`)\n+\n+\t_, err := Parse(data)\n+\tassert.Error(t, err)\n+}\n+\n+func TestIsNotification_NoID(t *testing.T) {\n+\tdata := []byte(`{\"jsonrpc\":\"2.0\",\"method\":\"notifications/initialized\"}`)\n+\n+\treq, err := Parse(data)\n+\trequire.NoError(t, err)\n+\tassert.True(t, req.IsNotification())\n+}\n+\n+func TestIsNotification_WithID(t *testing.T) {\n+\tdata := []byte(`{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"ping\"}`)\n+\n+\treq, err := Parse(data)\n+\trequire.NoError(t, err)\n+\tassert.False(t, req.IsNotification())\n+}\n+\n+func TestNewResponse(t *testing.T) {\n+\tid := json.RawMessage(`1`)\n+\tresult := json.RawMessage(`{\"tools\":[]}`)\n+\n+\tresp := NewResponse(&id, result)\n+\tassert.Equal(t, \"2.0\", resp.JSONRPC)\n+\tassert.Equal(t, json.RawMessage(`1`), *resp.ID)\n+\tassert.Equal(t, result, *resp.Result)\n+\tassert.Nil(t, resp.Error)\n+}\n+\n+func TestNewErrorResponse(t *testing.T) {\n+\tid := json.RawMessage(`1`)\n+\n+\tresp := NewErrorResponse(&id, MethodNotFound, \"Method not found\", nil)\n+\tassert.Equal(t, \"2.0\", resp.JSONRPC)\n+\tassert.NotNil(t, resp.Error)\n+\tassert.Equal(t, MethodNotFound, resp.Error.Code)\n+\tassert.Equal(t, \"Method not found\", resp.Error.Message)\n+\tassert.Nil(t, resp.Result)\n+}\n+\n+func TestNewErrorResponse_NilID(t *testing.T) {\n+\tresp := NewErrorResponse(nil, ParseError, \"Parse error\", nil)\n+\tassert.Nil(t, resp.ID)\n+\tassert.Equal(t, ParseError, resp.Error.Code)\n+}\n+\n+func TestErrorCodes(t *testing.T) {\n+\tassert.Equal(t, -32700, ParseError)\n+\tassert.Equal(t, -32600, InvalidRequest)\n+\tassert.Equal(t, -32601, MethodNotFound)\n+\tassert.Equal(t, -32602, InvalidParams)\n+\tassert.Equal(t, -32603, InternalError)\n+}\n+\n+func TestResponse_Marshal(t *testing.T) {\n+\tid := json.RawMessage(`1`)\n+\tresult := json.RawMessage(`{}`)\n+\tresp := NewResponse(&id, result)\n+\n+\tdata, err := json.Marshal(resp)\n+\trequire.NoError(t, err)\n+\n+\tvar parsed map[string]any\n+\trequire.NoError(t, json.Unmarshal(data, &parsed))\n+\tassert.Equal(t, \"2.0\", parsed[\"jsonrpc\"])\n+}\ndiff --git a/mcp-proxy/pkg/sessionid/sessionid.go b/mcp-proxy/pkg/sessionid/sessionid.go\nnew file mode 100644\nindex 000000000..9aaa02897\n--- /dev/null\n+++ b/mcp-proxy/pkg/sessionid/sessionid.go\n@@ -0,0 +1,148 @@\n+// Package sessionid encodes routing information into MCP session identifiers.\n+//\n+// A session ID has the format \"{XOR+Base62(backend-addr:proxy-id)}:{short-id}\"\n+// where the routing part is obfuscated so internal infrastructure details\n+// are not exposed to clients via the Mcp-Session-Id header.\n+package sessionid\n+\n+import (\n+\t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"math/big\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+const (\n+\tshortIDLen = 8\n+\tshortIDSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n+\tb62Charset = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n+)\n+\n+var (\n+\tb62Base = big.NewInt(62)\n+\txorKey  = func() []byte {\n+\t\tif key := os.Getenv(\"MCP_SESSION_XOR_KEY\"); key != \"\" {\n+\t\t\treturn []byte(key)\n+\t\t}\n+\t\treturn []byte(\"duplo-mcp-default-key\")\n+\t}()\n+)\n+\n+// ID holds the components of a routable session identifier.\n+type ID struct {\n+\tBackendAddr string // Backend pod IP or hostname (no port).\n+\tProxyID     string // Proxy instance identifier.\n+\tShortID     string // 8-char random alphanumeric identifier.\n+}\n+\n+// New creates a session ID with a fresh random short ID.\n+func New(backendAddr, proxyID string) ID {\n+\treturn ID{\n+\t\tBackendAddr: backendAddr,\n+\t\tProxyID:     proxyID,\n+\t\tShortID:     generateShortID(),\n+\t}\n+}\n+\n+// Parse decodes an encoded session ID string into its components.\n+func Parse(raw string) (ID, error) {\n+\tidx := strings.LastIndex(raw, \":\")\n+\tif idx <= 0 || idx >= len(raw)-1 {\n+\t\treturn ID{}, fmt.Errorf(\"invalid session id: bad format\")\n+\t}\n+\n+\trouting, err := decodeRouting(raw[:idx])\n+\tif err != nil {\n+\t\treturn ID{}, fmt.Errorf(\"invalid session id: %w\", err)\n+\t}\n+\n+\tsep := strings.LastIndex(routing, \":\")\n+\tif sep <= 0 || sep >= len(routing)-1 {\n+\t\treturn ID{}, fmt.Errorf(\"invalid session id: bad routing\")\n+\t}\n+\n+\treturn ID{\n+\t\tBackendAddr: routing[:sep],\n+\t\tProxyID:     routing[sep+1:],\n+\t\tShortID:     raw[idx+1:],\n+\t}, nil\n+}\n+\n+// String encodes the session ID as \"{XOR+Base62(backend-addr:proxy-id)}:{short-id}\".\n+func (id ID) String() string {\n+\treturn encodeRouting(id.BackendAddr+\":\"+id.ProxyID) + \":\" + id.ShortID\n+}\n+\n+// generateShortID returns 8 random characters from [A-Za-z0-9].\n+func generateShortID() string {\n+\tb := make([]byte, shortIDLen)\n+\tif _, err := rand.Read(b); err != nil {\n+\t\tpanic(\"crypto/rand: \" + err.Error())\n+\t}\n+\tfor i := range b {\n+\t\tb[i] = shortIDSet[b[i]%byte(len(shortIDSet))]\n+\t}\n+\treturn string(b)\n+}\n+\n+func encodeRouting(s string) string {\n+\treturn base62Encode(xorBytes([]byte(s)))\n+}\n+\n+func decodeRouting(s string) (string, error) {\n+\tdata, err := base62Decode(s)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn string(xorBytes(data)), nil\n+}\n+\n+// xorBytes applies repeating-key XOR. Symmetric: xor(xor(x)) == x.\n+func xorBytes(data []byte) []byte {\n+\tout := make([]byte, len(data))\n+\tfor i, b := range data {\n+\t\tout[i] = b ^ xorKey[i%len(xorKey)]\n+\t}\n+\treturn out\n+}\n+\n+// base62Encode encodes bytes to a Base62 string using math/big.\n+// A 0x01 sentinel is prepended to preserve leading zero bytes.\n+func base62Encode(data []byte) string {\n+\tif len(data) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tn := new(big.Int).SetBytes(append([]byte{1}, data...))\n+\tmod := new(big.Int)\n+\tvar buf []byte\n+\tfor n.Sign() > 0 {\n+\t\tn.DivMod(n, b62Base, mod)\n+\t\tbuf = append(buf, b62Charset[mod.Int64()])\n+\t}\n+\tfor i, j := 0, len(buf)-1; i < j; i, j = i+1, j-1 {\n+\t\tbuf[i], buf[j] = buf[j], buf[i]\n+\t}\n+\treturn string(buf)\n+}\n+\n+// base62Decode decodes a Base62 string back to bytes.\n+func base62Decode(s string) ([]byte, error) {\n+\tif s == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\tn := new(big.Int)\n+\tfor i := 0; i < len(s); i++ {\n+\t\tidx := strings.IndexByte(b62Charset, s[i])\n+\t\tif idx < 0 {\n+\t\t\treturn nil, fmt.Errorf(\"invalid base62 character: %c\", s[i])\n+\t\t}\n+\t\tn.Mul(n, b62Base)\n+\t\tn.Add(n, big.NewInt(int64(idx)))\n+\t}\n+\tb := n.Bytes()\n+\tif len(b) == 0 || b[0] != 1 {\n+\t\treturn nil, fmt.Errorf(\"invalid base62 data: missing sentinel\")\n+\t}\n+\treturn b[1:], nil\n+}\ndiff --git a/mcp-proxy/pkg/sessionid/sessionid_test.go b/mcp-proxy/pkg/sessionid/sessionid_test.go\nnew file mode 100644\nindex 000000000..893493df8\n--- /dev/null\n+++ b/mcp-proxy/pkg/sessionid/sessionid_test.go\n@@ -0,0 +1,123 @@\n+package sessionid\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestNew(t *testing.T) {\n+\tid := New(\"10.0.0.1\", \"proxy-a\")\n+\n+\tassert.Equal(t, \"10.0.0.1\", id.BackendAddr)\n+\tassert.Equal(t, \"proxy-a\", id.ProxyID)\n+\tassert.Len(t, id.ShortID, 8)\n+\tassert.Regexp(t, `^[A-Za-z0-9]{8}$`, id.ShortID)\n+}\n+\n+func TestNew_UniqueShortIDs(t *testing.T) {\n+\ta := New(\"host\", \"proxy\")\n+\tb := New(\"host\", \"proxy\")\n+\tassert.NotEqual(t, a.ShortID, b.ShortID)\n+}\n+\n+func TestString_Obfuscated(t *testing.T) {\n+\tid := New(\"10.0.0.1\", \"proxy-a\")\n+\ts := id.String()\n+\n+\tassert.NotContains(t, s, \"10.0.0.1\", \"backend-addr must be obfuscated\")\n+\tassert.NotContains(t, s, \"proxy-a\", \"proxy-id must be obfuscated\")\n+\tassert.Equal(t, 1, strings.Count(s, \":\"), \"encoded string must have exactly one colon\")\n+}\n+\n+func TestParse_RoundTrip(t *testing.T) {\n+\ttests := []struct {\n+\t\tname        string\n+\t\tbackendAddr string\n+\t\tproxyID     string\n+\t}{\n+\t\t{\"ip address\", \"10.0.0.1\", \"proxy-a\"},\n+\t\t{\"hostname\", \"backend-pod-0.svc.cluster.local\", \"mcp-proxy-7b\"},\n+\t\t{\"short names\", \"b\", \"p\"},\n+\t\t{\"ipv6 loopback\", \"::1\", \"proxy-v6\"},\n+\t\t{\"ipv6 full\", \"fd00::cafe:1\", \"proxy-v6\"},\n+\t\t{\"ipv6 with zone\", \"fe80::1%25eth0\", \"proxy-z\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\toriginal := New(tt.backendAddr, tt.proxyID)\n+\n+\t\t\tparsed, err := Parse(original.String())\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Equal(t, original, parsed)\n+\t\t})\n+\t}\n+}\n+\n+func TestParse_Errors(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\traw     string\n+\t\twantErr string\n+\t}{\n+\t\t{\n+\t\t\tname:    \"empty string\",\n+\t\t\traw:     \"\",\n+\t\t\twantErr: \"invalid session id\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"no colon\",\n+\t\t\traw:     \"abcdef12345678\",\n+\t\t\twantErr: \"invalid session id\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"empty routing part\",\n+\t\t\traw:     \":aB3kL9xZ\",\n+\t\t\twantErr: \"invalid session id\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"empty short id\",\n+\t\t\traw:     \"2FsK9xQmR7vBzT:\",\n+\t\t\twantErr: \"invalid session id\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid base62 in routing\",\n+\t\t\traw:     \"!!!invalid!!!:aB3kL9xZ\",\n+\t\t\twantErr: \"invalid session id\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t_, err := Parse(tt.raw)\n+\t\t\trequire.Error(t, err)\n+\t\t\tassert.Contains(t, err.Error(), tt.wantErr)\n+\t\t})\n+\t}\n+}\n+\n+func TestBase62_RoundTrip(t *testing.T) {\n+\tinputs := [][]byte{\n+\t\t[]byte(\"hello world\"),\n+\t\t[]byte(\"10.0.0.1:proxy-a\"),\n+\t\t{0, 0, 1, 2, 3}, // leading zeros\n+\t\t{255, 254, 253},\n+\t}\n+\n+\tfor _, input := range inputs {\n+\t\tencoded := base62Encode(input)\n+\t\tdecoded, err := base62Decode(encoded)\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, input, decoded)\n+\t}\n+}\n+\n+func TestXOR_RoundTrip(t *testing.T) {\n+\toriginal := []byte(\"10.0.0.1:proxy-a\")\n+\tencrypted := xorBytes(original)\n+\tdecrypted := xorBytes(encrypted)\n+\tassert.Equal(t, original, decrypted)\n+}\ndiff --git a/mcp-proxy/scripts/generate_proto.sh b/mcp-proxy/scripts/generate_proto.sh\nnew file mode 100755\nindex 000000000..7674e8dfa\n--- /dev/null\n+++ b/mcp-proxy/scripts/generate_proto.sh\n@@ -0,0 +1,28 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n+PROJECT_ROOT=\"$(cd \"$SCRIPT_DIR/..\" && pwd)\"\n+PROTO_DIR=\"$PROJECT_ROOT/../resource/proto\"\n+\n+GOBIN=\"$(go env GOPATH)/bin\"\n+PROTOC_GEN_GO=\"$GOBIN/protoc-gen-go\"\n+PROTOC_GEN_GO_GRPC=\"$GOBIN/protoc-gen-go-grpc\"\n+\n+# go_package in proto = \"gen/duplo/mcp/v1;mcpv1\"\n+# M option overrides go_package to include module prefix for module-based output\n+MCP_PROTO=\"duplo/mcp/v1/mcp_connector.proto\"\n+GO_PKG=\"mcp-proxy/gen/duplo/mcp/v1;mcpv1\"\n+\n+echo \"  proto: duplo/mcp/v1...\"\n+protoc \\\n+  --proto_path=\"$PROTO_DIR\" \\\n+  --plugin=protoc-gen-go=\"$PROTOC_GEN_GO\" \\\n+  --plugin=protoc-gen-go-grpc=\"$PROTOC_GEN_GO_GRPC\" \\\n+  --go_out=\"$PROJECT_ROOT\" \\\n+  --go_opt=\"module=mcp-proxy,M${MCP_PROTO}=${GO_PKG}\" \\\n+  --go-grpc_out=\"$PROJECT_ROOT\" \\\n+  --go-grpc_opt=\"module=mcp-proxy,require_unimplemented_servers=false,M${MCP_PROTO}=${GO_PKG}\" \\\n+  \"$PROTO_DIR/$MCP_PROTO\"\n+\n+echo \"Done.\"\ndiff --git a/resource/proto/buf.yaml b/resource/proto/buf.yaml\nnew file mode 100644\nindex 000000000..c286a2935\n--- /dev/null\n+++ b/resource/proto/buf.yaml\n@@ -0,0 +1,11 @@\n+version: v2\n+modules:\n+  - path: .\n+lint:\n+  use:\n+    - STANDARD\n+  except:\n+    - PACKAGE_VERSION_SUFFIX\n+breaking:\n+  use:\n+    - FILE\ndiff --git a/resource/proto/duplo/mcp/v1/mcp_connector.proto b/resource/proto/duplo/mcp/v1/mcp_connector.proto\nnew file mode 100644\nindex 000000000..aa1d4a30d\n--- /dev/null\n+++ b/resource/proto/duplo/mcp/v1/mcp_connector.proto\n@@ -0,0 +1,334 @@\n+// MCP Connector gRPC Service\n+//\n+// Go Proxy ↔ Kotlin Backend 간 gRPC 인터페이스 정의\n+// Go Proxy가 클라이언트 연결·인증·세션 관리를 담당하고,\n+// Kotlin Backend가 커넥터·비즈니스 로직을 담당한다\n+\n+syntax = \"proto3\";\n+\n+package duplo.mcp.v1;\n+\n+option java_multiple_files = true;\n+option java_package = \"io.querypie.duplo.mcp.v1\";\n+option go_package = \"gen/duplo/mcp/v1;mcpv1\";\n+\n+import \"google/protobuf/struct.proto\";\n+\n+// Go Proxy ↔ Kotlin Backend 간 MCP 커넥터 서비스\n+service McpConnectorService {\n+  // 단일 요청-응답. oneof payload로 메시지를 구분한다\n+  rpc Send(SendRequest) returns (SendResponse);\n+\n+  // 양방향 스트리밍. Go Proxy ↔ Backend 연결 단위(멀티플렉싱)\n+  // 여러 세션의 메시지가 session_id로 구분되어 하나의 스트림에서 교환된다\n+  rpc Channel(stream ChannelRequest) returns (stream ChannelResponse);\n+}\n+\n+// Send RPC 요청 envelope\n+message SendRequest {\n+  oneof payload {\n+    CreateSessionRequest create_session = 10;\n+    ListToolsRequest list_tools = 11;\n+    CloseSessionRequest close_session = 12;\n+    SendNotificationRequest send_notification = 13;\n+    QuerySessionRequest query_session = 14;\n+    DeleteSessionRequest delete_session = 15;\n+    VerifyAccessKeyRequest verify_access_key = 16;\n+    CallToolSendRequest call_tool = 17;\n+  }\n+}\n+\n+// Send RPC 응답 envelope\n+message SendResponse {\n+  oneof payload {\n+    ErrorResponse error = 10;\n+    CreateSessionResponse create_session = 11;\n+    ListToolsResponse list_tools = 12;\n+    CloseSessionResponse close_session = 13;\n+    SendNotificationResponse send_notification = 14;\n+    QuerySessionResponse query_session = 15;\n+    DeleteSessionResponse delete_session = 16;\n+    VerifyAccessKeyResponse verify_access_key = 17;\n+    CallToolResult call_tool = 18;\n+  }\n+}\n+\n+// Send RPC용 도구 호출 요청 (session_id 래핑)\n+message CallToolSendRequest {\n+  string session_id = 1;\n+  CallToolPayload payload = 2;\n+}\n+\n+// MCP 세션 생성 요청\n+message CreateSessionRequest {\n+  // Agent installation path (라우팅 키)\n+  string base_url = 1;\n+  // Go Proxy가 인증 후 전달하는 사용자 정보\n+  AuthContext auth_context = 2;\n+  ClientInfo client_info = 3;\n+  // e.g. \"2025-03-26\"\n+  string protocol_version = 4;\n+  // JSON string — Struct 대신 원본 보존\n+  string client_capabilities_json = 5;\n+  McpClientInfo mcp_client_info = 6;\n+  // Proxy가 생성한 세션 ID. 세션 ID의 소유권은 Proxy에 있다.\n+  // Backend는 이 값을 세션 식별자로 사용해야 한다.\n+  string session_id = 7;\n+}\n+\n+// MCP 세션 생성 응답\n+message CreateSessionResponse {\n+  // Deprecated: Proxy가 전달한 session_id를 echo back. 새 코드에서는 무시.\n+  string session_id = 1;\n+  ServerCapabilities server_capabilities = 2;\n+  ServerInfo server_info = 3;\n+  string protocol_version = 4;\n+  // 최적화용 초기 도구 목록. Backend가 즉시 로드하지 않으면 빈 배열\n+  repeated Tool tools = 5;\n+  string instructions = 6;\n+}\n+\n+// 도구 목록 조회 요청\n+message ListToolsRequest {\n+  string session_id = 1;\n+  // 페이지네이션 커서\n+  string cursor = 2;\n+}\n+\n+// 도구 목록 조회 응답\n+message ListToolsResponse {\n+  repeated Tool tools = 1;\n+  // 빈 문자열이면 마지막 페이지\n+  string next_cursor = 2;\n+}\n+\n+// 세션 종료 요청\n+message CloseSessionRequest {\n+  string session_id = 1;\n+}\n+\n+// 세션 종료 응답\n+message CloseSessionResponse {}\n+\n+// JSON-RPC notification 전달 요청\n+message SendNotificationRequest {\n+  string session_id = 1;\n+  // e.g. \"notifications/cancelled\"\n+  string method = 2;\n+  // JSON string\n+  string params_json = 3;\n+}\n+\n+// JSON-RPC notification 전달 응답\n+message SendNotificationResponse {}\n+\n+// 세션 존재 여부 조회 요청\n+message QuerySessionRequest {\n+  string session_id = 1;\n+}\n+\n+// 세션 존재 여부\n+enum SessionExistence {\n+  SESSION_EXISTENCE_UNSPECIFIED = 0;\n+  SESSION_EXISTENCE_EXISTS = 1;\n+  SESSION_EXISTENCE_NOT_EXISTS = 2;\n+}\n+\n+// 세션 존재 여부 조회 응답\n+message QuerySessionResponse {\n+  SessionExistence existence = 1;\n+}\n+\n+// 세션 삭제 요청. session_id 또는 agent_installation_id로 대상 지정\n+message DeleteSessionRequest {\n+  oneof target {\n+    string session_id = 1;\n+    string agent_installation_id = 2;\n+  }\n+}\n+\n+// 세션 삭제 응답\n+message DeleteSessionResponse {\n+  int32 deleted_count = 1;\n+}\n+\n+// CLI HTTP 서명 인증 시 AccessKey 검증 위임 요청\n+// Go Proxy는 서명을 자체 검증할 수 없으므로(DeviceID/Secret이 Backend DB에 존재),\n+// Backend에 유효성 확인을 위임한다\n+message VerifyAccessKeyRequest {\n+  // 설치 과정에서 발급된 AccessKey\n+  string access_key = 1;\n+  string preset_id = 2;\n+}\n+\n+// AccessKey 검증 응답\n+message VerifyAccessKeyResponse {\n+  bool valid = 1;\n+  // 검증 성공 시 CreateSession의 AuthContext로 사용\n+  string user_id = 2;\n+  string device_id = 3;\n+}\n+\n+// gRPC 에러 응답\n+message ErrorResponse {\n+  int32 code = 1;\n+  string message = 2;\n+  string details_json = 3;\n+}\n+\n+// Channel RPC — Go Proxy → Backend 스트림 메시지\n+message ChannelRequest {\n+  // 세션 멀티플렉싱 키 (ping/pong에서는 빈 문자열)\n+  string session_id = 2;\n+  // 요청-응답 매칭 키 (CallTool → CallToolResult/Progress)\n+  string request_id = 3;\n+  oneof payload {\n+    ErrorResponse error = 10;\n+    CallToolPayload call_tool = 11;\n+    SubscribeEventsPayload subscribe_events = 12;\n+    UnsubscribeEventsPayload unsubscribe_events = 13;\n+    PingPayload ping = 14;\n+  }\n+}\n+\n+// Channel RPC — Backend → Go Proxy 스트림 메시지\n+message ChannelResponse {\n+  // 세션 멀티플렉싱 키 (ping/pong에서는 빈 문자열)\n+  string session_id = 2;\n+  // 요청-응답 매칭 키 (CallTool → CallToolResult/Progress)\n+  string request_id = 3;\n+  oneof payload {\n+    ErrorResponse error = 10;\n+    ProgressNotification progress = 11;\n+    CallToolResult call_tool_result = 12;\n+    ToolListChangedEvent tool_list_changed = 13;\n+    LoggingMessageEvent logging_message = 14;\n+    PongPayload pong = 15;\n+  }\n+}\n+\n+// 도구 호출 요청 payload\n+message CallToolPayload {\n+  string name = 1;\n+  // JSON string (int64/double 등 원본 타입 보존)\n+  string arguments_json = 2;\n+  google.protobuf.Struct meta = 3;\n+}\n+\n+// 도구 호출 결과\n+message CallToolResult {\n+  repeated Content content = 1;\n+  bool is_error = 2;\n+  google.protobuf.Struct meta = 3;\n+}\n+\n+// 세션의 비동기 이벤트 구독 시작\n+message SubscribeEventsPayload {}\n+\n+// 세션의 비동기 이벤트 구독 해제\n+message UnsubscribeEventsPayload {}\n+\n+// 연결 헬스체크 요청\n+message PingPayload {}\n+\n+// 연결 헬스체크 응답\n+message PongPayload {}\n+\n+// 도구 실행 중 진행 상황 알림\n+message ProgressNotification {\n+  string progress_token = 1;\n+  optional double progress = 2;  // null = indeterminate\n+  optional double total = 3;     // null = unknown total\n+  string message = 4;\n+}\n+\n+// 도구 목록 변경 알림\n+message ToolListChangedEvent {}\n+\n+// MCP 로깅 메시지\n+message LoggingMessageEvent {\n+  // debug, info, notice, warning, error, critical, alert, emergency\n+  string level = 1;\n+  string logger = 2;\n+  string data_json = 3;\n+}\n+\n+// Go Proxy가 인증 후 전달하는 사용자 컨텍스트\n+message AuthContext {\n+  string user_id = 1;\n+  AuthMethod auth_method = 2;\n+  map<string, string> metadata = 3;\n+}\n+\n+// 인증 방식\n+enum AuthMethod {\n+  AUTH_METHOD_UNSPECIFIED = 0;\n+  AUTH_METHOD_OAUTH = 1;\n+  AUTH_METHOD_HTTP_SIGNATURE = 2;\n+}\n+\n+// MCP 클라이언트 접속 메타정보\n+message ClientInfo {\n+  string ip = 1;\n+  string user_agent = 2;\n+  string conversation_id = 3;\n+}\n+\n+// MCP 클라이언트 구현체 정보\n+message McpClientInfo {\n+  string name = 1;\n+  string version = 2;\n+}\n+\n+// MCP 서버 기능\n+message ServerCapabilities {\n+  ToolsCapability tools = 1;\n+  LoggingCapability logging = 2;\n+}\n+\n+// 도구 관련 기능\n+message ToolsCapability {\n+  bool list_changed = 1;\n+}\n+\n+// 로깅 관련 기능. 향후 설정 필드 추가 가능\n+message LoggingCapability {}\n+\n+// MCP 서버 구현체 정보\n+message ServerInfo {\n+  string name = 1;\n+  string version = 2;\n+}\n+\n+// MCP 도구 정의\n+message Tool {\n+  string name = 1;\n+  string description = 2;\n+  // JSON Schema (JSON string)\n+  string input_schema_json = 3;\n+  string displayed_description = 4;\n+  string integration_id = 5;\n+  string integration_name = 6;\n+  string installed_integration_id = 7;\n+  string installed_integration_name = 8;\n+  google.protobuf.Struct meta = 9;\n+}\n+\n+// 도구 실행 결과 콘텐츠\n+message Content {\n+  oneof content {\n+    TextContent text = 1;\n+    ImageContent image = 2;\n+  }\n+}\n+\n+// 텍스트 콘텐츠\n+message TextContent {\n+  string text = 1;\n+}\n+\n+// 이미지 콘텐츠 (Base64 인코딩)\n+message ImageContent {\n+  string data = 1;\n+  string mime_type = 2;\n+}","knowledge":{"conventions":"","decisions":"","ignore_rules":"","review_examples":"","extra":{}},"files":["backend/api/build.gradle.kts","backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcAccessKeyVerifierImpl.kt","backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/grpc/GrpcConnectorProviderImpl.kt","backend/api/src/main/kotlin/com/querypie/duplo/api/preset/proxy/interceptor/ClientInfoContextInterceptor.kt","backend/app/build.gradle.kts","backend/app/src/main/resources/application.yaml","backend/buildSrc/build.gradle.kts","backend/gradle/libs.versions.toml","backend/mcp/grpc/build.gradle.kts","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerConfig.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/config/GrpcServerProperties.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConverters.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandler.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/GrpcErrorCodes.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/McpConnectorGrpcService.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandler.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManager.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcAccessKeyVerifier.kt","backend/mcp/grpc/src/main/kotlin/com/querypie/duplo/mcp/grpc/spi/GrpcConnectorProvider.kt","backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/converter/ProtoConvertersTest.kt","backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/ChannelHandlerTest.kt","backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/service/SendHandlerTest.kt","backend/mcp/grpc/src/test/kotlin/com/querypie/duplo/mcp/grpc/session/GrpcSessionManagerTest.kt","backend/mcp/proxy/build.gradle.kts","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/CollectionUtilsTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/UnifiedMcpTransportServletTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/ClientInfoContextTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/HostCodecTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpMessageBroadcastServiceTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionIdTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServiceTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagementServletTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionManagerTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpSessionServiceTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/McpToolManagerTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/gateway/McpGatewayImplTest.kt","backend/mcp/proxy/src/test/kotlin/com/querypie/duplo/mcp/proxy/mcp/relay/RelayServletTest.kt","backend/settings.gradle.kts","mcp-proxy/.gitignore","mcp-proxy/CLAUDE.md","mcp-proxy/Dockerfile","mcp-proxy/Makefile","mcp-proxy/cmd/server/main.go","mcp-proxy/cmd/server/setup.go","mcp-proxy/gen/duplo/mcp/v1/mcp_connector.pb.go","mcp-proxy/gen/duplo/mcp/v1/mcp_connector_grpc.pb.go","mcp-proxy/go.mod","mcp-proxy/go.sum","mcp-proxy/internal/app/app.go","mcp-proxy/internal/config/common.go","mcp-proxy/internal/config/config.go","mcp-proxy/internal/config/env.go","mcp-proxy/internal/config/files/default.yaml","mcp-proxy/internal/config/load.go","mcp-proxy/internal/grpcclient/backend_pool.go","mcp-proxy/internal/grpcclient/backend_pool_test.go","mcp-proxy/internal/logging/component_writer.go","mcp-proxy/internal/logging/logger.go","mcp-proxy/internal/mcp/auth.go","mcp-proxy/internal/mcp/auth_test.go","mcp-proxy/internal/mcp/backend.go","mcp-proxy/internal/mcp/backend_routing.go","mcp-proxy/internal/mcp/backend_routing_test.go","mcp-proxy/internal/mcp/event_subscriber.go","mcp-proxy/internal/mcp/event_subscriber_test.go","mcp-proxy/internal/mcp/handler.go","mcp-proxy/internal/mcp/handler_test.go","mcp-proxy/internal/mcp/lazy.go","mcp-proxy/internal/mcp/lazy_test.go","mcp-proxy/internal/mcp/middleware.go","mcp-proxy/internal/mcp/middleware_test.go","mcp-proxy/internal/mcp/server.go","mcp-proxy/internal/mcp/session.go","mcp-proxy/internal/mcp/session_cleaner.go","mcp-proxy/internal/mcp/session_cleaner_test.go","mcp-proxy/internal/mcp/session_manager.go","mcp-proxy/internal/mcp/session_manager_test.go","mcp-proxy/internal/mcp/session_test.go","mcp-proxy/internal/mcp/sse.go","mcp-proxy/internal/mcp/sse_test.go","mcp-proxy/internal/version/version.go","mcp-proxy/pkg/jsonrpc/jsonrpc.go","mcp-proxy/pkg/jsonrpc/jsonrpc_test.go","mcp-proxy/pkg/sessionid/sessionid.go","mcp-proxy/pkg/sessionid/sessionid_test.go","mcp-proxy/scripts/generate_proto.sh","resource/proto/buf.yaml","resource/proto/duplo/mcp/v1/mcp_connector.proto"]}